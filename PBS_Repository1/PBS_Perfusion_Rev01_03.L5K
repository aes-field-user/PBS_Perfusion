(*********************************************

  Import-Export
  Version   := RSLogix 5000 v32.03
  Owner     := , 
  Exported  := Mon Nov 13 20:11:21 2023

  Note:  File encoded in UTF-8.  Only edit file in a program 
         which supports UTF-8 (like Notepad, not Wordpad).

**********************************************)
IE_VER := 2.23;

CONTROLLER PBS_Perfusion (Description := "pbs perfusion / oxygenation skid",
                          ProcessorType := "5069-L320ER",
                          Major := 32,
                          RedundancyEnabled := 0,
                          KeepTestEditsOnSwitchOver := 0,
                          SecurityCode := 0,
                          ChangesToDetect := 16#ffff_ffff_ffff_ffff,
                          SFCExecutionControl := "CurrentActive",
                          SFCRestartPosition := "MostRecent",
                          SFCLastScan := "DontScan",
                          SerialNumber := 16#d021_cb27,
                          MatchProjectToController := No,
                          CanUseRPIFromProducer := No,
                          InhibitAutomaticFirmwareUpdate := 0,
                          PassThroughConfiguration := EnabledWithAppend,
                          DownloadProjectDocumentationAndExtendedProperties := Yes,
                          ReportMinorOverflow := 0,
                          EtherNetIPMode := "A1/A2: Dual-IP")
	DATATYPE AMP_Alarm_Word (Description := "Applied Motion Input Assembly - Alarm Word ",
	                         FamilyType := NoFamily)
		SINT ZZZZZZZZZZAMP_Alarm_0 (Hidden := 1);
		BIT Position_Limit ZZZZZZZZZZAMP_Alarm_0 : 0 (Description := "Position Limit");
		BIT CCW_Limit ZZZZZZZZZZAMP_Alarm_0 : 1 (Description := "CCW Limit");
		BIT CW_Limit ZZZZZZZZZZAMP_Alarm_0 : 2 (Description := "CW Limit");
		BIT Over_Temp ZZZZZZZZZZAMP_Alarm_0 : 3 (Description := "Over Temp");
		BIT Excess_Regen_or_Internal_Voltage ZZZZZZZZZZAMP_Alarm_0 : 4 (Description := "Excess Regen or Internal Voltage");
		BIT Over_Voltage ZZZZZZZZZZAMP_Alarm_0 : 5 (Description := "Over Voltage");
		BIT Under_Voltage ZZZZZZZZZZAMP_Alarm_0 : 6 (Description := "Under Voltage");
		BIT Over_Current ZZZZZZZZZZAMP_Alarm_0 : 7 (Description := "Over Current");
		SINT ZZZZZZZZZZAMP_Alarm_9 (Hidden := 1);
		BIT Open_Motor_Windings ZZZZZZZZZZAMP_Alarm_9 : 0 (Description := "Open Motor Windings");
		BIT Bad_Encoder ZZZZZZZZZZAMP_Alarm_9 : 1 (Description := "Bad Encoder");
		BIT Comm_Error ZZZZZZZZZZAMP_Alarm_9 : 2 (Description := "Comm Error");
		BIT Bad_Flash ZZZZZZZZZZAMP_Alarm_9 : 3 (Description := "Bad Flash");
		BIT No_Move ZZZZZZZZZZAMP_Alarm_9 : 4 (Description := "No Move");
		BIT NA_1 ZZZZZZZZZZAMP_Alarm_9 : 5 (Description := "NA 1");
		BIT Blank_Q_Segment ZZZZZZZZZZAMP_Alarm_9 : 6 (Description := "Blank Q Segment");
		BIT NA_2 ZZZZZZZZZZAMP_Alarm_9 : 7 (Description := "NA 2");
	END_DATATYPE

	DATATYPE AMP_Input_Assembly_v2 (Description := "Applied Motion Drive Input Assembly Version 2.0",
	                                FamilyType := NoFamily)
		DINT Status_Code (Description := "Status Code");
		DINT Alarm_Code (Description := "Alarm Code");
		DINT Voltage (Description := "Supply Voltage (x0.1V)");
		DINT Current (Description := "Actual Current (mA)");
		DINT Temp (Description := "Drive Temperature (0.1 deg C)");
		DINT Encoder_Position (Description := "Encoder Position (20,000 counts = 1 shaft turn)");
		DINT Absolute_Position (Description := "Absolute Position (20,000 counts = 1 shaft turn)");
		DINT Position_Error (Description := "Position Error (counts)");
		DINT Actual_Velocity (Description := "Actual Velocity (rev/sec * 240, 0 when no encoder)");
		DINT Extended_Inputs (Description := "Input Status (Extended)");
		DINT Main_Board_Inputs (Description := "Input Status (Main board)");
		DINT Word11 (Description := "Reserved");
		DINT Analog_Input_1 (Description := "Analog Input 1 (ADC counts, 0=min V, 16383 = max V)");
		DINT Analog_Input_2 (Description := "Analog Input 2 (ADC counts, 0=min V, 16383 = max V)");
	END_DATATYPE

	DATATYPE AMP_Status_Word (Description := "Applied Motion Input Assembly Status Word",
	                          FamilyType := NoFamily)
		SINT ZZZZZZZZZZAMP_Status0 (Hidden := 1);
		BIT Enabled ZZZZZZZZZZAMP_Status0 : 0 (Description := "Motor Enabled (Motor Disabled if this bit = 0)");
		BIT Sampling ZZZZZZZZZZAMP_Status0 : 1 (Description := "Sampling (for Quick Tuner)");
		BIT Drive_Fault ZZZZZZZZZZAMP_Status0 : 2 (Description := "Drive Fault (check Alarm Code)");
		BIT In_Position ZZZZZZZZZZAMP_Status0 : 3 (Description := "In Position (motor is in position)");
		BIT Moving ZZZZZZZZZZAMP_Status0 : 4 (Description := "Moving (motor is moving)");
		BIT Jogging ZZZZZZZZZZAMP_Status0 : 5 (Description := "Jogging (currently in jog mode)");
		BIT Stopping ZZZZZZZZZZAMP_Status0 : 6 (Description := "Stopping (in the process of stopping from a stop command)");
		BIT Waiting ZZZZZZZZZZAMP_Status0 : 7 (Description := "Waiting (for an input; executing a WI command)");
		SINT ZZZZZZZZZZAMP_Status9 (Hidden := 1);
		BIT Saving ZZZZZZZZZZAMP_Status9 : 0 (Description := "Saving (parameter data is being saved)");
		BIT Alarm_Present ZZZZZZZZZZAMP_Status9 : 1 (Description := "Alarm present (check Alarm Code)");
		BIT Homing ZZZZZZZZZZAMP_Status9 : 2 (Description := "Homing (executing an SH command)");
		BIT Wait_Time ZZZZZZZZZZAMP_Status9 : 3 (Description := "Waiting (for time; executing a WD or WT command)");
		BIT Wizard_Running ZZZZZZZZZZAMP_Status9 : 4 (Description := "Wizard running (Timing Wizard is running)");
		BIT Checking_Encoder ZZZZZZZZZZAMP_Status9 : 5 (Description := "Checking encoder (Timing Wizard is running)");
		BIT Q_Program_Running ZZZZZZZZZZAMP_Status9 : 6 (Description := "Q Program is running");
		BIT Initializing ZZZZZZZZZZAMP_Status9 : 7 (Description := "Initializing (happens at power up) ; Servo Ready (for SV200 drives only)");
	END_DATATYPE

	DATATYPE DateTime (Description := "Date and TimeOfDay (absolute) or Time (duration/interval)",
	                   FamilyType := NoFamily)
		DINT Yr (Description := "Year(s)");
		DINT Mo (Description := "Month(s)");
		DINT Da (Description := "Day(s)");
		DINT Hr (Description := "Hour(s)");
		DINT Min (Description := "Minute(s)");
		DINT Sec (Description := "Second(s)");
		DINT uSec (Description := "Microsecond(s)");
	END_DATATYPE

	DATATYPE PBSdata_UDT (FamilyType := NoFamily)
		REAL agitation_pv (Description := "AgPV(RPM)");
		REAL agitation_sp (Description := "AgSP(RPM)");
		REAL agitation_man (Description := "AgPowerUser(%)");
		INT agitation_mode (Description := "AgModeUser");
		INT agitation_error (Description := "N/A:$N $N0 means sensor is good and within range$N40 means Low (corresponds to Agitation Low alarm)$N50 means High (corresponds to Agitation High alarm)$N90 means Low Low (corresponds to Agitation Low Low alarm)$N100 means High High (corresponds to Agitation High High alarm)$N200 means Fail (corresponds to Agitation Sensor Failure alarm)");
		INT agitation_interlocked (Description := "InterlockAgMotor");
		REAL agitation_output (Description := "AgPowerActualRequest(%)");
		REAL temperature_pv (Description := "TempPV(C)");
		REAL temperature_sp (Description := "TempSP(C)");
		REAL temperature_man (Description := "TempHeatDutyUser(%)");
		INT temperature_mode (Description := "TempModeUser");
		INT temperature_error (Description := "N/A:$N $N0 means sensor is good and within range$N40 means Low (corresponds to Temperature Low alarm)$N50 means High (corresponds to Temperature High alarm)$N90 means Low Low (corresponds to Temperature Low Low alarm)$N100 means High High (corresponds to Temperature High High alarm)$N200 means Fail (corresponds to Temp Sensor A Failure (range) alarm)");
		INT temperature_interlocked (Description := "InterlockHeater");
		REAL temperature_output (Description := "TempHeatDutyActual(%)");
		REAL do_pv (Description := "DOPV(%)");
		REAL do_sp (Description := "DOSP(%)");
		REAL do_manUp (Description := "DOO2FlowUser(%)");
		REAL do_manDown (Description := "DON2FlowUser(%)");
		INT do_mode (Description := "DOModeUser");
		INT do_error (Description := "N/A:$N $N0 means sensor is good and within range$N40 means Low (corresponds to DO Low alarm)$N50 means High (corresponds to DO High alarm)$N90 means Low Low (corresponds to DO Low Low alarm)$N100 means High High (corresponds to DO High High alarm)$N200 means Fail (corresponds to DO Sensor A Failure (range) alarm)");
		INT do_interlocked (Description := "InterlockGasFlow");
		REAL do_outputUp (Description := "DOO2FlowControllerRequestLimited(%)");
		REAL do_outputDown (Description := "DON2FlowActualRequest(%)");
		REAL ph_pv (Description := "pHPV");
		REAL ph_sp (Description := "pHSP");
		REAL ph_manUp (Description := "pHBaseDutyUser(%)");
		REAL ph_manDown (Description := "pHCO2User(%)");
		INT ph_mode (Description := "pHModeUser");
		INT ph_error (Description := "N/A:$N $N0 means sensor is good and within range$N40 means Low (corresponds to pH Low alarm)$N50 means High (corresponds to pH High alarm)$N90 means Low Low (corresponds to pH Low Low alarm)$N100 means High High (corresponds to pH High High alarm)$N200 means Fail (corresponds to either pH Sensor A Failure (range) alarm, or pH Sensor A Failure (rate) alarm)");
		INT ph_interlocked (Description := "InterlockGasFlow + InterlockPumps");
		REAL ph_outputUp (Description := "pHBaseDutyActual(%)");
		REAL ph_outputDown (Description := "pHCO2ActualRequest(%)");
		REAL pressure_pv (Description := "PressurePV(psi)");
		INT pressure_error (Description := "N/A:$N $N0 means sensor is good and within range$N40 means Low (corresponds to Pressure Low alarm)$N50 means High (corresponds to Pressure High alarm)$N90 means Low Low (corresponds to Pressure Low Low alarm)$N100 means High High (corresponds to Pressure High High alarm)$N200 means Fail (corresponds to Pressure Sensor Disconnected alarm)");
		REAL level_pv (Description := "LevelPV(L)");
		INT level_error (Description := "0 means sensor is good and within range$N40 means Low (corresponds to Level Low alarm)$N50 means High (corresponds to Level High alarm)$N90 means Low Low (corresponds to Level Low Low alarm)$N100 means High High (corresponds to Level High High alarm)$N200 is not applicable for Level");
		REAL condenser_pv (Description := "FilterOvenPV(C)");
		INT condenser_sp (Description := "FilterOvenSP(C)");
		REAL condenser_man (Description := "FilterOvenDutyUser(%)");
		INT condenser_mode (Description := "FilterOvenModeUser");
		INT condenser_error (Description := "N/A:$N $N0 means sensor is good and within range$N40 means Low (corresponds to Filter Oven Low alarm)$N50 means High (corresponds to Filter Oven High alarm)$N90 means Low Low (corresponds to Filter Oven Low Low alarm)$N100 means High High (corresponds to Filter Oven High High alarm)$N200 means Fail (no corresponding alarm)");
		REAL condenser_output (Description := "FilterOvenDutyActual(%)");
		REAL maingas_pv (Description := "MainGasFeedback(LPM)");
		REAL maingas_man (Description := "MainGasUser(LPM)");
		INT maingas_mode (Description := "MainGasModeUser");
		INT maingas_error (Description := "0 means sensor is good and within range$N40 means Low (corresponds to Main Gas Low alarm)$N50 means High (corresponds to Main Gas High alarm)$N90 means Low Low (corresponds to Main Gas Low Low alarm)$N100 means High High (corresponds to Main Gas High High alarm)$N200 is not applicable for Main Gas");
		INT maingas_interlocked (Description := "InterlockGasFlow");
		REAL MFCs_air (Description := "MFCAirFlowFeedback(LPM)");
		REAL MFCs_co2 (Description := "MFCCO2FlowFeedback(LPM)");
		REAL MFCs_n2 (Description := "MFCN2FlowFeedback(LPM)");
		REAL MFCs_o2 (Description := "MFCO2FlowFeedback(LPM)");
		SINT ZZZZZZZZZZPBSdata_UD51 (Hidden := 1);
		BIT exchangeHeartbeat ZZZZZZZZZZPBSdata_UD51 : 0 (Description := "Heartbeat between the API exchange and PLC. If not flipping at specified rate, check console app is running");
		BIT jsonFailure ZZZZZZZZZZPBSdata_UD51 : 1 (Description := "If (1) API exchange can$'t reach webserver.");
		REAL jsonQuality (Description := "Percentage of Good Connections Made Over Period of Time");
	END_DATATYPE

	DATATYPE ProcData (FamilyType := NoFamily)
		DINT LocalDateTime[7] (Description := "Local Date and Time");
		INT ProcStatus (Description := "Controller Status");
		INT ProcForceStatus (Description := "Processor Forces Enabled");
		DINT ProcMinorFaultBits (Description := "Processor Minor Fault Bits");
		DINT ProcMajorFaultBits (Description := "Processor Major Fault Bits");
		SINT ZZZZZZZZZZProcData5 (Hidden := 1);
		BIT RunMode ZZZZZZZZZZProcData5 : 0 (Description := "Controller in RUN mode");
		BIT ProgramMode ZZZZZZZZZZProcData5 : 1 (Description := "Controller in PROGRAM mode");
		BIT DebugMode ZZZZZZZZZZProcData5 : 2 (Description := "Controller in DEBUG mode");
		BIT KeySwitchRun ZZZZZZZZZZProcData5 : 3 (Description := "Key Switch in RUN");
		BIT KeySwitchProgram ZZZZZZZZZZProcData5 : 4 (Description := "Key Switch in PROGRAM");
		BIT KeySwitchRemote ZZZZZZZZZZProcData5 : 5 (Description := "Key Switch in REMOTE");
		BIT Faulted ZZZZZZZZZZProcData5 : 6 (Description := "Controller Faulted");
		BIT ForcesInstalled ZZZZZZZZZZProcData5 : 7 (Description := "Forces Installed");
		SINT ZZZZZZZZZZProcData14 (Hidden := 1);
		BIT ForcesEnabled ZZZZZZZZZZProcData14 : 0 (Description := "Forces Enabled");
		BIT LogicFault ZZZZZZZZZZProcData14 : 1 (Description := "Controller Logic Minor Fault");
		BIT LowBattery ZZZZZZZZZZProcData14 : 2 (Description := "Low Battery Minor Fault");
		DINT MinorFaultBits (Description := "Minor Faults Status Word");
		DINT MajorFaultBits (Description := "Major Faults Status Word");
		DINT MinorFaultRecord[11] (Description := "Minor Faults for this program");
		DINT MajorFaultRecord[11] (Description := "Major Faults for this program");
	END_DATATYPE

	DATATYPE P_DescList (Description := "Code / Description List Entry",
	                     FamilyType := NoFamily)
		DINT Code (Description := "Code for which to look up Description");
		STRING_40 Desc (Description := "Description for given Code");
	END_DATATYPE

	DATATYPE STRING_12 (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[12] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_16 (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[16] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_20 (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[20] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_40 (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[40] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_8 (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[8] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_Area (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[8] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_Cond (FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[20] (Radix := ASCII);
	END_DATATYPE

	DATATYPE STRING_NavTag (Description := "Navigation Tag",
	                        FamilyType := StringFamily)
		DINT LEN;
		SINT DATA[20] (Radix := ASCII);
	END_DATATYPE

	DATATYPE UDT_ParamsProfileVelocityMode (Description := "Most important and needed parameters for Profile Velocity Mode",
	                                        FamilyType := NoFamily)
		DINT Od606Dh_00;
		DINT Od606Eh_00;
		DINT Od607Eh_00;
		DINT Od6083h_00;
		DINT Od6084h_00;
		DINT Od6085h_00;
		DINT Od6086h_00;
		DINT Od604Ah_01;
		DINT Od604Ah_02;
	END_DATATYPE

	DATATYPE UDT_ParamsVelocityMode (Description := "Most important and needed parameters for Velocity Mode",
	                                 FamilyType := NoFamily)
		DINT Od604Ch_01;
		DINT Od604Ch_02;
		DINT Od6048h_01;
		DINT Od6048h_02;
		DINT Od6049h_01;
		DINT Od6049h_02;
		DINT Od6046h_01;
		DINT Od6046h_02;
		DINT Od604Ah_01;
		DINT Od604Ah_02;
	END_DATATYPE

	MODULE Local (Parent := "Local",
	              ParentModPortId := 1,
	              CatalogNumber := "5069-L320ER",
	              Vendor := 1,
	              ProductType := 14,
	              ProductCode := 217,
	              Major := 32,
	              Minor := 14,
	              PortLabel := "RxBACKPLANE",
	              ChassisSize := 17,
	              Slot := 0,
	              Mode := 2#0000_0000_0000_0001,
	              CompatibleModule := 0,
	              KeyMask := 2#0000_0000_0000_0000)
	END_MODULE

	MODULE P101_Drive (Description := "stf stepper drive p101",
	                   Parent := "Local",
	                   ParentModPortId := 3,
	                   CatalogNumber := "ETHERNET-MODULE",
	                   Vendor := 1,
	                   ProductType := 0,
	                   ProductCode := 18,
	                   Major := 1,
	                   Minor := 1,
	                   PortLabel := "A1",
	                   NodeAddress := "192.168.1.31",
	                   CommMethod := 536870913,
	                   ConfigMethod := 8388609,
	                   Mode := 2#0000_0000_0000_0000,
	                   CompatibleModule := 0,
	                   KeyMask := 2#0000_0000_0000_0000,
	                   PrimCxnInputSize := 56,
	                   PrimCxnOutputSize := 64,
	                   SecCxnInputSize := 0,
	                   SecCxnOutputSize := 0)
			ConfigData  := [6,102,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
			CONNECTION Standard (Rate := 100000,
			                     InputCxnPoint := 101,
			                     InputSize := 56,
			                     OutputCxnPoint := 112,
			                     OutputSize := 64,
			                     EventID := 0,
			                     Unicast := Yes)
					InputData  := [[9,0,240,0,387,0,0,0,0,0,255,15,0,0]];
					OutputData  := [[0,-465,60,60,900,60,60,4000000,0,0,0,0,0,0,0,0]];
			END_CONNECTION

	END_MODULE

	MODULE P102_Drive (Description := "stf stepper drive p102",
	                   Parent := "Local",
	                   ParentModPortId := 3,
	                   CatalogNumber := "ETHERNET-MODULE",
	                   Vendor := 1,
	                   ProductType := 0,
	                   ProductCode := 18,
	                   Major := 1,
	                   Minor := 1,
	                   PortLabel := "A1",
	                   NodeAddress := "192.168.1.32",
	                   CommMethod := 536870913,
	                   ConfigMethod := 8388609,
	                   Mode := 2#0000_0000_0000_0000,
	                   CompatibleModule := 0,
	                   KeyMask := 2#0000_0000_0000_0000,
	                   PrimCxnInputSize := 56,
	                   PrimCxnOutputSize := 64,
	                   SecCxnInputSize := 0,
	                   SecCxnOutputSize := 0)
			ConfigData  := [6,102,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
			CONNECTION Standard (Rate := 100000,
			                     InputCxnPoint := 101,
			                     InputSize := 56,
			                     OutputCxnPoint := 112,
			                     OutputSize := 64,
			                     EventID := 0,
			                     Unicast := Yes)
					InputData  := [[9,0,244,0,389,0,0,0,0,0,255,15,0,0]];
					OutputData  := [[0,-513,60,60,900,60,60,4000000,0,0,0,0,0,0,0,0]];
			END_CONNECTION

	END_MODULE

	MODULE P103_Drive (Description := "stf stepper drive p103",
	                   Parent := "Local",
	                   ParentModPortId := 3,
	                   CatalogNumber := "ETHERNET-MODULE",
	                   Vendor := 1,
	                   ProductType := 0,
	                   ProductCode := 18,
	                   Major := 1,
	                   Minor := 1,
	                   PortLabel := "A1",
	                   NodeAddress := "192.168.1.33",
	                   CommMethod := 536870913,
	                   ConfigMethod := 8388609,
	                   Mode := 2#0000_0000_0000_0000,
	                   CompatibleModule := 0,
	                   KeyMask := 2#0000_0000_0000_0000,
	                   PrimCxnInputSize := 56,
	                   PrimCxnOutputSize := 64,
	                   SecCxnInputSize := 0,
	                   SecCxnOutputSize := 0)
			ConfigData  := [6,102,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
			CONNECTION Standard (Rate := 100000,
			                     InputCxnPoint := 101,
			                     InputSize := 56,
			                     OutputCxnPoint := 112,
			                     OutputSize := 64,
			                     EventID := 0,
			                     Unicast := Yes)
					InputData  := [[49,0,244,0,395,0,101537108,0,0,0,255,15,0,0]];
					OutputData  := [[0,341,60,60,900,60,60,4000000,0,0,0,0,0,0,0,0]];
			END_CONNECTION

	END_MODULE

	MODULE P104_Drive (Description := "stf stepper drive p104",
	                   Parent := "Local",
	                   ParentModPortId := 3,
	                   CatalogNumber := "ETHERNET-MODULE",
	                   Vendor := 1,
	                   ProductType := 0,
	                   ProductCode := 18,
	                   Major := 1,
	                   Minor := 1,
	                   PortLabel := "A1",
	                   NodeAddress := "192.168.1.34",
	                   CommMethod := 536870913,
	                   ConfigMethod := 8388609,
	                   Mode := 2#0000_0000_0000_0000,
	                   CompatibleModule := 0,
	                   KeyMask := 2#0000_0000_0000_0000,
	                   PrimCxnInputSize := 56,
	                   PrimCxnOutputSize := 64,
	                   SecCxnInputSize := 0,
	                   SecCxnOutputSize := 0)
			ConfigData  := [6,102,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
			CONNECTION Standard (Rate := 100000,
			                     InputCxnPoint := 101,
			                     InputSize := 56,
			                     OutputCxnPoint := 112,
			                     OutputSize := 64,
			                     EventID := 0,
			                     Unicast := Yes)
					InputData  := [[49,0,240,0,382,0,-51502203,0,0,0,255,15,0,0]];
					OutputData  := [[0,0,60,60,900,60,60,4000000,0,0,0,0,0,0,0,0]];
			END_CONNECTION

	END_MODULE

	MODULE P105_Ethernet (Parent := "Local",
	                      ParentModPortId := 3,
	                      CatalogNumber := "530_630_730 EtherNet/IP Pump",
	                      Vendor := 1542,
	                      ProductType := 43,
	                      ProductCode := 1,
	                      Major := 2,
	                      Minor := 5,
	                      PortLabel := "A1",
	                      NodeAddress := "192.168.1.35",
	                      Mode := 2#0000_0000_0000_0000,
	                      CompatibleModule := 1,
	                      KeyMask := 2#0000_0000_0001_1111,
	                      SafetyEnabled := 0)
			ExtendedProp := [[[___<public><PL>02<Version Name=$Q2.5$Q/></PL><Vendor>Watson-Marlow Ltd</Vendor><CatNum>530_630_730 EtherNet/IP Pump</CatNum></public>___]]]
			CONNECTION _200424002C962C64 (Rate := 20000,
			                              InputSize := 100,
			                              OutputSize := 19,
			                              EventID := 0,
			                              Priority := Scheduled,
			                              InputConnectionType := Unicast,
			                              InputProductionTrigger := Cyclic,
			                              ConnectionPath := "20 04 24 00 2c 96 2c 64",
			                              InputTagSuffix := "I",
			                              OutputTagSuffix := "O")
					InputData (COMMENT.FLOWCAL := "nl/rev") := [0,7210,8,0,0,0,2000,0,2000,0,20000,0,20000,0,0,0,2200,0,0,42,1,47,1,2,23,0,6,0,65,0,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0];
					OutputData  := [7210,69,2200,0,1,0,0,1,0,0,0,0,0];
			END_CONNECTION

	END_MODULE

	MODULE SIC401_Drive (Parent := "Local",
	                     ParentModPortId := 3,
	                     CatalogNumber := "C5-E-2-11",
	                     Vendor := 1368,
	                     ProductType := 43,
	                     ProductCode := 83,
	                     Major := 2,
	                     Minor := 71,
	                     PortLabel := "A1",
	                     NodeAddress := "192.168.1.36",
	                     Mode := 2#0000_0000_0000_0000,
	                     CompatibleModule := 1,
	                     KeyMask := 2#0000_0000_0001_1111,
	                     SafetyEnabled := 0)
			ExtendedProp := [[[___<public><PL>01<Version Name=$Q1.2$Q/><Connection Name=$Q_20042C692C68$Q Format=$Q0$Q/></PL><Vendor>Nanotec Electronic GmbH &amp; Co. KG</Vendor><CatNum>C5-E-2-11</CatNum></public>___]]]
			CONNECTION _20042C692C68 (Rate := 10000,
			                          InputSize := 12,
			                          OutputSize := 8,
			                          EventID := 0,
			                          Priority := Scheduled,
			                          InputConnectionType := Unicast,
			                          InputProductionTrigger := Cyclic,
			                          ConnectionPath := "20 04 2c 69 2c 68",
			                          InputTagSuffix := "I1",
			                          OutputTagSuffix := "O1")
					InputData  := [0,[-128,64,0,0,0,0,0,0]];
					OutputData  := [[-6,0,0,0,126,96,0,3]];
			END_CONNECTION

	END_MODULE

	MODULE MCV_Scale (Description := "Hardy",
	                  Parent := "Local",
	                  ParentModPortId := 3,
	                  CatalogNumber := "Hardy 6500 Series",
	                  Vendor := 258,
	                  ProductType := 43,
	                  ProductCode := 2,
	                  Major := 2,
	                  Minor := 35,
	                  PortLabel := "A1",
	                  NodeAddress := "192.168.1.41",
	                  Mode := 2#0000_0000_0000_0000,
	                  CompatibleModule := 1,
	                  KeyMask := 2#0000_0000_0001_1111,
	                  SafetyEnabled := 0)
			ExtendedProp := [[[___<public><PL>02<Version Name=$Q1.3$Q/></PL><Vendor>Hardy Process Solutions</Vendor><CatNum>Hardy 6500 Series</CatNum></public>___]]]
			ConfigData  := [96,4,0,1,0,1.00000000e+001,2,9.99999000e+005,4,1.00000000e+001,0.00000000e+000,1.00115895e+000
		,1.00000000e+003,3,10,0,0.00000000e+000,1,1.00000000e+001,3,0,0,0,0,0.00000000e+000];
			CONNECTION _200424802C702C64 (Rate := 10000,
			                              InputSize := 52,
			                              OutputSize := 48,
			                              EventID := 0,
			                              Priority := Scheduled,
			                              InputConnectionType := Unicast,
			                              InputProductionTrigger := Cyclic,
			                              ConnectionPath := "20 04 24 80 2c 70 2c 64",
			                              InputTagSuffix := "I",
			                              OutputTagSuffix := "O")
					InputData (COMMENT.COMMAND_STATUS := "Status Register$N0: Command Success$N1: Motion Error$N2: A/D Error$N3: Out of Tolerance Error") := [0,0,520126464,0,0,1342177280,2.52999973e+000,1.06599998e+001,0,0,0,0,0];
					OutputData (COMMENT.COMMAND := "Write #1 to ZERO the gross weight. Write #2 to TARE net weight") := [0,0,0,0,0,0,0,0,0,0,0,0];
			END_CONNECTION

	END_MODULE

	MODULE Wago_IO (Description := "Wago IO via Ethernet",
	                Parent := "Local",
	                ParentModPortId := 3,
	                CatalogNumber := "750-363",
	                Vendor := 40,
	                ProductType := 12,
	                ProductCode := 363,
	                Major := 1,
	                Minor := 4,
	                PortLabel := "A1",
	                NodeAddress := "192.168.1.51",
	                Mode := 2#0000_0000_0000_0000,
	                CompatibleModule := 1,
	                KeyMask := 2#0000_0000_0001_1111,
	                SafetyEnabled := 0)
			ExtendedProp := [[[___<public><PL>01<Version Name=$Q1.7$Q/><Connection Name=$Q_200424012C662C6C$Q Format=$Q0$Q/><Connection Name=$Q_200424012C672C6D$Q Format=$Q0$Q/></PL><Vendor>Wago Corporation</Vendor><CatNum>750-363</CatNum></public>___]]]
			CONNECTION _200424012C662C6C (Rate := 5000,
			                              InputSize := 5,
			                              OutputSize := 3,
			                              EventID := 0,
			                              Priority := Scheduled,
			                              InputConnectionType := Unicast,
			                              InputProductionTrigger := Cyclic,
			                              ConnectionPath := "20 04 24 01 2c 66 2c 6c",
			                              InputTagSuffix := "I1",
			                              OutputTagSuffix := "O1")
					InputData (COMMENT.DATA[0].0 := "DI1 - ESCR$N0 = ESTOP ON") := [0,[1]];
					OutputData (COMMENT.DATA[0].0 := "750-504 A",
            COMMENT.DATA[0].1 := "750-504 B",
            COMMENT.DATA[0].2 := "750-504 C$NTurns on P105",
            COMMENT.DATA[0].3 := "750-504 D$NTurns on Cosy",
            COMMENT.DATA[0].4 := "750-1505$N1 - CCA  Sparge KV-111",
            COMMENT.DATA[0].5 := "750-1505 $N2-O2  Overlay$NKV-121",
            COMMENT.DATA[0].6 := "750-1505 $N3 - CCA Overlay KV-112",
            COMMENT.DATA[0].7 := "750-1505 $N4 - O2$NSparge$NKV-122",
            COMMENT.DATA[1].0 := "750 -1505$N5 - EMPTY",
            COMMENT.DATA[1].1 := "750-1505 $N6 - EMPTY",
            COMMENT.DATA[1].2 := "750-1505$N7 - EMPTY",
            COMMENT.DATA[1].3 := "750-1505$N8 - EMPTY",
            COMMENT.DATA[1].4 := "750-1505$N9 - EMPTY",
            COMMENT.DATA[1].5 := "750-1505$N10 - EMPTY",
            COMMENT.DATA[1].6 := "750-1505$N11 - CO2 Overlay KV-131",
            COMMENT.DATA[1].7 := "750-1505$N12 - N2 Sparge$NKV-141",
            COMMENT.DATA[2].0 := "750-1505$N13 - CO2 Overlay KV-132",
            COMMENT.DATA[2].1 := "750-1505$N14 - N2 Sparge$NKV-142",
            COMMENT.DATA[2].2 := "750-1505$N15 - EMPTY",
            COMMENT.DATA[2].3 := "750-1505$N16 - EMPTY",
            COMMENT.DATA[2].4 := "EMPTY",
            COMMENT.DATA[2].5 := "EMPTY",
            COMMENT.DATA[2].6 := "EMPTY",
            COMMENT.DATA[2].7 := "EMPTY") := [[52,-64,0]];
			END_CONNECTION

			CONNECTION _200424012C672C6D (Rate := 5000,
			                              InputSize := 16,
			                              OutputSize := 8,
			                              EventID := 0,
			                              Priority := Scheduled,
			                              InputConnectionType := Unicast,
			                              InputProductionTrigger := Cyclic,
			                              ConnectionPath := "20 04 24 01 2c 67 2c 6d",
			                              InputTagSuffix := "I2",
			                              OutputTagSuffix := "O2")
					InputData  := [0,[38,4,52,33,0,0,104,42,3,0,3,0]];
					OutputData  := [[0,0,0,0,0,0,0,0]];
			END_CONNECTION

	END_MODULE

	ADD_ON_INSTRUCTION_DEFINITION AMP_Alarm_Code (Description := "Applied Motion - Alarm Code - AOI",
	                                              Revision := "1.0",
	                                              ExecutePrescan := No,
	                                              ExecutePostscan := No,
	                                              ExecuteEnableInFalse := No,
	                                              CreatedDate := "2012-03-28T13:25:24.614Z",
	                                              CreatedBy := "MATT-F3A979C4EF\Administrator",
	                                              EditedDate := "2018-03-29T21:18:44.454Z",
	                                              EditedBy := "VM-RS2015-W7XX\Grantek",
	                                              SoftwareRevision := "v20.04",
	                                              AdditionalHelpText := "The Alarm Code AOI uses the raw data stored in the Alarm Code word (Element 1 from Input Assembly 0x65) to set individual appropriately named boolean outputs.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT (Description := "Element 1 from Drive Input Assembly (0x65)",
			                 Usage := Input,
			                 RADIX := Hex,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Position_Limit : BOOL (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			CCW_Limit : BOOL (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			CW_Limit : BOOL (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Over_Temp : BOOL (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Excess_Regen_or_Internal_Voltage : BOOL (Usage := Output,
			                                            RADIX := Decimal,
			                                            Required := No,
			                                            Visible := Yes,
			                                            ExternalAccess := Read Only,
			                                            DefaultData := 0);
			Over_Voltage : BOOL (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Under_Voltage : BOOL (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Over_Current : BOOL (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Open_Motor_Windings : BOOL (Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := Yes,
			                               ExternalAccess := Read Only,
			                               DefaultData := 0);
			Bad_Encoder : BOOL (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Comm_Error : BOOL (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Bad_Flash : BOOL (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			No_Move : BOOL (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			NA_1 : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Blank_Q_Segment : BOOL (Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			NA_2 : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Alarm_Code$N"
				    "Takes the alarm WORD and breaks it into BITS that are easily used in the program. $N"
				    "$N"
				    "";
				N: XIC(Input.0)OTE(Position_Limit);
				N: XIC(Input.1)OTE(CCW_Limit);
				N: XIC(Input.2)OTE(CW_Limit);
				N: XIC(Input.3)OTE(Over_Temp);
				N: XIC(Input.4)OTE(Excess_Regen_or_Internal_Voltage);
				N: XIC(Input.5)OTE(Over_Voltage);
				N: XIC(Input.6)OTE(Under_Voltage);
				N: XIC(Input.7)OTE(Over_Current);
				N: XIC(Input.8)OTE(Open_Motor_Windings);
				N: XIC(Input.9)OTE(Bad_Encoder);
				N: XIC(Input.10)OTE(Comm_Error);
				N: XIC(Input.11)OTE(Bad_Flash);
				N: XIC(Input.12)OTE(No_Move);
				N: XIC(Input.13)OTE(NA_1);
				N: XIC(Input.14)OTE(Blank_Q_Segment);
				N: XIC(Input.15)OTE(NA_2);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Alarm_Reset (Description := "Applied Motion - Alarm Reset - AOI",
	                                               Revision := "1.0",
	                                               ExecutePrescan := No,
	                                               ExecutePostscan := No,
	                                               ExecuteEnableInFalse := No,
	                                               CreatedDate := "2017-11-16T21:13:24.555Z",
	                                               CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                               EditedDate := "2018-03-21T18:42:19.431Z",
	                                               EditedBy := "VM-RS2015-W7XX\Grantek",
	                                               SoftwareRevision := "v20.04",
	                                               AdditionalHelpText := "The Alarm Reset AOI is used to reset Drive Fault and clear Alarm Code (if possible). Figure 1 shows a preview of an instance of the AOI.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Reset : BOOL (Description := "Reset the Drive (on rising edge)",
			                 Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Sent : BOOL (Description := "Reset has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Reset in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Reset completed without errors - Drive is not faulted",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Reset failed - Not Used",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := None,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to servo",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Stop_ONS : BOOL (RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Reset)ONS(Loc_Stop_ONS)MOV(10,State)CLR(Output[0]);
				RC: "State 10 - We do not check for drive readiness, simply set state=20";
				N: EQU(State,10)MOV(20,State);
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#100000,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70";
				N: EQU(State,60)XIO(Loc_StatusCode.Drive_Fault)XIO(Loc_StatusCode.Alarm_Present)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected during the sending and execution of the command, set the Error output bit$N"
				    "(Not used - Error always false)";
				N: LIM(10,State,50)XIO(Error)XIC(Error)OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(10,State,60)OTE(In_Progress);
				RC: "If sequence has progressed passed the command send completion, then indicate $QSent$Q";
				N: LIM(60,State,70)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Configuration_Settings (Description := "Applied Motion - Configuration Settings AOI",
	                                                          Revision := "1.0",
	                                                          ExecutePrescan := No,
	                                                          ExecutePostscan := No,
	                                                          ExecuteEnableInFalse := No,
	                                                          CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                          CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                          EditedDate := "2018-03-29T22:03:18.622Z",
	                                                          EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                          SoftwareRevision := "v20.04",
	                                                          AdditionalHelpText := "The Configuration Settings AOI accepts all the required parameters for: Position Fault (PF), Control Mode (CM), Secondary Control Mode (CN), Electronic Gearing (EG), Input Noise Filter (EI), Jerk Filter (KJ), and then scales and issues these to the drive, one at a time.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			MSG_Write : SINT[8] (Description := "Message Write data tag",
			                     COMMENT[0] := "Message Reserved = 0",
			                     COMMENT[1] := "Message Type (16#01 or 16#02)",
			                     COMMENT[2] := "Type 1: Register$NType 2: Opcode",
			                     COMMENT[3] := "Type 1: Opcode$NType 2: Operand",
			                     COMMENT[4] := "Type 1: Parameter 1$NType 2: data MSB",
			                     COMMENT[5] := "Type 1: Parameter 2$NType 2: data LSB",
			                     COMMENT[6] := "Type 1: Parameter 3$NType 2: not used",
			                     COMMENT[7] := "Type 1: Parameter 4$NType 2: not used",
			                     Usage := InOut,
			                     RADIX := Decimal,
			                     Required := Yes,
			                     Visible := Yes);
			SendMsg : MESSAGE (Description := "Message tag",
			                   Usage := InOut,
			                   Required := Yes,
			                   Visible := Yes);
			MSG_Response : SINT[8] (Description := "Message Response data tag",
			                        COMMENT[0] := "Command Word",
			                        COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                        COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                        COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                        COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                        COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                        COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                        COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                        Usage := InOut,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes);
			Configure : BOOL (Description := "Start the Configuration",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := Yes,
			                     Visible := Yes,
			                     DefaultData := 0);
			PF : INT (Description := "Position Fault (steps or counts)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			CM : INT (Description := "Control Mode (integer code)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			CN : INT (Description := "Secondary Control Mode (integer code)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			EG : INT (Description := "Electronic Gearing (steps/rev or counts/rev)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			EI : INT (Description := "Input Noise Filter Constant (0-255)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			KJ : INT (Description := "Jerk Filter (Hz)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			Sent : BOOL (Description := "All configuration settings have been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "The configuration is in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Configuration completed without errors",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Configuration failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 34);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			loc_Steps_per_Rev_div_by_2 : DINT (RADIX := Decimal,
			                                     ExternalAccess := Read/Write,
			                                     DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "When the command trigger is received and start conditions are deemed ok, set state=12$N"
				    "if trigger is received when start conditions indicate that failure is inevitable, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)";
				N: XIC(Configure)ONS(Loc_Start_ONS)[XIO(SendMsg.EN) MOV(12,State) ,XIC(SendMsg.EN) MOV(10,State) ];
				RC: "State 12 - PF - Position Fault (counts)$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QPF$Q parameter (operand =16#21) with data = Position Fault Limit (counts)";
				N: EQU(State,12)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#21,MSG_Write[3])BTD(PF,8,MSG_Write[4],0,8)BTD(PF,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(13,State);
				N: EQU(State,13)XIC(SendMsg.EN)MOV(14,State);
				N: EQU(State,14)[XIC(SendMsg.DN) MOV(15,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 14 - CM - Control Mode$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QCM$Q parameter (operand =16#10) with data = control mode";
				N: EQU(State,15)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#10,MSG_Write[3])BTD(CM,8,MSG_Write[4],0,8)BTD(CM,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(16,State);
				N: EQU(State,16)XIC(SendMsg.EN)MOV(17,State);
				N: EQU(State,17)[XIC(SendMsg.DN) MOV(18,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 17 - CN - Control Mode$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QCN$Q parameter (operand =16#27) with data = secondary control mode";
				N: EQU(State,18)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#27,MSG_Write[3])BTD(CN,8,MSG_Write[4],0,8)BTD(CN,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(19,State);
				N: EQU(State,19)XIC(SendMsg.EN)MOV(20,State);
				N: EQU(State,20)[XIC(SendMsg.DN) MOV(21,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 20 - EG - Electronic Gearing$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QEG$Q parameter (operand =16#26) with data = steps/rev divided by 2";
				N: EQU(State,21)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#26,MSG_Write[3])DIV(EG,2,loc_Steps_per_Rev_div_by_2)BTD(loc_Steps_per_Rev_div_by_2,8,MSG_Write[4],0,8)BTD(loc_Steps_per_Rev_div_by_2,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(22,State);
				N: EQU(State,22)XIC(SendMsg.EN)MOV(23,State);
				N: EQU(State,23)[XIC(SendMsg.DN) MOV(24,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 27 - EI - Input Noise Filter Constant$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#43) for setting $QEI$Q parameter (operand =16#10) with data = Filter Value (0..255, Frequency = <max freq.>/<Filter Value>)";
				N: EQU(State,24)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#43,MSG_Write[3])BTD(EI,8,MSG_Write[4],0,8)BTD(EI,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(25,State);
				N: EQU(State,25)XIC(SendMsg.EN)MOV(26,State);
				N: EQU(State,26)[XIC(SendMsg.DN) MOV(27,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 24 - KJ - Jerk Filter$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QKJ$Q parameter (operand =16#0B) with data = frequency (Hz)";
				N: EQU(State,27)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#0B,MSG_Write[3])BTD(KJ,8,MSG_Write[4],0,8)BTD(KJ,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(28,State);
				N: EQU(State,28)XIC(SendMsg.EN)MOV(29,State);
				N: EQU(State,29)[XIC(SendMsg.DN) MOV(30,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				N: [EQU(State,13) ,EQU(State,16) ,EQU(State,19) ,EQU(State,22) ,EQU(State,25) ,EQU(State,28) ]MSG(SendMsg);
				RC: "Last Configuration setting is complete. Wait for Message instruction to be non-enabled";
				N: EQU(State,30)XIO(SendMsg.EN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80$N"
				    "[The command was successful when all parameters have been sent]";
				N: EQU(State,60)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(12,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Crash_Stop (Description := "Applied Motion - Stop/Kill using Maximum Deceleration - AOI",
	                                              Revision := "1.0",
	                                              ExecutePrescan := No,
	                                              ExecutePostscan := No,
	                                              ExecuteEnableInFalse := No,
	                                              CreatedDate := "2017-11-16T21:13:24.555Z",
	                                              CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                              EditedDate := "2018-03-21T20:00:52.656Z",
	                                              EditedBy := "VM-RS2015-W7XX\Grantek",
	                                              SoftwareRevision := "v20.04",
	                                              AdditionalHelpText := "The Crash Stop AOI is used to stop and kill the drive using the maximum deceleration as set by the AM command.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Stop : BOOL (Description := "Stop the drive axis",
			                Usage := Input,
			                RADIX := Decimal,
			                Required := Yes,
			                Visible := Yes,
			                DefaultData := 0);
			Sent : BOOL (Description := "Stop has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Stop in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Stop completed without errors - Servo is not moving",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Stop failed - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := None,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to servo",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Stop_ONS : BOOL (RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Stop)ONS(Loc_Stop_ONS)MOV(10,State)CLR(Output[0]);
				RC: "State 10 - If drive is ready, then set state=20";
				N: EQU(State,10)XIC(Loc_StatusCode.Enabled)XIO(Loc_StatusCode.Drive_Fault)MOV(20,State);
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#4000,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70";
				N: EQU(State,60)XIO(Loc_StatusCode.Moving)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected during the sending and execution of the command, set the Error output bit";
				N: LIM(10,State,60)[XIO(Loc_StatusCode.Enabled) ,XIC(Loc_StatusCode.Drive_Fault) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(10,State,60)OTE(In_Progress);
				RC: "If sequence has progressed passed the command send completion, then indicate $QSent$Q";
				N: LIM(60,State,70)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Hard_Stop_Homing (Description := "Applied Motion - Hard Stop Homing AOI",
	                                                    Revision := "1.0",
	                                                    ExecutePrescan := No,
	                                                    ExecutePostscan := No,
	                                                    ExecuteEnableInFalse := No,
	                                                    CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                    CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                    EditedDate := "2018-03-29T21:16:46.393Z",
	                                                    EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                    SoftwareRevision := "v20.04",
	                                                    AdditionalHelpText := "The Hard Stop Homing AOI accepts all the required parameters for SCL commands HV1, HV2, HV3, HA1, HA2, HA3, HL1, HL2, HL3, HC, HD, HO and then sends the HS command to initiate the Hard Stop Homing move.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Start : BOOL (Description := "Start the Homing",
			                 Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			HV1 : REAL (Description := "Velocity used while seeking the hard stop (rev/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HV2 : REAL (Description := "Velocity when moving offset distance set by HO (rev/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HV3 : REAL (Description := "Velocity when searching for encoder index if desired (rev/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HA1 : REAL (Description := "Accel used while seeking the hard stop (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HA2 : REAL (Description := "Accel when moving offset distance set by HO (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HA3 : REAL (Description := "Accel when searching for encoder index if desired (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HL1 : REAL (Description := "Decel used while seeking the hard stop (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HL2 : REAL (Description := "Decel when moving offset distance set by HO (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HL3 : REAL (Description := "Decel when searching for encoder index if desired (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			HC : REAL (Description := "Hard Stop Current (Amps)",
			              Usage := Input,
			              RADIX := Float,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0.00000000e+000);
			HD : DINT (Description := "Hard Stop Fault Delay (ms)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			HO : DINT (Description := "Home Offset (steps, negative = CCW, positive = CW)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			HS : DINT (Description := "Hard Stop method (0 = without index, 1 = with index)",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			Sent : BOOL (Description := "All parameter setting and homing commands have been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "The setting of parameters and/or homing are in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Homing Move completed without errors - desired position reached",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Homing failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 34);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to drive",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle $N"
				    "(we maintain signals 30% longer than nominal RPI).";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure drive has seen command idle state)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "Wait for command word to be non-zero for a long enough time (to ensure command value was seen by drive)";
				N: NEQ(Output[0],0)TON(Loc_CommandOn_Timer,?,?);
				RC: "When the command trigger is received, set state=11$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)";
				N: XIC(Start)ONS(Loc_Start_ONS)[XIO(Loc_StatusCode.Drive_Fault) [CLR(Output[0]) ,MOV(11,State) ] ,XIC(Loc_StatusCode.Drive_Fault) MOV(10,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,11)XIC(Loc_CommandOff_Timer.DN)MOV(12,State);
				RC: "State 12 - HV1: set Velocity used while seeking the hard stop (rev/s)$N"
				    "$N"
				    "Send SCL command $QHV$Q (16#4856) with Reg1 = $Q1$Q (16#0031) and Reg2 = scaled velocity $N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,12)[MOV(16#4856,Output[9]) MOV(16#0031,Output[10]) MUL(HV1,240.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(13,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,13)XIC(Loc_CommandOff_Timer.DN)MOV(14,State);
				RC: "State 14 - HV2: set Velocity when moving offset distance set by HO (rev/s)$N"
				    "$N"
				    "Send SCL command $QHV$Q (16#4856) with Reg1 = $Q2$Q (16#0032) and Reg2 = scaled velocity $N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,14)[MOV(16#4856,Output[9]) MOV(16#0032,Output[10]) MUL(HV2,240.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(15,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,15)XIC(Loc_CommandOff_Timer.DN)MOV(16,State);
				RC: "State 16 - HV3: set Velocity when searching for encoder index if desired (rev/s)$N"
				    "$N"
				    "Send SCL command $QHV$Q (16#4856) with Reg1 = $Q3$Q (16#0033) and Reg2 = scaled velocity $N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,16)[MOV(16#4856,Output[9]) MOV(16#0033,Output[10]) MUL(HV3,240.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(17,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,17)XIC(Loc_CommandOff_Timer.DN)MOV(18,State);
				RC: "State 18 - HA1: set Acceleration used while seeking the hard stop (rev/s/s)$N"
				    "$N"
				    "Send SCL command $QHA$Q (16#4841) with Reg1 = $Q1$Q (16#0031) and Reg2 = scaled acceleration$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,18)[MOV(16#4841,Output[9]) MOV(16#0031,Output[10]) MUL(HA1,6.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(19,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,19)XIC(Loc_CommandOff_Timer.DN)MOV(20,State);
				RC: "State 20 - HA2: set Acceleration when moving offset distance set by HO (rev/s/s)$N"
				    "$N"
				    "Send SCL command $QHA$Q (16#4841) with Reg1 = $Q2$Q (16#0032) and Reg2 = scaled acceleration$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,20)[MOV(16#4841,Output[9]) MOV(16#0032,Output[10]) MUL(HA2,6.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(21,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,21)XIC(Loc_CommandOff_Timer.DN)MOV(22,State);
				RC: "State 22 - HA3: set Acceleration when searching for encoder index if desired (rev/s/s)$N"
				    "$N"
				    "$N"
				    "Send SCL command $QHA$Q (16#4841) with Reg1 = $Q3$Q (16#0033) and Reg2 = scaled acceleration$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,22)[MOV(16#4841,Output[9]) MOV(16#0033,Output[10]) MUL(HA3,6.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(23,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,23)XIC(Loc_CommandOff_Timer.DN)MOV(24,State);
				RC: "State 24 - HL1: set Deceleration used while seeking the hard stop (rev/s/s)$N"
				    "$N"
				    "Send SCL command $QHL$Q (16#484c) with Reg1 = $Q1$Q (16#0031) and Reg2 = scaled deceleration$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,24)[MOV(16#484c,Output[9]) MOV(16#0031,Output[10]) MUL(HL1,6.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(25,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,25)XIC(Loc_CommandOff_Timer.DN)MOV(26,State);
				RC: "State 26 - HL2: set Deceleration when moving offset distance set by HO (rev/s/s)$N"
				    "$N"
				    "Send SCL command $QHL$Q (16#484c) with Reg1 = $Q2$Q (16#0032) and Reg2 = scaled deceleration$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,26)[MOV(16#484c,Output[9]) MOV(16#0032,Output[10]) MUL(HL2,6.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(27,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,27)XIC(Loc_CommandOff_Timer.DN)MOV(28,State);
				RC: "State 28 - HL3: set Deceleration when searching for encoder index if desired (rev/s/s)$N"
				    "$N"
				    "Send SCL command $QHL$Q (16#484c) with Reg1 = $Q3$Q (16#0033) and Reg2 = scaled deceleration$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,28)[MOV(16#484c,Output[9]) MOV(16#0033,Output[10]) MUL(HL3,6.0,Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(29,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,29)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - HC: set Hard Stop Current (Amps)$N"
				    "$N"
				    "Send SCL command $QHC$Q (16#4843) with Reg1 = scaled current and Reg2 = 0$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#4843,Output[9]) MUL(HC,100,Output[10]) CLR(Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(31,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,31)XIC(Loc_CommandOff_Timer.DN)MOV(32,State);
				RC: "State 32 - Hard Stop Fault Delay (ms)$N"
				    "$N"
				    "Send SCL command $QHD$Q (16#4844) with Reg1 = delay (ms) and Reg2 = 0$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,32)[MOV(16#4844,Output[9]) MOV(HD,Output[10]) CLR(Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(33,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,33)XIC(Loc_CommandOff_Timer.DN)MOV(34,State);
				RC: "State 34 - Home Offset (negative = CCW, positive = CW)$N"
				    "$N"
				    "Send SCL command $QHO$Q (16#484f) with Reg1 = offset (steps) and Reg2 = 0$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,34)[MOV(16#484f,Output[9]) MOV(HO,Output[10]) CLR(Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(35,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,35)XIC(Loc_CommandOff_Timer.DN)MOV(36,State);
				RC: "State 36 - Hard Stop Homing command with or without index$N"
				    "$N"
				    "Send SCL command $QHS$Q (16#4853) with Reg1 = use index (0=no or 1=yes) and Reg2 = 0$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,36)[MOV(16#4853,Output[9]) MOV(HS,Output[10]) CLR(Output[11]) MOV(16#40000,Output[0]) ,XIC(Loc_CommandOn_Timer.DN) CLR(Output[0]) MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80";
				N: EQU(State,60)[XIO(Loc_StatusCode.Moving) XIC(Loc_StatusCode.Enabled) XIO(Loc_StatusCode.Drive_Fault) MOV(70,State) ,[XIC(Loc_StatusCode.Drive_Fault) ,XIO(Loc_StatusCode.Moving) XIO(Loc_StatusCode.Enabled) ] MOV(80,State) ];
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(20,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Input_Assembly (Description := "Applied Motion - Input Assembly AOI",
	                                                  Revision := "1.0",
	                                                  ExecutePrescan := No,
	                                                  ExecutePostscan := No,
	                                                  ExecuteEnableInFalse := No,
	                                                  CreatedDate := "2012-03-27T18:09:00.023Z",
	                                                  CreatedBy := "MATT-F3A979C4EF\Administrator",
	                                                  EditedDate := "2018-03-21T20:01:40.018Z",
	                                                  EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                  SoftwareRevision := "v20.04",
	                                                  AdditionalHelpText := "The Input Assembly AOI takes raw input data from the drive and re-interprets the data, using either scaling or copying, to appropriately named outputs.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "AMP_Assembly",
			                 Usage := InOut,
			                 RADIX := Hex,
			                 Required := Yes,
			                 Visible := Yes);
			Output : AMP_Input_Assembly_v2 (Usage := InOut,
			                  Required := Yes,
			                  Visible := Yes);
			Status_Code : DINT (Description := "Status Code",
			                       Usage := Output,
			                       RADIX := Hex,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Alarm_Code : DINT (Description := "Alarm Code",
			                      Usage := Output,
			                      RADIX := Hex,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Voltage : REAL (Description := "Supply Voltage (V)",
			                   Usage := Output,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0.00000000e+000);
			Current : REAL (Description := "Actual Current (mA)",
			                   Usage := Output,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0.00000000e+000);
			Temp : REAL (Description := "Drive Temperature (deg C)",
			                Usage := Output,
			                RADIX := Float,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0.00000000e+000);
			Encoder_Position : DINT (Description := "Encoder Position (20,000 counts = 1 shaft turn)",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Absolute_Position : DINT (Description := "Absolute Position (20,000 counts = 1 shaft turn)",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := Yes,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0);
			Actual_Velocity : REAL (Description := "Actual Velocity (rev/sec, 0 when no encoder)",
			                           Usage := Output,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0.00000000e+000);
			Position_Error : DINT (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Extended_Inputs : INT (Description := "Input Status (Extended)",
			                           Usage := Output,
			                           RADIX := Hex,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Main_Board_Inputs : INT (Description := "Input Status (Main board)",
			                             Usage := Output,
			                             RADIX := Hex,
			                             Required := No,
			                             Visible := Yes,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0);
			Analog_Input_1 : DINT (Description := "Analog Input 1 (ADC counts, 0=min V, 16383 = max V)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Analog_Input_2 : DINT (Description := "Analog Input 2 (ADC counts, 0=min V, 16383 = max V)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := None,
			                         DefaultData := "[0,0]");
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Input Assembly$N"
				    "Take the cyclic data collected from the drive and breaks it down into variable to be used in the program$N"
				    "";
				N: NOP();
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Output,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Status Word";
				N: MOV(Output.Status_Code,Status_Code);
				RC: "Alarm Word";
				N: MOV(Output.Alarm_Code,Alarm_Code);
				RC: "Supply Voltage";
				N: DIV(Output.Voltage,10.0,Voltage);
				RC: "Actual Current";
				N: MOV(Output.Current,Current);
				RC: "Drive Temp";
				N: DIV(Output.Temp,10.0,Temp);
				RC: "Encoder Position";
				N: MOV(Output.Encoder_Position,Encoder_Position);
				RC: "Absolute Position";
				N: MOV(Output.Absolute_Position,Absolute_Position);
				RC: "Position Error";
				N: MOV(Output.Position_Error,Position_Error);
				RC: "Velocity";
				N: DIV(Output.Actual_Velocity,240.0,Actual_Velocity);
				RC: "Input Status Extended";
				N: MOV(Output.Extended_Inputs,Extended_Inputs);
				RC: "Input Status Main";
				N: MOV(Output.Main_Board_Inputs,Main_Board_Inputs);
				RC: "Analog Input 1";
				N: MOV(Output.Analog_Input_1,Analog_Input_1);
				RC: "Analog Input 2";
				N: MOV(Output.Analog_Input_2,Analog_Input_2);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Jog_Move (Description := "Applied Motion - Jog Move AOI",
	                                            Revision := "1.0",
	                                            ExecutePrescan := No,
	                                            ExecutePostscan := No,
	                                            ExecuteEnableInFalse := No,
	                                            CreatedDate := "2017-11-16T21:13:24.555Z",
	                                            CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                            EditedDate := "2018-02-23T20:07:24.181Z",
	                                            EditedBy := "VM-RS2015-W7XX\Grantek",
	                                            SoftwareRevision := "v20.04",
	                                            AdditionalHelpText := "The Jog Move AOI is used to start jogging an axis at a specified speed and direction (a negative speed set point implies a CCW direction). ")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/min/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/min/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Start : BOOL (Description := "Start the Relative Move",
			                 Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Speed : REAL (Description := "Velocity of Move (rev/min)",
			                 Usage := Input,
			                 RADIX := Float,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0.00000000e+000);
			Acc : REAL (Description := "Acceleration of Move (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			Dec : REAL (Description := "Deceleration (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			Sent : BOOL (Description := "Move has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Move in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Move completed without errors - desired position reached",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Move failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to drive",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Loc_AlarmCode : AMP_Alarm_Word (ExternalAccess := None,
			                        DefaultData := "[0,0]");
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1)COP(Loc_Input_Assembly.Alarm_Code,Loc_AlarmCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle $N"
				    "(we maintain signals 30% longer than nominal RPI).";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=20 if motor was not faulted, otherwise go to the error state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Start)ONS(Loc_Start_ONS)[XIO(Loc_StatusCode.Drive_Fault) [CLR(Output[0]) ,MOV(20,State) ] ,XIC(Loc_StatusCode.Drive_Fault) MOV(10,State) ];
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Scale input parameters and set appropriate registers for this command$N"
				    "$N"
				    "Speed in rev/s, converted to 0.25 rev/min$N"
				    "Acceleration in rev/s/s, converted to 10 rev/min/s$N"
				    "Deceleration in rev/s/s, converted to 10 rev/min/s";
				N: EQU(State,30)[MUL(Speed,240.0,Output[1]) ,MUL(Acc,6.0,Output[2]) ,MUL(Dec,6.0,Output[3]) ];
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#10000,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80";
				N: EQU(State,60)[XIC(Loc_StatusCode.Jogging) XIC(Loc_StatusCode.Enabled) XIO(Loc_StatusCode.Drive_Fault) MOV(70,State) ,[XIC(Loc_StatusCode.Drive_Fault) ,XIC(Loc_StatusCode.In_Position) XIO(Loc_StatusCode.Enabled) ] MOV(80,State) ];
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(20,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Motor_Disable (Description := "Applied Motion - Motor Disable - AOI",
	                                                 Revision := "1.0",
	                                                 ExecutePrescan := No,
	                                                 ExecutePostscan := No,
	                                                 ExecuteEnableInFalse := No,
	                                                 CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                 CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                 EditedDate := "2018-03-21T18:42:08.461Z",
	                                                 EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                 SoftwareRevision := "v20.04",
	                                                 AdditionalHelpText := "The Motor Disable AOI disables motor outputs (reduces motor current to zero).")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Disable : BOOL (Description := "Disable the Drive (on rising edge)",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
			Sent : BOOL (Description := "Disable has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Disable in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Disable completed without errors - Drive is disabled",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Disable failed - Not Used",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to servo",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := Read/Write,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Disable_ONS : BOOL (RADIX := Decimal,
			                          ExternalAccess := Read/Write,
			                          DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Disable)ONS(Loc_Disable_ONS)MOV(10,State)CLR(Output[0]);
				RC: "State 10 - We do not check for drive readiness, simply set state=20";
				N: EQU(State,10)MOV(20,State);
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#4,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70";
				N: EQU(State,60)XIO(Loc_StatusCode.Enabled)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected during the sending and execution of the command, set the Error output bit$N"
				    "(Not used - Error always false)";
				N: LIM(10,State,60)XIO(Error)XIC(Error)OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(10,State,60)OTE(In_Progress);
				RC: "If sequence has progressed passed the command send completion, then indicate $QSent$Q";
				N: LIM(60,State,70)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Motor_Enable (Description := "Applied Motion - Motor Enable - AOI",
	                                                Revision := "1.0",
	                                                ExecutePrescan := No,
	                                                ExecutePostscan := No,
	                                                ExecuteEnableInFalse := No,
	                                                CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                EditedDate := "2018-03-21T18:41:47.959Z",
	                                                EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                SoftwareRevision := "v20.04",
	                                                AdditionalHelpText := "The Motor Enable AOI restores drive current to motor.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Enable : BOOL (Description := "Enable the Drive (on rising edge)",
			                  Usage := Input,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes,
			                  DefaultData := 0);
			Sent : BOOL (Description := "Enable has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Enable in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Enable completed without errors - Drive is enabled",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Enable failed -Not used",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to servo",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := Read/Write,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Enable_ONS : BOOL (RADIX := Decimal,
			                         ExternalAccess := Read/Write,
			                         DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Enable)ONS(Loc_Enable_ONS)MOV(10,State)CLR(Output[0]);
				RC: "State 10 - We do not check for drive readiness, simply set state=20";
				N: EQU(State,10)MOV(20,State);
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#2,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70";
				N: EQU(State,60)XIC(Loc_StatusCode.Enabled)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected during the sending and execution of the command, set the Error output bit$N"
				    "(Not used - Error always false)";
				N: LIM(10,State,60)XIO(Error)XIC(Error)OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(10,State,60)OTE(In_Progress);
				RC: "If sequence has progressed passed the command send completion, then indicate $QSent$Q";
				N: LIM(60,State,70)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Normal_Stop (Description := "Applied Motion - Stop/Kill using Normal Deceleration - AOI",
	                                               Revision := "1.0",
	                                               ExecutePrescan := No,
	                                               ExecutePostscan := No,
	                                               ExecuteEnableInFalse := No,
	                                               CreatedDate := "2017-11-16T21:13:24.555Z",
	                                               CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                               EditedDate := "2018-02-19T21:28:47.967Z",
	                                               EditedBy := "VM-RS2015-W7XX\Grantek",
	                                               SoftwareRevision := "v20.04",
	                                               AdditionalHelpText := "The Normal Stop AOI is used to stop and kill the drive using the normal deceleration set by the DE command.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Stop : BOOL (Description := "Stop the drive axis",
			                Usage := Input,
			                RADIX := Decimal,
			                Required := Yes,
			                Visible := Yes,
			                DefaultData := 0);
			Sent : BOOL (Description := "Stop has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Stop in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Stop completed without errors - Servo is not moving",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Stop failed - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := None,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to servo",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Stop_ONS : BOOL (RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Stop)ONS(Loc_Stop_ONS)MOV(10,State)CLR(Output[0]);
				RC: "State 10 - If drive is ready, then set state=20";
				N: EQU(State,10)XIC(Loc_StatusCode.Enabled)XIO(Loc_StatusCode.Drive_Fault)MOV(20,State);
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#8000,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70";
				N: EQU(State,60)XIO(Loc_StatusCode.Moving)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected during the sending and execution of the command, set the Error output bit";
				N: LIM(10,State,60)[XIO(Loc_StatusCode.Enabled) ,XIC(Loc_StatusCode.Drive_Fault) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(10,State,60)OTE(In_Progress);
				RC: "If sequence has progressed passed the command send completion, then indicate $QSent$Q";
				N: LIM(60,State,70)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Point_to_Point_IO (Description := "Applied Motion - Point to Point Move with IO AOI",
	                                                     Revision := "1.0",
	                                                     ExecutePrescan := No,
	                                                     ExecutePostscan := No,
	                                                     ExecuteEnableInFalse := No,
	                                                     CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                     CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                     EditedDate := "2018-03-26T19:47:04.193Z",
	                                                     EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                     SoftwareRevision := "v20.04",
	                                                     AdditionalHelpText := "The Point-to-Point Move with I/O AOI executes moves involving up to 2 Input conditions and a possible output state change. The move variant can be any of the following:$N- FS - Feed to Sensor$N- FD - Feed to Double Sensor$N- FM - Feed to Sensor with Mask Distance$N- FY - Feed to Sensor with Safety Distance$N- FO - Feed to Length and Set Output$N- FE - Follow Encoder$N- SH - Seek Home$NAll seven (7) of the above variants need exactly one I/O point except for FD which requires a second I/O point to be specified in the parameters.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Start : BOOL (Description := "Start the Move",
			                 Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Command : INT (Description := "Command variant: FS/FD/FY/FM/FO/SH/FE",
			                   Usage := Input,
			                   RADIX := ASCII,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 17989);
			IO1_Number : DINT (Description := "Main Input/Output Number (0 = Encoder index, 1-8 = In/Out 1-8)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := Yes,
			                      Visible := Yes,
			                      DefaultData := 0);
			IO1_Condition : SINT (Description := "Main Input/Output Condition/State H/L/R/F (High/Low/Rising Edge/Falling Edge)",
			                         Usage := Input,
			                         RADIX := ASCII,
			                         Required := Yes,
			                         Visible := Yes,
			                         DefaultData := 82);
			IO2_Number : DINT (Description := "Second Input/Output Number (0 = Encoder index, 1-8 = In/Out 1-8)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := Yes,
			                      Visible := Yes,
			                      DefaultData := 0);
			IO2_Condition : SINT (Description := "Second Input/Output Condition/State H/L/R/F (High/Low/Rising Edge/Falling Edge)",
			                         Usage := Input,
			                         RADIX := ASCII,
			                         Required := Yes,
			                         Visible := Yes,
			                         DefaultData := 0);
			IO_Connector : DINT (Description := "I/O Connector (1=IN/OUT 1, 2=IN/OUT 2)",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes,
			                        DefaultData := 1);
			Distance : DINT (Description := "Distance to Move (negative = reverse)",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := Yes,
			                    Visible := Yes,
			                    DefaultData := 0);
			Speed : REAL (Description := "Velocity of Move (rev/min)",
			                 Usage := Input,
			                 RADIX := Float,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0.00000000e+000);
			Acc : REAL (Description := "Acceleration of Move (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			Dec : REAL (Description := "Deceleration (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			Change_Distance : DINT (Description := "Change Distance (steps, FY/FM/FO only)",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := Yes,
			                           Visible := Yes,
			                           DefaultData := 0);
			Change_Speed : REAL (Description := "Velocity Change (rev/s) (FD only)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := Yes,
			                        Visible := Yes,
			                        DefaultData := 0.00000000e+000);
			Sent : BOOL (Description := "Move has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Move in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Move completed without errors - desired position reached",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Move failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to drive",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Loc_ChangeSpeed_Required : BOOL (RADIX := Decimal,
			                                   ExternalAccess := None,
			                                   DefaultData := 0);
			Loc_ChangeDistance_Required : BOOL (RADIX := Decimal,
			                                      ExternalAccess := None,
			                                      DefaultData := 0);
			Loc_IO1_Condition_Encoded : INT (RADIX := ASCII,
			                                    ExternalAccess := None,
			                                    DefaultData := 0);
			Loc_IO1_Number_Encoded : INT (RADIX := Decimal,
			                                 ExternalAccess := None,
			                                 DefaultData := 0);
			Loc_IO2_Condition_Encoded : INT (RADIX := ASCII,
			                                    ExternalAccess := None,
			                                    DefaultData := 0);
			Loc_IO2_Number_Encoded : INT (RADIX := Decimal,
			                                 ExternalAccess := None,
			                                 DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle $N"
				    "(we maintain signals 30% longer than nominal RPI).";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "If command is FD then a Change_Speed parameter setting is required$N"
				    "[FD = 16#4644]$N"
				    "If command is FY, FM or FO then a Change_Distance parameter setting is required$N"
				    "[FY = 16#4659]$N"
				    "[FM = 16#464d]$N"
				    "[FO = 16#464f]";
				N: [EQU(Command,16#4644) NEQ(Change_Speed,0.0) OTE(Loc_ChangeSpeed_Required) ,[EQU(Command,16#4659) ,EQU(Command,16#464d) ,EQU(Command,16#464f) ] NEQ(Change_Distance,0) OTE(Loc_ChangeDistance_Required) ];
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "Wait for command word to be non-zero for a long enough time (to ensure command value was seen by drive)";
				N: NEQ(Output[0],0)TON(Loc_CommandOn_Timer,?,?);
				RC: "When the command trigger is received, set state=12$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)";
				N: XIC(Start)ONS(Loc_Start_ONS)[XIO(Loc_StatusCode.Drive_Fault) [CLR(Output[0]) ,MOV(12,State) ] ,XIC(Loc_StatusCode.Drive_Fault) MOV(10,State) ];
				RC: "State 12 - VC: set Change Speed setting$N"
				    "$N"
				    "Send SCL command $QVC$Q (16#5643) with Reg1 = scaled velocity and Reg2 = 0$N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,12)[XIC(Loc_ChangeSpeed_Required) MOV(16#5643,Output[9]) MUL(Change_Speed,240.0,Output[10]) CLR(Output[11]) MOV(16#40000,Output[0]) ,[XIC(Loc_CommandOn_Timer.DN) ,XIO(Loc_ChangeSpeed_Required) ] CLR(Output[0]) MOV(13,State) ];
				RC: "Make sure the command word is idle before sending the next command";
				N: EQU(State,13)XIC(Loc_CommandOff_Timer.DN)MOV(14,State);
				RC: "State 14 - DC: set Change Distance$N"
				    "$N"
				    "Send SCL command $QDC$Q (16#4443) with Reg1 = Distance (steps or counts) $N"
				    "set command value for SCL (16#40000) and keep on for the set hold time";
				N: EQU(State,14)[XIC(Loc_ChangeDistance_Required) MOV(16#4443,Output[9]) MOV(Change_Distance,Output[10]) CLR(Output[11]) MOV(16#40000,Output[0]) ,[XIC(Loc_CommandOn_Timer.DN) ,XIO(Loc_ChangeDistance_Required) ] CLR(Output[0]) MOV(20,State) ];
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Scale input parameters and set appropriate registers for this command$N"
				    "$N"
				    "Distance in motor steps, no conversion required$N"
				    "Speed in rev/s, converted to 0.25 rev/min$N"
				    "Acceleration in rev/s/s, converted to 10 rev/min/s$N"
				    "Deceleration in rev/s/s, converted to 10 rev/min/s";
				N: EQU(State,30)[MOV(Distance,Output[7]) ,MUL(Speed,240,Output[4]) ,MUL(Acc,6,Output[5]) ,MUL(Dec,6,Output[6]) ];
				RC: "State 30 - Set IO input 1$N"
				    "$N"
				    "IO Point in Data/SCL Register 1$N"
				    "$N"
				    "Most Significant Byte encodes the condition (it$'s simply the ASCII code of the letter):$N"
				    "High = $'H$' = 16#48$N"
				    "Low = $'L$' = 16#4c$N"
				    "Rising = $'R$' = 16#52$N"
				    "Falling = $'F$' = 16#46$N"
				    "$N"
				    "Least Significant Byte encodes the I/O number:$N"
				    "0xB0-0xBC for connector 1 (IN/OUT1) depending on provided I/O number 0-12 (0=encoder)$N"
				    "0x30-0x3C for connector 2 (IN/OUT2) depending on provided I/O numbers 0-12 (0=encoder)$N"
				    "";
				N: EQU(State,30)[MUL(IO1_Condition,16#100,Loc_IO1_Condition_Encoded) ,EQU(IO_Connector,1) ADD(IO1_Number,16#B0,Loc_IO1_Number_Encoded) ,EQU(IO_Connector,2) ADD(IO1_Number,16#30,Loc_IO1_Number_Encoded) ,ADD(Loc_IO1_Condition_Encoded,Loc_IO1_Number_Encoded,Output[10]) ];
				RC: "State 30 - Set I/O Point 2$N"
				    "$N"
				    "IO Point 2 in Data/SCL Register 2$N"
				    "$N"
				    "Most Significant Byte encodes the condition:$N"
				    "High = $'H$' = 16#48$N"
				    "Low = $'L$' = 16#4c$N"
				    "Rising = $'R$' = 16#52$N"
				    "Falling = $'F$' = 16#46$N"
				    "$N"
				    "Least Significant Byte encodes the I/O number:$N"
				    "0xB0-0xBC for connector 1 (IN/OUT1) depending on provided I/O number 0-12 (0=encoder)$N"
				    "0x30-0x3C for connector 2 (IN/OUT2) depending on provided I/O numbers 0-12 (0=encoder)$N"
				    "";
				N: EQU(State,30)[MUL(IO2_Condition,16#100,Loc_IO2_Condition_Encoded) ,EQU(IO_Connector,1) ADD(IO2_Number,16#B0,Loc_IO2_Number_Encoded) ,EQU(IO_Connector,2) ADD(IO2_Number,16#30,Loc_IO2_Number_Encoded) ,ADD(Loc_IO2_Condition_Encoded,Loc_IO2_Number_Encoded,Output[11]) ];
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)$N"
				    "$N"
				    "FS (Feed to Sensor): ASCII = 16#4653, Cmd = 16#20, $N"
				    "FD (Feed to Double Sensor): ASCII = 16#4644, Cmd = 16#40, Feed to Double Sensor$N"
				    "FY (Feed to Sensor with Safety Distance): ASCII = 16#4659, Cmd = 16#80$N"
				    "FM (Feed to Sensor with Mask Distance): ASCII = 16#464d, Cmd = 16#100$N"
				    "FO (Feed to Length and Set Output): ASCII = 16#464f, Cmd = 16#200$N"
				    "SH (Seek Home): ASCII = 16#5348, Cmd = 16#800$N"
				    "FE (Follow Encoder): ASCII = 16#4645, Cmd = 16#2000";
				N: EQU(State,30)[[EQU(Command,16#4653) MOV(16#20,Output[0]) ,EQU(Command,16#4644) MOV(16#40,Output[0]) ,EQU(Command,16#4659) MOV(16#80,Output[0]) ,EQU(Command,16#464d) MOV(16#100,Output[0]) ,EQU(Command,16#464f) MOV(16#200,Output[0]) ,EQU(Command,16#5348) MOV(16#800,Output[0]) ,EQU(Command,16#4645) MOV(16#2000,Output[0]) ] ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80";
				N: EQU(State,60)[XIO(Loc_StatusCode.Moving) XIC(Loc_StatusCode.Enabled) XIO(Loc_StatusCode.Drive_Fault) MOV(70,State) ,[XIC(Loc_StatusCode.Drive_Fault) ,XIO(Loc_StatusCode.Moving) XIO(Loc_StatusCode.Enabled) ] MOV(80,State) ];
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(12,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Q_Segment_Execute (Description := "Applied Motion - Q Segment Execute AOI",
	                                                     Revision := "1.0",
	                                                     ExecutePrescan := No,
	                                                     ExecutePostscan := No,
	                                                     ExecuteEnableInFalse := No,
	                                                     CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                     CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                     EditedDate := "2018-02-26T23:06:03.384Z",
	                                                     EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                     SoftwareRevision := "v20.04",
	                                                     AdditionalHelpText := "The SCL Command Execute AOI executes selected SCL commands (as listed under “Available SCL Commands” in the Host Command Reference).")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			LoadAndExec : BOOL (Description := "Load and Execute the specified Q segment (edge triggered)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := Yes,
			                       Visible := Yes,
			                       DefaultData := 0);
			Q_Segment : DINT (Description := "Q Segment to Load and Execute",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := Yes,
			                     Visible := Yes,
			                     DefaultData := 0);
			Sent : BOOL (Description := "Command has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "In progress = sending command",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Command sent",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Command failed to be sent",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to drive",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle $N"
				    "(we maintain signals 30% longer than nominal RPI).";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=20$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(LoadAndExec)ONS(Loc_Start_ONS)MOV(20,State)CLR(Output[0]);
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Transform input parameters and output to drive output assembly$N"
				    "$N"
				    "";
				N: EQU(State,30)MOV(Q_Segment,Output[10]);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#80000,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80 [ Error detection is not currently used ]";
				N: EQU(State,60)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected during the sending of the command or reaching the final position, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(20,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Relative_Move (Description := "Applied Motion - Relative Move AOI",
	                                                 Revision := "1.0",
	                                                 ExecutePrescan := No,
	                                                 ExecutePostscan := No,
	                                                 ExecuteEnableInFalse := No,
	                                                 CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                 CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                 EditedDate := "2018-03-26T19:31:17.564Z",
	                                                 EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                 SoftwareRevision := "v20.04",
	                                                 AdditionalHelpText := "The Relative Move AOI is used to move an axis by a specified distance (positive or negative) relative to its currently commanded position.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/min/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/min/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Start : BOOL (Description := "Start the Relative Move",
			                 Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Distance : DINT (Description := "Relative Distance to Move (steps, negative = reverse)",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := Yes,
			                    Visible := Yes,
			                    DefaultData := 0);
			Speed : REAL (Description := "Velocity of Move (rev/min)",
			                 Usage := Input,
			                 RADIX := Float,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0.00000000e+000);
			Acc : REAL (Description := "Acceleration of Move (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			Dec : REAL (Description := "Deceleration (rev/s/s)",
			               Usage := Input,
			               RADIX := Float,
			               Required := Yes,
			               Visible := Yes,
			               DefaultData := 0.00000000e+000);
			Sent : BOOL (Description := "Move has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Move in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Move completed without errors - desired position reached",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Move failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to drive",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Loc_AlarmCode : AMP_Alarm_Word (ExternalAccess := None,
			                        DefaultData := "[0,0]");
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1)COP(Loc_Input_Assembly.Alarm_Code,Loc_AlarmCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle $N"
				    "(we maintain signals 30% longer than nominal RPI).";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=20 if motor was not faulted, otherwise go to the error state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Start)ONS(Loc_Start_ONS)[XIO(Loc_StatusCode.Drive_Fault) [CLR(Output[0]) ,MOV(20,State) ] ,XIC(Loc_StatusCode.Drive_Fault) MOV(10,State) ];
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Scale input parameters and set appropriate registers for this command$N"
				    "$N"
				    "Distance in motor steps, no conversion required$N"
				    "Speed in rev/s, converted to 0.25 rev/min$N"
				    "Acceleration in rev/s/s, converted to 10 rev/min/s$N"
				    "Deceleration in rev/s/s, converted to 10 rev/min/s";
				N: EQU(State,30)[MOV(Distance,Output[7]) ,MUL(Speed,240.0,Output[4]) ,MUL(Acc,6.0,Output[5]) ,MUL(Dec,6.0,Output[6]) ];
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#0008,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80";
				N: EQU(State,60)[XIO(Loc_StatusCode.Moving) XIC(Loc_StatusCode.Enabled) XIO(Loc_StatusCode.Drive_Fault) MOV(70,State) ,[XIC(Loc_StatusCode.Drive_Fault) ,XIO(Loc_StatusCode.Moving) XIO(Loc_StatusCode.Enabled) ] MOV(80,State) ];
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(20,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Status_Code (Description := "Applied Motion - Status Code AOI",
	                                               Revision := "1.0",
	                                               ExecutePrescan := No,
	                                               ExecutePostscan := No,
	                                               ExecuteEnableInFalse := No,
	                                               CreatedDate := "2012-03-28T13:25:24.614Z",
	                                               CreatedBy := "MATT-F3A979C4EF\Administrator",
	                                               EditedDate := "2018-03-29T21:18:32.952Z",
	                                               EditedBy := "VM-RS2015-W7XX\Grantek",
	                                               SoftwareRevision := "v20.04",
	                                               AdditionalHelpText := "The Status Code AOI uses the raw data stored in the Status Code word (Element 0 from Input Assembly 0x65) to set individual appropriately named boolean outputs.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT (Description := "Element 0 from Drive Input Assembly (0x65)",
			                 Usage := Input,
			                 RADIX := Hex,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Motor_Enabled : BOOL (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sampling : BOOL (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Drive_Fault : BOOL (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			In_Position : BOOL (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Moving : BOOL (Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Jogging : BOOL (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Stopping : BOOL (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Waiting : BOOL (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Saving : BOOL (Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Alarm_Present : BOOL (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Homing : BOOL (Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Wait_Time : BOOL (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wizard_Running : BOOL (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Checking_Encoder : BOOL (Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Q_Program_Running : BOOL (Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := Yes,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0);
			Initializing : BOOL (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Status Code$N"
				    "Takes the status WORD and breaks it into BITS that are easily used in the program. $N"
				    "";
				N: XIC(Input.0)OTE(Motor_Enabled);
				N: XIC(Input.1)OTE(Sampling);
				N: XIC(Input.2)OTE(Drive_Fault);
				N: XIC(Input.3)OTE(In_Position);
				N: XIC(Input.4)OTE(Moving);
				N: XIC(Input.5)OTE(Jogging);
				N: XIC(Input.6)OTE(Stopping);
				N: XIC(Input.7)OTE(Waiting);
				N: XIC(Input.8)OTE(Saving);
				N: XIC(Input.9)OTE(Alarm_Present);
				N: XIC(Input.10)OTE(Homing);
				N: XIC(Input.11)OTE(Wait_Time);
				N: XIC(Input.12)OTE(Wizard_Running);
				N: XIC(Input.13)OTE(Checking_Encoder);
				N: XIC(Input.14)OTE(Q_Program_Running);
				N: XIC(Input.15)OTE(Initializing);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Tuning_Params_StepSERVO (Description := "Applied Motion - Tuning Parameters StepSERVO AOI",
	                                                           Revision := "1.0",
	                                                           ExecutePrescan := No,
	                                                           ExecutePostscan := No,
	                                                           ExecuteEnableInFalse := No,
	                                                           CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                           CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                           EditedDate := "2018-03-21T21:08:37.613Z",
	                                                           EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                           SoftwareRevision := "v20.04",
	                                                           AdditionalHelpText := "The Tuning Parameters for StepSERVO AOI accepts all the required parameters for SCL commands VP, VI, KK, KC, KP, KD and KE, and then scales and issues these to the drive, one at a time.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			MSG_Write : SINT[8] (Description := "Message Write data tag",
			                     COMMENT[0] := "Message Reserved = 0",
			                     COMMENT[1] := "Message Type (16#01 or 16#02)",
			                     COMMENT[2] := "Type 1: Register$NType 2: Opcode",
			                     COMMENT[3] := "Type 1: Opcode$NType 2: Operand",
			                     COMMENT[4] := "Type 1: Parameter 1$NType 2: data MSB",
			                     COMMENT[5] := "Type 1: Parameter 2$NType 2: data LSB",
			                     COMMENT[6] := "Type 1: Parameter 3$NType 2: not used",
			                     COMMENT[7] := "Type 1: Parameter 4$NType 2: not used",
			                     Usage := InOut,
			                     RADIX := Decimal,
			                     Required := Yes,
			                     Visible := Yes);
			SendMsg : MESSAGE (Description := "Message tag",
			                   Usage := InOut,
			                   Required := Yes,
			                   Visible := Yes);
			MSG_Response : SINT[8] (Description := "Message Response data tag",
			                        COMMENT[0] := "Command Word",
			                        COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                        COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                        COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                        COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                        COMMENT[5] := "Point-to-Point Acceleration (10 rev/s/s)",
			                        COMMENT[6] := "Point-to-Point Deceleration (10 rev/s/s)",
			                        COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                        Usage := InOut,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes);
			Configure : BOOL (Description := "Start the Configuration",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := Yes,
			                     Visible := Yes,
			                     DefaultData := 0);
			VP : INT (Description := "Velocity Mode Proportional Constant",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			VI : INT (Description := "Velocity Integrator Constant",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			KP : INT (Description := "Proportional Global Gain Value",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			KK : INT (Description := "Inertia Feedforward Gain",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			KE : INT (Description := "Differential Filter Gain Value",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			KD : INT (Description := "Damping Gain Value",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			KC : INT (Description := "Overall Servo Filter value",
			              Usage := Input,
			              RADIX := Decimal,
			              Required := Yes,
			              Visible := Yes,
			              DefaultData := 0);
			Sent : BOOL (Description := "All parameter settings have been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "The setting of parameters is in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Parameters set without errors",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Configuration failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 34);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			MSG_Active : BOOL (RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "When the command trigger is received and start conditions are deemed ok, set state=12$N"
				    "if trigger is received when start conditions indicate that failure is inevitable, set state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)";
				N: XIC(Configure)ONS(Loc_Start_ONS)[XIO(SendMsg.EN) MOV(12,State) ,XIC(SendMsg.EN) MOV(10,State) ];
				RC: "State 12 - VP - Velocity Mode Proportional Constant$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QVP$Q parameter (operand =16#0E) with data = Velocity Mode Gain";
				N: EQU(State,12)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#0E,MSG_Write[3])BTD(VP,8,MSG_Write[4],0,8)BTD(VP,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(13,State);
				N: EQU(State,13)XIC(SendMsg.EN)MOV(14,State);
				N: EQU(State,14)[XIC(SendMsg.DN) MOV(15,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 15 - VI - Velocity Integrator Constant$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QVI$Q parameter (operand =16#0F) with data = Velocity Mode Integ Gain";
				N: EQU(State,15)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#0F,MSG_Write[3])BTD(VI,8,MSG_Write[4],0,8)BTD(VI,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(16,State);
				N: EQU(State,16)XIC(SendMsg.EN)MOV(17,State);
				N: EQU(State,17)[XIC(SendMsg.DN) MOV(18,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 18 - KK - Inertia Feedforward Constant$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QKK$Q parameter (operand =16#0C) with data = Inertia Feedforward Gain";
				N: EQU(State,18)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#0C,MSG_Write[3])BTD(KK,8,MSG_Write[4],0,8)BTD(KK,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(19,State);
				N: EQU(State,19)XIC(SendMsg.EN)MOV(20,State);
				N: EQU(State,20)[XIC(SendMsg.DN) MOV(21,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 21 - KC - Overall Servo Filter$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QKC$Q parameter (operand =16#51) with $N"
				    "data = provided file gain value. Filter value = (72090 / (1400/F + 2.2), where F = desired filter Frequency in Hz.";
				N: EQU(State,21)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#51,MSG_Write[3])BTD(KC,8,MSG_Write[4],0,8)BTD(KC,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(22,State);
				N: EQU(State,22)XIC(SendMsg.EN)MOV(23,State);
				N: EQU(State,23)[XIC(SendMsg.DN) MOV(24,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 24 - KP - Proportional Constant$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QKP$Q parameter (operand =16#07) with data = provided global gain value";
				N: EQU(State,24)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#07,MSG_Write[3])BTD(KP,8,MSG_Write[4],0,8)BTD(KP,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(25,State);
				N: EQU(State,25)XIC(SendMsg.EN)MOV(26,State);
				N: EQU(State,26)[XIC(SendMsg.DN) MOV(27,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 27 - KD - Differential Constant $N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QKD$Q parameter (operand =16#0D) with data = provided damping gain value";
				N: EQU(State,27)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#0D,MSG_Write[3])BTD(KD,8,MSG_Write[4],0,8)BTD(KD,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(28,State);
				N: EQU(State,28)XIC(SendMsg.EN)MOV(29,State);
				N: EQU(State,29)[XIC(SendMsg.DN) MOV(30,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				RC: "State 30 - KE - Differential Filter$N"
				    "$N"
				    "Send explicit Type 2 message $QParameter write$Q (opcode 16#83) for setting $QKE$Q parameter (operand =16#0F) with data = provided differential filter gain value. Filter value = (72090 / (1400/F + 2.2), where F = desired filter Frequency in Hz.";
				N: EQU(State,30)XIO(SendMsg.EN)MOV(16#00,MSG_Write[0])MOV(16#02,MSG_Write[1])MOV(16#83,MSG_Write[2])MOV(16#4F,MSG_Write[3])BTD(KE,8,MSG_Write[4],0,8)BTD(KE,0,MSG_Write[5],0,8)CLR(MSG_Write[6])CLR(MSG_Write[7])MOV(31,State);
				N: EQU(State,31)XIC(SendMsg.EN)MOV(32,State);
				N: EQU(State,32)[XIC(SendMsg.DN) MOV(33,State) ,XIC(SendMsg.ER) MOV(80,State) ];
				N: [EQU(State,13) ,EQU(State,16) ,EQU(State,19) ,EQU(State,22) ,EQU(State,25) ,EQU(State,28) ,EQU(State,31) ]MSG(SendMsg);
				RC: "Last Configuration setting is complete. Wait for Message instruction to be non-enabled";
				N: EQU(State,33)XIO(SendMsg.EN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80$N"
				    "[The command was successful when all parameters have been sent]";
				N: EQU(State,60)MOV(70,State);
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(12,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AMP_Update_Jog_Speed (Description := "Applied Motion - Update Jog Speed AOI",
	                                                    Revision := "1.0",
	                                                    ExecutePrescan := No,
	                                                    ExecutePostscan := No,
	                                                    ExecuteEnableInFalse := No,
	                                                    CreatedDate := "2017-11-16T21:13:24.555Z",
	                                                    CreatedBy := "VM-RS2015-W7XX\Grantek",
	                                                    EditedDate := "2018-03-22T20:36:24.995Z",
	                                                    EditedBy := "VM-RS2015-W7XX\Grantek",
	                                                    SoftwareRevision := "v20.04",
	                                                    AdditionalHelpText := "The Jog Move AOI is used to start jogging an axis at a specified speed and direction (a negative speed set point implies a CCW direction). ")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Input : DINT[14] (Description := "Drive Input Assembly",
			                 Usage := InOut,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes);
			Output : DINT[16] (Description := "Drive Output Assembly",
			                  COMMENT[0] := "Command Word",
			                  COMMENT[1] := "Jog Speed (0.25 rev/min)",
			                  COMMENT[2] := "Jog Acceleration (10 rev/s/s)",
			                  COMMENT[3] := "Jog Deceleration (10 rev/s/s)",
			                  COMMENT[4] := "Point-to-Point Velocity (0.25 rev/min)",
			                  COMMENT[5] := "Point-to-Point Acceleration (10 rev/min/s)",
			                  COMMENT[6] := "Point-to-Point Deceleration (10 rev/min/s)",
			                  COMMENT[7] := "Point-to-Point Distance (Motor steps)",
			                  COMMENT[9] := "(2x ASCII Letters in 16 lower word)",
			                  COMMENT[10] := "Data/Register 1",
			                  COMMENT[11] := "Data/Register 2",
			                  Usage := InOut,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes);
			RPI : DINT (Description := "Drive Connection Request Packet Interval (milliseconds)",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 100);
			Start : BOOL (Description := "Start the Relative Move",
			                 Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Speed : REAL (Description := "Updated Jog Velocity (rev/min)",
			                 Usage := Input,
			                 RADIX := Float,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0.00000000e+000);
			Sent : BOOL (Description := "Updated Jog Velocity has been sent to drive",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			In_Progress : BOOL (Description := "Jog Velocity Update in progress",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Done : BOOL (Description := "Jog Velocity Update completed without errors",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Description := "Jog Velocity Update failed to complete - drive not ready or faulted",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			State : DINT (Description := "Internal state of progress",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read Only,
			                 DefaultData := 10);
		END_PARAMETERS

		LOCAL_TAGS
			Loc_StatusCode : AMP_Status_Word (ExternalAccess := Read/Write,
			                         DefaultData := "[0,0]");
			Loc_CommandOff_Timer : TIMER (Description := "Timer to make sure command value was 0 before sending a new command",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,0,0]");
			Loc_CommandOn_Timer : TIMER (Description := "Timer to make sure command value is set long enough to be sent to drive",
			                              ExternalAccess := Read/Write,
			                              DefaultData := "[0,0,0]");
			Loc_Input_Assembly : AMP_Input_Assembly_v2 (ExternalAccess := None,
			                             DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0,0,0]");
			Loc_Start_ONS : BOOL (RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Loc_AlarmCode : AMP_Alarm_Word (ExternalAccess := None,
			                        DefaultData := "[0,0]");
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Create readable local copy of the input assembly and status";
				N: COP(Input[0],Loc_Input_Assembly,1)COP(Loc_Input_Assembly.Status_Code,Loc_StatusCode,1)COP(Loc_Input_Assembly.Alarm_Code,Loc_AlarmCode,1);
				RC: "Make sure the ethernet/ip commands are maintained long enough to catch at least one RPI cycle $N"
				    "(we maintain signals 30% longer than nominal RPI).";
				N: MUL(RPI,1.3,Loc_CommandOff_Timer.PRE)MUL(RPI,1.3,Loc_CommandOn_Timer.PRE);
				RC: "Wait for command word to be zero for a long enough time (to ensure command value is idle)";
				N: EQU(Output[0],0)TON(Loc_CommandOff_Timer,?,?);
				RC: "When command trigger is received, set state=20 if motor was not faulted, otherwise go to the error state=10$N"
				    "(Clear the output assembly command word, in case it wasn$'t already zero = idle)$N"
				    "";
				N: XIC(Start)ONS(Loc_Start_ONS)[XIO(Loc_StatusCode.Drive_Fault) [CLR(Output[0]) ,MOV(20,State) ] ,XIC(Loc_StatusCode.Drive_Fault) MOV(10,State) ];
				RC: "State 20 - Make sure the command word is idle, then set state=30";
				N: EQU(State,20)XIC(Loc_CommandOff_Timer.DN)MOV(30,State);
				RC: "State 30 - Scale input parameters and set appropriate registers for this command$N"
				    "$N"
				    "Speed in rev/s, converted to 0.25 rev/min$N"
				    "Acceleration in rev/s/s, converted to 10 rev/min/s$N"
				    "Deceleration in rev/s/s, converted to 10 rev/min/s";
				N: EQU(State,30)MUL(Speed,240.0,Output[1]);
				RC: "State 30 - Set output command bit for the set hold time $N"
				    "(if timer preset is zero, then command is maintained for one full scan)";
				N: EQU(State,30)[MOV(16#20000,Output[0]) ,TON(Loc_CommandOn_Timer,?,?) ,XIC(Loc_CommandOn_Timer.DN) MOV(40,State) ];
				RC: "State 40 - When the command has been held high long enough, clear the command";
				N: EQU(State,40)[CLR(Output[0]) ,MOV(50,State) ];
				RC: "State 50 - Hold the idle command value (0) for a set time long enough to reach the next RPI cycle";
				N: EQU(State,50)XIC(Loc_CommandOff_Timer.DN)MOV(60,State);
				RC: "State 60 - Wait for the status to indicate that the command was successful, then move to final state=70$N"
				    "If an error is detected, set the error state=80";
				N: EQU(State,60)[XIC(Loc_StatusCode.Jogging) XIC(Loc_StatusCode.Enabled) XIO(Loc_StatusCode.Drive_Fault) MOV(70,State) ,[XIC(Loc_StatusCode.Drive_Fault) ,XIC(Loc_StatusCode.In_Position) XIO(Loc_StatusCode.Enabled) ] MOV(80,State) ];
				RC: "State 70 - Final state. Hold Done output until the next execution of this AOI instance.";
				N: EQU(State,70)OTE(Done);
				RC: "Exception: if a problem is detected either during before or during execution of the command, set the Error output bit";
				N: [EQU(State,10) ,EQU(State,80) ]OTE(Error);
				RC: "If sequence is started and has not yet reached a final state, then indicate $QIn Progress$Q";
				N: LIM(20,State,60)OTE(In_Progress);
				RC: "If sequence is passed the state where the command has been sent, then indicate $QSent$Q";
				N: LIM(60,State,80)OTE(Sent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_Controlword_6040h (Description := "AOI to switch up or down the drive state machine or clear an error state.",
	                                                     Revision := "1.1",
	                                                     RevisionNote := "1.1: Fix a problem with display quick stop",
	                                                     Vendor := "Nanotec Electronic GmbH & Co. KG",
	                                                     ExecutePrescan := No,
	                                                     ExecutePostscan := No,
	                                                     ExecuteEnableInFalse := No,
	                                                     CreatedDate := "2015-03-04T16:12:36.473Z",
	                                                     CreatedBy := "NANOTEC\entwickler_la",
	                                                     EditedDate := "2015-11-09T16:31:09.346Z",
	                                                     EditedBy := "NANOTEC\schormann_m",
	                                                     SoftwareRevision := "v20.01",
	                                                     AdditionalHelpText := "Select a operation mode:$NOpMode = 1 -> Switch up the Od6040h drive state machine.$NOpMode = 2 -> Switch down the Od6040h drive state machine.$NOpMode = 3 -> Clear the failture bit in Od6041h.$N$NExecute a command:$NSet Execute = 1 to run the command which is selected by OpMode. After execution the state is shown. Done if everything okay and Error if something was wrong by the communication. After execution you must set Execute = 0 again after that it is possible to run another command.$NThe Output Quickstop shows if a quickstop has occured.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Od6040h : DINT (Usage := InOut,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes);
			Od6041h : DINT (Usage := InOut,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes);
			OpMode : DINT (Usage := Input,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes,
			                  DefaultData := 0);
			Done : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Error : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			Quickstop : BOOL (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			StateMachine : DINT (RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			StateMachine_Status : DINT (RADIX := Decimal,
			                              ExternalAccess := None,
			                              DefaultData := 0);
			VAR32 : DINT (RADIX := Decimal,
			                ExternalAccess := None,
			                DefaultData := 0);
			StateMachine_Status_0xF : DINT (RADIX := Decimal,
			                                  ExternalAccess := None,
			                                  DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Copy the status word 6041h from the input assembly into the variable StateMachine_Status.";
				N: MOV(0,StateMachine_Status)BTD(Od6041h,0,StateMachine_Status,0,7);
				RC: "The variable StatemachineStatus_0xF should only contain the first 4 bits of the status word 6041h, because they reflect the CiA402 statemachine.";
				N: MOV(0,StateMachine_Status_0xF)BTD(Od6041h,0,StateMachine_Status_0xF,0,4);
				RC: "Operation mode = 1 -> Switch automatically 6040h from 0 or 6 to 15. Example: 0, 6, 7, 15. For explanations of the state machine see  technical manual.";
				N: XIO(Error)XIO(Done)XIC(Execute)EQU(OpMode,1)CLR(StateMachine)[EQU(StateMachine_Status_0xF,0) MVM(Od6040h,16#FFFFFFF0,StateMachine) OR(StateMachine,6,StateMachine) MOV(StateMachine,Od6040h) OTU(Quickstop) ,[EQU(StateMachine_Status,33) ,EQU(StateMachine_Status,49) ] MVM(Od6040h,16#FFFFFFF0,StateMachine) OR(StateMachine,7,StateMachine) MOV(StateMachine,Od6040h) OTU(Quickstop) ,[EQU(StateMachine_Status,35) ,EQU(StateMachine_Status,51) ] MVM(Od6040h,16#FFFFFFF0,StateMachine) OR(StateMachine,15,StateMachine) MOV(StateMachine,Od6040h) OTU(Quickstop) ,EQU(StateMachine_Status,55) OTU(Quickstop) OTL(Done) ];
				RC: "Operation mode =2 -> Switch automatically 6040h from 15 to 6. Example: 15, 7, 6. For explanations of the state machine see  technical manual.";
				N: XIO(Error)XIO(Done)XIC(Execute)EQU(OpMode,2)CLR(StateMachine)[EQU(StateMachine_Status,55) MVM(Od6040h,16#FFFFFFF0,StateMachine) OR(StateMachine,7,StateMachine) MOV(StateMachine,Od6040h) ,EQU(StateMachine_Status,51) MVM(Od6040h,16#FFFFFFF0,StateMachine) OR(StateMachine,6,StateMachine) MOV(StateMachine,Od6040h) OTL(Done) ];
				RC: "Operation mode = 3 -> Confirms an error and clear the error bit in OD-entry 6041h.";
				N: XIO(Done)XIC(Execute)EQU(OpMode,3)MOV(Od6040h,VAR32)OR(Od6040h,16#80,Od6040h);
				RC: "If operation mode = 3, checks if the bit3 (error) is cleared and then set the $'Done$' output.";
				N: XIO(Done)XIC(Execute)EQU(OpMode,3)XIO(Od6041h.3)MOV(VAR32,Od6040h)OTL(Done);
				RC: "If the $'Execute$' bit is cleared, clear the $'Done$' output.";
				N: XIO(Execute)OTU(Done);
				RC: "If the error bit is set in 6041h, the error output is set.";
				N: XIC(Od6041h.3)OTL(Error);
				RC: "If the error bit is not set in 6041h, the error output is cleared.";
				N: XIO(Od6041h.3)OTU(Error);
				RC: "Check if motion control is in quick stop state while this AOI executed, tjem set the statemachine to power off (6040h=0) and signal $'Quickstop$' on the output.";
				N: XIO(Od6041h.5)XIC(Execute)NEQ(StateMachine_Status_0xF,0)CLR(StateMachine)MVM(Od6040h,16#FFFFFFF0,StateMachine)OR(StateMachine,6,StateMachine)MOV(StateMachine,Od6040h)OTL(Quickstop);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_GetOdEntry (Description := "Get a object dictionary entry. Writes the data always into a DINT. This function is the best approach for Rockwell because the object definition is sent, too. So the AOI can easily convert the reply into a DINT.",
	                                              Revision := "1.0",
	                                              ExecutePrescan := No,
	                                              ExecutePostscan := No,
	                                              ExecuteEnableInFalse := No,
	                                              CreatedDate := "2015-02-02T08:30:40.731Z",
	                                              CreatedBy := "NANOTEC\entwickler_la",
	                                              EditedDate := "2015-11-10T08:53:29.833Z",
	                                              EditedBy := "NANOTEC\schormann_m",
	                                              SoftwareRevision := "v20.01",
	                                              AdditionalHelpText := "Reads out a value from the object dictionary entry. $N$NInputs:$N1. Index:  (see technical manual for OD-entries)$N2. Subindex:  (see technical manual for OD-entries)$N$NOutputs:$N1. Data: The value which is read out of the OD-entry.$N2. Error: If there was an error while reading, this flag is set.$N3: Done: If the read out is finished, this flag is set$N$NInOut:$N1. Data_String: If a String is read out it will be stored here. ")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Done : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := None,
			                DefaultData := 0);
			Error : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
			Send_MSG : MESSAGE (Usage := InOut,
			                    Required := Yes,
			                    Visible := Yes);
			MSG_Data_Input : SINT[100] (Usage := InOut,
			                          RADIX := Decimal,
			                          Required := Yes,
			                          Visible := Yes);
			MSG_Data_Output : SINT[100] (Usage := InOut,
			                           RADIX := Decimal,
			                           Required := Yes,
			                           Visible := Yes);
			Index : DINT (Usage := Input,
			                 RADIX := Hex,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Subindex : DINT (Usage := Input,
			                    RADIX := Hex,
			                    Required := Yes,
			                    Visible := Yes,
			                    DefaultData := 0);
			Data : DINT (Usage := Output,
			                RADIX := Decimal,
			                Required := Yes,
			                Visible := Yes,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Data_String : STRING (Usage := InOut,
			                       Required := Yes,
			                       Visible := Yes);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Message_prepared : BOOL (RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Trigger : BOOL (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR16 : INT (RADIX := Decimal,
			                ExternalAccess := None,
			                DefaultData := 0);
			DataLen : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			ObjType : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				N: XIO(Execute)XIO(Send_MSG.EN)XIC(Send_MSG.DN)OTU(Done);
				RC: "Prepare and send the message.";
				N: XIC(Execute)ONS(Trigger)BTD(Index,0,MSG_Data_Input[0],0,8)BTD(Index,8,MSG_Data_Input[1],0,8)BTD(Subindex,0,MSG_Data_Input[2],0,8)MSG(Send_MSG);
				RC: "Interpret the answer and convert the data into DINT or into a string.$N"
				    "The received ObjType specifies the data.";
				N: XIC(Execute)XIC(Send_MSG.DN)COP(MSG_Data_Output[0],ObjType,2)COP(MSG_Data_Output[2],DataLen,2)[EQU(ObjType,2) MOV(MSG_Data_Output[4],Data) ,EQU(ObjType,3) COP(MSG_Data_Output[4],VAR16,2) MOV(VAR16,Data) ,EQU(ObjType,4) COP(MSG_Data_Output[4],Data,4) ,LIM(5,ObjType,7) COP(MSG_Data_Output[4],Data,DataLen) ,EQU(ObjType,8) COP(MSG_Data_Output[4],Data,4) ,EQU(ObjType,9) COP(MSG_Data_Output[4],Data_String.DATA[0],DataLen) MOV(DataLen,Data_String.LEN) ]OTL(Done);
				N: GRT(Send_MSG.ERR,0)OTE(Error);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_SetOdEntry (Description := "Set a object dictionary entry.",
	                                              Revision := "1.0",
	                                              ExecutePrescan := No,
	                                              ExecutePostscan := No,
	                                              ExecuteEnableInFalse := No,
	                                              CreatedDate := "2015-02-02T08:30:40.731Z",
	                                              CreatedBy := "NANOTEC\entwickler_la",
	                                              EditedDate := "2015-11-10T09:02:36.665Z",
	                                              EditedBy := "NANOTEC\schormann_m",
	                                              SoftwareRevision := "v20.01",
	                                              AdditionalHelpText := "Writest a value into the object dictionary entry. $N$NInputs:$N1. Index:  (see technical manual for OD-entries)$N2. Subindex:  (see technical manual for OD-entries)$N3. DataSize: Check the data size for that OD-entry in the technical manual$N4. Data: The value which should be written into  the OD-entry.$N$NOutputs:$N1. Error: If there was an error while writing, this flag is set.$N2: Done: If the write is finished, this flag is set")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Done : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := None,
			                DefaultData := 0);
			Error : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
			Send_MSG : MESSAGE (Usage := InOut,
			                    Required := Yes,
			                    Visible := Yes);
			MSG_Data_Input : SINT[7] (Usage := InOut,
			                          RADIX := Decimal,
			                          Required := Yes,
			                          Visible := Yes);
			Index : DINT (Usage := Input,
			                 RADIX := Hex,
			                 Required := Yes,
			                 Visible := Yes,
			                 DefaultData := 0);
			Subindex : DINT (Usage := Input,
			                    RADIX := Hex,
			                    Required := Yes,
			                    Visible := Yes,
			                    DefaultData := 0);
			Data_Size : DINT (Usage := Input,
			                     RADIX := Decimal,
			                     Required := Yes,
			                     Visible := Yes,
			                     DefaultData := 0);
			Data : DINT (Usage := Input,
			                RADIX := Decimal,
			                Required := Yes,
			                Visible := Yes,
			                DefaultData := 0);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Message_prepared : BOOL (RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Trigger : BOOL (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "If message is sent, signal $'Done$' on the output.";
				N: XIO(Execute)XIO(Send_MSG.EN)XIC(Send_MSG.DN)OTU(Done);
				RC: "Prepare and send the message.";
				N: XIC(Execute)ONS(Trigger)BTD(Index,0,MSG_Data_Input[0],0,8)BTD(Index,8,MSG_Data_Input[1],0,8)BTD(Subindex,0,MSG_Data_Input[2],0,8)COP(Data,MSG_Data_Input[3],4)MSG(Send_MSG);
				N: GRT(Send_MSG.ERR,0)OTE(Error);
				N: XIC(Execute)XIC(Send_MSG.DN)OTL(Done);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_MotorDriveSubmodeSelect_3202h (Description := "AOI to get or set the motor drive submode in OD-entry 3202h.",
	                                                                 Revision := "1.0",
	                                                                 Vendor := "Nanotec Electronic GmbH & Co. KG",
	                                                                 ExecutePrescan := No,
	                                                                 ExecutePostscan := No,
	                                                                 ExecuteEnableInFalse := No,
	                                                                 CreatedDate := "2015-03-06T11:51:23.193Z",
	                                                                 CreatedBy := "NANOTEC\entwickler_la",
	                                                                 EditedDate := "2015-07-14T14:20:23.232Z",
	                                                                 EditedBy := "NANOTEC\schormann_m",
	                                                                 SoftwareRevision := "v21.03",
	                                                                 AdditionalHelpText := "Select a operation mode:$NOpMode = 1 -> Get the value of Od3202h and move it into Output.$NOpMode = 2 -> Set the value in Input and move it into Od3202h.$N$NExecute a command:$NSet Execute = 1 to run the command which is selected by OpMode. After execution the state is shown. Done if everything okay and Error if something was wrong by the communication. After execution you must set Execute = 0 again after that it is possible to run another command.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			GetOdEntry_MSG : MESSAGE (Usage := InOut,
			                          Required := Yes,
			                          Visible := Yes);
			SetOdEntry_MSG : MESSAGE (Usage := InOut,
			                          Required := Yes,
			                          Visible := Yes);
			MSG_Data_Input : SINT[100] (Usage := InOut,
			                          RADIX := Decimal,
			                          Required := Yes,
			                          Visible := Yes);
			MSG_Data_Output : SINT[100] (Usage := InOut,
			                           RADIX := Decimal,
			                           Required := Yes,
			                           Visible := Yes);
			Input : DINT (Usage := Input,
			                 RADIX := Decimal,
			                 Required := Yes,
			                 Visible := Yes,
			                 ExternalAccess := None,
			                 DefaultData := 0);
			Output : DINT (Usage := Output,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Done : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := None,
			                DefaultData := 0);
			Error : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := None,
			                 DefaultData := 0);
			OpMode : DINT (Usage := Input,
			                  RADIX := Decimal,
			                  Required := Yes,
			                  Visible := Yes,
			                  DefaultData := 0);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			AOI_GetOdEntry : AOI_GetOdEntry (ExternalAccess := None,
			                         DefaultData := "[1,0,0,0,0,0,0]");
			AOI_SetOdEntry : AOI_SetOdEntry (ExternalAccess := None,
			                         DefaultData := "[1,0,0,0,0]");
			VAR32_OUT : DINT (RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			VAR32_IN : DINT (RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			DummyString : STRING (ExternalAccess := None,
			                      DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Operation mode = 1 reads out OD-entry 3202h";
				N: EQU(OpMode,1)AOI_GetOdEntry(AOI_GetOdEntry,GetOdEntry_MSG,MSG_Data_Input,MSG_Data_Output,16#0000_3202,0,Output,DummyString,Execute);
				RC: "Operation mode = 2 write into OD-entry 3202h";
				N: EQU(OpMode,2)AOI_SetOdEntry(AOI_SetOdEntry,SetOdEntry_MSG,MSG_Data_Input,16#0000_3202,0,4,Input,Execute);
				N: [XIC(AOI_SetOdEntry.Done) ,XIC(AOI_GetOdEntry.Done) ]OTL(Done);
				N: [XIC(AOI_SetOdEntry.Error) ,XIC(AOI_GetOdEntry.Error) ]OTL(Error);
				N: XIO(Execute)OTU(Done)OTU(Error);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_IO_Common (Description := "AOI to read/write the $QIO Common$Q Assemblies",
	                                             Revision := "1.1",
	                                             RevisionNote := "1.1: Added Digital Inputs and Digital Output",
	                                             Vendor := "Nanotec Electronic GmbH & Co. KG",
	                                             ExecutePrescan := No,
	                                             ExecutePostscan := No,
	                                             ExecuteEnableInFalse := No,
	                                             CreatedDate := "2015-02-12T14:14:47.083Z",
	                                             CreatedBy := "NANOTEC\entwickler_la",
	                                             EditedDate := "2023-10-03T21:50:53.538Z",
	                                             EditedBy := "DESKTOP-1FEFFUM\Rockwell24",
	                                             SoftwareRevision := "v32.03",
	                                             AdditionalHelpText := "Copies input data into the outgoing assembly and the incoming assembly data into the output. Because also $Qunsigned values$Q must be handled a easy CPS instruction for copy is not possible. ")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			IO_Data_In : SINT[32] (Usage := InOut,
			                      RADIX := Decimal,
			                      Required := Yes,
			                      Visible := Yes);
			IO_Data_Out : SINT[24] (Usage := InOut,
			                       RADIX := Decimal,
			                       Required := Yes,
			                       Visible := Yes);
			Controlword_6040h_0 : DINT (Usage := Input,
			                               RADIX := Hex,
			                               Required := Yes,
			                               Visible := Yes,
			                               DefaultData := 0);
			Statusword_6041h_0 : DINT (Usage := Output,
			                              RADIX := Hex,
			                              Required := Yes,
			                              Visible := Yes,
			                              ExternalAccess := Read/Write,
			                              DefaultData := 0);
			Modes_Of_Operation_6060h_0 : DINT (Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := Yes,
			                                      Visible := Yes,
			                                      DefaultData := 0);
			Modes_Of_Operation_Display_6061h_0 : DINT (Usage := Output,
			                                              RADIX := Decimal,
			                                              Required := Yes,
			                                              Visible := Yes,
			                                              ExternalAccess := Read/Write,
			                                              DefaultData := 0);
			Error_Register_1001h_0 : DINT (Usage := Output,
			                                  RADIX := Hex,
			                                  Required := Yes,
			                                  Visible := Yes,
			                                  ExternalAccess := Read/Write,
			                                  DefaultData := 0);
			Predefined_Error_Field_1003h_1 : DINT (Usage := Output,
			                                          RADIX := Hex,
			                                          Required := Yes,
			                                          Visible := Yes,
			                                          ExternalAccess := Read/Write,
			                                          DefaultData := 0);
			Target_Position_607Ah_0 : DINT (Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := Yes,
			                                   Visible := Yes,
			                                   DefaultData := 0);
			Position_Actual_Value_6064h_0 : DINT (Usage := Output,
			                                         RADIX := Decimal,
			                                         Required := Yes,
			                                         Visible := Yes,
			                                         ExternalAccess := Read/Write,
			                                         DefaultData := 0);
			VI_Target_Velocity_6042h_0 : DINT (Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := Yes,
			                                      Visible := Yes,
			                                      DefaultData := 0);
			Vl_Velocity_Demand_Value_6043h_0 : DINT (Usage := Output,
			                                            RADIX := Decimal,
			                                            Required := Yes,
			                                            Visible := Yes,
			                                            ExternalAccess := Read/Write,
			                                            DefaultData := 0);
			Vl_Velocity_Actual_Value_6044h_0 : DINT (Usage := Output,
			                                            RADIX := Decimal,
			                                            Required := Yes,
			                                            Visible := Yes,
			                                            ExternalAccess := Read/Write,
			                                            DefaultData := 0);
			Target_Velocity_60FFh_0 : DINT (Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := Yes,
			                                   Visible := Yes,
			                                   DefaultData := 0);
			Velocity_Demand_Value_606Bh_0 : DINT (Usage := Output,
			                                         RADIX := Decimal,
			                                         Required := Yes,
			                                         Visible := Yes,
			                                         ExternalAccess := Read/Write,
			                                         DefaultData := 0);
			Velocity_Actual_Value_606Ch_0 : DINT (Usage := Output,
			                                         RADIX := Decimal,
			                                         Required := Yes,
			                                         Visible := Yes,
			                                         ExternalAccess := Read/Write,
			                                         DefaultData := 0);
			Target_Torque_6071h_0 : DINT (Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := Yes,
			                                 Visible := Yes,
			                                 DefaultData := 0);
			Torque_Demand_6074h_0 : DINT (Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := Yes,
			                                 Visible := Yes,
			                                 ExternalAccess := Read/Write,
			                                 DefaultData := 0);
			Homing_Method_6098h_0 : DINT (Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := Yes,
			                                 Visible := Yes,
			                                 DefaultData := 0);
			Digital_Inputs_60FDh_0 : DINT (Usage := Output,
			                                  RADIX := Hex,
			                                  Required := Yes,
			                                  Visible := Yes,
			                                  ExternalAccess := Read Only,
			                                  DefaultData := 0);
			Digital_Outputs_60FEh_1 : DINT (Usage := Input,
			                                   RADIX := Hex,
			                                   Required := Yes,
			                                   Visible := Yes,
			                                   DefaultData := 0);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			VAR16_2 : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR16_1 : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR08_1 : SINT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR08_3 : SINT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR08_2 : SINT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR08_4 : SINT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR16_5 : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR16_4 : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR16_3 : INT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			VAR08_5 : SINT (RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Copies input data into the appropriate assembly and assembly data into the output variables. ";
				N: XIC(Execute)[CPS(IO_Data_In[0],VAR08_4,1) MOV(VAR08_4,Modes_Of_Operation_Display_6061h_0) ,BTD(IO_Data_In[2],0,Statusword_6041h_0,0,8) BTD(IO_Data_In[3],0,Statusword_6041h_0,8,8) ,CPS(IO_Data_In[4],Position_Actual_Value_6064h_0,1) ,CPS(IO_Data_In[8],VAR16_1,1) MOV(VAR16_1,Vl_Velocity_Demand_Value_6043h_0) ,CPS(IO_Data_In[10],VAR16_1,1) MOV(VAR16_1,Vl_Velocity_Actual_Value_6044h_0) ,CPS(IO_Data_In[12],Velocity_Demand_Value_606Bh_0,1) ,CPS(IO_Data_In[16],Velocity_Actual_Value_606Ch_0,1) ,CPS(IO_Data_In[20],VAR16_2,1) MOV(VAR16_2,Torque_Demand_6074h_0) ,CPS(IO_Data_In[22],VAR08_5,1) MOV(VAR08_5,Error_Register_1001h_0) ,CPS(IO_Data_In[24],Predefined_Error_Field_1003h_1,1) ,CPS(IO_Data_In[28],Digital_Inputs_60FDh_0,1) ,MOV(Modes_Of_Operation_6060h_0,VAR08_1) CPS(VAR08_1,IO_Data_Out[0],1) ,CPS(Controlword_6040h_0,IO_Data_Out[2],2) ,CPS(Target_Position_607Ah_0,IO_Data_Out[4],4) ,MOV(VI_Target_Velocity_6042h_0,VAR16_4) CPS(VAR16_4,IO_Data_Out[8],2) ,CPS(Target_Velocity_60FFh_0,IO_Data_Out[12],4) ,MOV(Target_Torque_6071h_0,VAR16_5) CPS(VAR16_5,IO_Data_Out[16],2) ,MOV(Homing_Method_6098h_0,VAR08_2) CPS(VAR08_2,IO_Data_Out[18],1) ,CPS(Digital_Outputs_60FEh_1,IO_Data_Out[20],4) ];
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_SetParamsProfileVelocityMode (Description := "Set a bunch of Profile Velocity Mode parameters",
	                                                                Revision := "1.0",
	                                                                Vendor := "Nanotec Electronic GmbH & Co. KG",
	                                                                ExecutePrescan := No,
	                                                                ExecutePostscan := No,
	                                                                ExecuteEnableInFalse := No,
	                                                                CreatedDate := "2015-03-17T15:18:48.915Z",
	                                                                CreatedBy := "NANOTEC\entwickler_la",
	                                                                EditedDate := "2015-11-10T09:16:12.864Z",
	                                                                EditedBy := "NANOTEC\schormann_m",
	                                                                SoftwareRevision := "v20.01",
	                                                                AdditionalHelpText := "With this AOI it is possible to set the most important parameters for the profile velocity mode at once. Parameters are stored in the UDT_ParamsProfileVelocityMode.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Parameter : UDT_ParamsProfileVelocityMode (Usage := InOut,
			                     Required := Yes,
			                     Visible := Yes);
			SetOdEntry_MSG : MESSAGE (Usage := InOut,
			                          Required := Yes,
			                          Visible := Yes);
			MSG_Data_Input : SINT[7] (Usage := InOut,
			                          RADIX := Decimal,
			                          Required := Yes,
			                          Visible := Yes);
			Done : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Error : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			VAR32_Subindex : DINT (RADIX := Hex,
			                         ExternalAccess := None,
			                         DefaultData := 0);
			VAR32_Index : DINT (RADIX := Hex,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			VAR32_Data : DINT (RADIX := Hex,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Execute_AOI_SetOdEntry : BOOL (RADIX := Decimal,
			                                 ExternalAccess := None,
			                                 DefaultData := 0);
			AOI_SetOdEntry : AOI_SetOdEntry (ExternalAccess := None,
			                         DefaultData := "[1,0,0,0,0]");
			VAR32_Statemachine : DINT (RADIX := Decimal,
			                             ExternalAccess := None,
			                             DefaultData := 0);
			VAR32_DataSize : DINT (RADIX := Decimal,
			                         ExternalAccess := None,
			                         DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Sends one parameter after another to the device.$N"
				    "Parameter are stored in an UDT as an DINT.$N"
				    "For every parameter the the index and subindex is deposited and used to write the data into the object.";
				N: AOI_SetOdEntry(AOI_SetOdEntry,SetOdEntry_MSG,MSG_Data_Input,VAR32_Index,VAR32_Subindex,VAR32_DataSize,VAR32_Data,Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,0)MOV(2,VAR32_DataSize)MOV(16#0000_606d,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od606Dh_00,VAR32_Data)MOV(1,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,1)XIC(AOI_SetOdEntry.Done)MOV(2,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,2)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(2,VAR32_DataSize)MOV(16#0000_606e,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od606Eh_00,VAR32_Data)MOV(3,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,3)XIC(AOI_SetOdEntry.Done)MOV(2,VAR32_Statemachine)MOV(4,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,4)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(1,VAR32_DataSize)MOV(16#0000_607e,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od607Eh_00,VAR32_Data)MOV(5,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,5)XIC(AOI_SetOdEntry.Done)MOV(3,VAR32_Statemachine)MOV(6,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,6)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6083,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od6083h_00,VAR32_Data)MOV(7,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,7)XIC(AOI_SetOdEntry.Done)MOV(4,VAR32_Statemachine)MOV(8,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,8)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6084,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od6084h_00,VAR32_Data)MOV(9,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,9)XIC(AOI_SetOdEntry.Done)MOV(5,VAR32_Statemachine)MOV(10,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,10)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6085,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od6085h_00,VAR32_Data)MOV(11,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,11)XIC(AOI_SetOdEntry.Done)MOV(6,VAR32_Statemachine)MOV(12,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,12)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(2,VAR32_DataSize)MOV(16#0000_6086,VAR32_Index)MOV(0,VAR32_Subindex)MOV(Parameter.Od6086h_00,VAR32_Data)MOV(13,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,13)XIC(AOI_SetOdEntry.Done)MOV(14,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,14)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_604a,VAR32_Index)MOV(1,VAR32_Subindex)MOV(Parameter.Od604Ah_01,VAR32_Data)MOV(15,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,15)XIC(AOI_SetOdEntry.Done)MOV(16,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,16)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(2,VAR32_DataSize)MOV(16#0000_604a,VAR32_Index)MOV(2,VAR32_Subindex)MOV(Parameter.Od604Ah_02,VAR32_Data)MOV(17,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,17)XIC(AOI_SetOdEntry.Done)OTU(Execute_AOI_SetOdEntry)OTL(Done);
				N: XIO(Execute)MOV(0,VAR32_Statemachine)MOV(0,VAR32_Index)MOV(0,VAR32_Subindex)OTU(Execute_AOI_SetOdEntry)OTU(Error)OTU(Done);
				N: XIC(AOI_SetOdEntry.Error)OTL(Error);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_SetParamsVelocityMode (Description := "Set a bunch of Velocity Mode parameters",
	                                                         Revision := "1.0",
	                                                         Vendor := "Nanotec Electronic GmbH & Co. KG",
	                                                         ExecutePrescan := No,
	                                                         ExecutePostscan := No,
	                                                         ExecuteEnableInFalse := No,
	                                                         CreatedDate := "2015-03-17T15:18:48.915Z",
	                                                         CreatedBy := "NANOTEC\entwickler_la",
	                                                         EditedDate := "2015-11-10T09:16:21.170Z",
	                                                         EditedBy := "NANOTEC\schormann_m",
	                                                         SoftwareRevision := "v20.01",
	                                                         AdditionalHelpText := "With this AOI it is possible to set the most important parameters for the velocity mode at once. Parameters are stored in the UDT_ParamsVelocityMode.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Parameter : UDT_ParamsVelocityMode (Usage := InOut,
			                     Required := Yes,
			                     Visible := Yes);
			SetOdEntry_MSG : MESSAGE (Usage := InOut,
			                          Required := Yes,
			                          Visible := Yes);
			MSG_Data_Input : SINT[7] (Usage := InOut,
			                          RADIX := Decimal,
			                          Required := Yes,
			                          Visible := Yes);
			Done : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Error : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
			Execute : BOOL (Usage := Input,
			                   RADIX := Decimal,
			                   Required := Yes,
			                   Visible := Yes,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			VAR32_Subindex : DINT (RADIX := Hex,
			                         ExternalAccess := None,
			                         DefaultData := 0);
			VAR32_Index : DINT (RADIX := Hex,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			VAR32_Data : DINT (RADIX := Hex,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Execute_AOI_SetOdEntry : BOOL (RADIX := Decimal,
			                                 ExternalAccess := None,
			                                 DefaultData := 0);
			AOI_SetOdEntry : AOI_SetOdEntry (ExternalAccess := None,
			                         DefaultData := "[1,0,0,0,0]");
			VAR32_Statemachine : DINT (RADIX := Decimal,
			                             ExternalAccess := None,
			                             DefaultData := 0);
			VAR32_DataSize : DINT (RADIX := Decimal,
			                         ExternalAccess := None,
			                         DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Sends one parameter after another to the device.$N"
				    "Parameter are stored in an UDT as an DINT.$N"
				    "For every parameter the the index and subindex is deposited and used to write the data into the object.";
				N: AOI_SetOdEntry(AOI_SetOdEntry,SetOdEntry_MSG,MSG_Data_Input,VAR32_Index,VAR32_Subindex,VAR32_DataSize,VAR32_Data,Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,0)MOV(4,VAR32_DataSize)MOV(16#0000_604c,VAR32_Index)MOV(1,VAR32_Subindex)MOV(Parameter.Od604Ch_01,VAR32_Data)MOV(1,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,1)XIC(AOI_SetOdEntry.Done)MOV(2,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,2)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_604c,VAR32_Index)MOV(2,VAR32_Subindex)MOV(Parameter.Od604Ch_02,VAR32_Data)MOV(3,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,3)XIC(AOI_SetOdEntry.Done)MOV(2,VAR32_Statemachine)MOV(4,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,4)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6048,VAR32_Index)MOV(1,VAR32_Subindex)MOV(Parameter.Od6048h_01,VAR32_Data)MOV(5,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,5)XIC(AOI_SetOdEntry.Done)MOV(3,VAR32_Statemachine)MOV(6,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,6)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(2,VAR32_DataSize)MOV(16#0000_6048,VAR32_Index)MOV(2,VAR32_Subindex)MOV(Parameter.Od6048h_02,VAR32_Data)MOV(7,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,7)XIC(AOI_SetOdEntry.Done)MOV(4,VAR32_Statemachine)MOV(8,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,8)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6049,VAR32_Index)MOV(1,VAR32_Subindex)MOV(Parameter.Od6049h_01,VAR32_Data)MOV(9,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,9)XIC(AOI_SetOdEntry.Done)MOV(5,VAR32_Statemachine)MOV(10,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,10)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(2,VAR32_DataSize)MOV(16#0000_6049,VAR32_Index)MOV(2,VAR32_Subindex)MOV(Parameter.Od6049h_02,VAR32_Data)MOV(11,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,11)XIC(AOI_SetOdEntry.Done)MOV(6,VAR32_Statemachine)MOV(12,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,12)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6046,VAR32_Index)MOV(1,VAR32_Subindex)MOV(Parameter.Od6046h_01,VAR32_Data)MOV(13,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,13)XIC(AOI_SetOdEntry.Done)MOV(14,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,14)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_6046,VAR32_Index)MOV(2,VAR32_Subindex)MOV(Parameter.Od6046h_02,VAR32_Data)MOV(15,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,15)XIC(AOI_SetOdEntry.Done)MOV(16,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,16)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(4,VAR32_DataSize)MOV(16#0000_604a,VAR32_Index)MOV(1,VAR32_Subindex)MOV(Parameter.Od604Ah_01,VAR32_Data)MOV(17,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,17)XIC(AOI_SetOdEntry.Done)MOV(9,VAR32_Statemachine)OTU(Execute_AOI_SetOdEntry);
				N: XIC(Execute)EQU(VAR32_Statemachine,9)XIO(Execute_AOI_SetOdEntry)XIO(AOI_SetOdEntry.Done)MOV(2,VAR32_DataSize)MOV(16#0000_604a,VAR32_Index)MOV(2,VAR32_Subindex)MOV(Parameter.Od604Ah_02,VAR32_Data)MOV(18,VAR32_Statemachine)OTL(Execute_AOI_SetOdEntry);
				N: EQU(VAR32_Statemachine,18)XIC(AOI_SetOdEntry.Done)OTU(Execute_AOI_SetOdEntry)OTL(Done);
				N: XIO(Execute)MOV(0,VAR32_Statemachine)MOV(0,VAR32_Index)MOV(0,VAR32_Subindex)OTU(Execute_AOI_SetOdEntry)OTU(Error)OTU(Done);
				N: XIC(AOI_SetOdEntry.Error)OTL(Error);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION AOI_Statusword_6041h (Description := "Takes the status WORD and breaks it into BITS that are easily used in the program.",
	                                                    Revision := "1.0",
	                                                    ExecutePrescan := No,
	                                                    ExecutePostscan := No,
	                                                    ExecuteEnableInFalse := No,
	                                                    CreatedDate := "2015-02-06T16:56:34.508Z",
	                                                    CreatedBy := "NANOTEC\entwickler_la",
	                                                    EditedDate := "2015-11-10T09:17:58.202Z",
	                                                    EditedBy := "NANOTEC\schormann_m",
	                                                    SoftwareRevision := "v20.01",
	                                                    AdditionalHelpText := "The object dictionary entry 6041h queries whether the state commanded with object 6040h (control word) has been reached. The AOI break down the bits into single flags.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Statusword_6041h : DINT (Usage := InOut,
			                            RADIX := Decimal,
			                            Required := Yes,
			                            Visible := Yes);
			Ready_To_Switched_On : BOOL (Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := Yes,
			                                ExternalAccess := Read Only,
			                                DefaultData := 0);
			Switched_On : BOOL (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Operational_Enabled : BOOL (Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := Yes,
			                               ExternalAccess := Read Only,
			                               DefaultData := 0);
			FAULT : BOOL (Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			Voltage_Enabled : BOOL (Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Quick_Stop : BOOL (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Switched_On_Disabled : BOOL (Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := Yes,
			                                ExternalAccess := Read Only,
			                                DefaultData := 0);
			Warning : BOOL (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Synchronisation : BOOL (Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Remote : BOOL (Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Target_Reached : BOOL (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Internal_Limit_Reached : BOOL (Usage := Output,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := Yes,
			                                  ExternalAccess := Read Only,
			                                  DefaultData := 0);
			Operation_Mode_Specific1 : BOOL (Usage := Output,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := Yes,
			                                    ExternalAccess := Read Only,
			                                    DefaultData := 0);
			Operation_Mode_Specific2 : BOOL (Usage := Output,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := Yes,
			                                    ExternalAccess := Read Only,
			                                    DefaultData := 0);
			Closed_Loop_Available : BOOL (Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := Yes,
			                                 ExternalAccess := Read Only,
			                                 DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "Expand every bit of the status word 6041h and signal it as an output.";
				N: XIC(Statusword_6041h.0)OTE(Ready_To_Switched_On);
				N: XIC(Statusword_6041h.1)OTE(Switched_On);
				N: XIC(Statusword_6041h.2)OTE(Operational_Enabled);
				N: XIC(Statusword_6041h.3)OTE(FAULT);
				N: XIC(Statusword_6041h.4)OTE(Voltage_Enabled);
				N: XIC(Statusword_6041h.5)OTE(Quick_Stop);
				N: XIC(Statusword_6041h.6)OTE(Switched_On_Disabled);
				N: XIC(Statusword_6041h.7)OTE(Warning);
				N: XIC(Statusword_6041h.8)OTE(Synchronisation);
				N: XIC(Statusword_6041h.9)OTE(Remote);
				N: XIC(Statusword_6041h.10)OTE(Target_Reached);
				N: XIC(Statusword_6041h.11)OTE(Internal_Limit_Reached);
				N: XIC(Statusword_6041h.12)OTE(Operation_Mode_Specific1);
				N: XIC(Statusword_6041h.13)OTE(Operation_Mode_Specific2);
				N: XIC(Statusword_6041h.15)OTE(Closed_Loop_Available);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION PBS_error (Revision := "1.0",
	                                         ExecutePrescan := No,
	                                         ExecutePostscan := No,
	                                         ExecuteEnableInFalse := No,
	                                         CreatedDate := "2023-07-26T14:58:54.593Z",
	                                         CreatedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                         EditedDate := "2023-07-26T15:11:18.555Z",
	                                         EditedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                         SoftwareRevision := "v32.03")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			errorInteger : INT (Usage := Input,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes,
			                        DefaultData := 0);
			OK : BOOL (Usage := Output,
			              RADIX := Decimal,
			              Required := No,
			              Visible := Yes,
			              ExternalAccess := Read Only,
			              DefaultData := 0);
			Failure : BOOL (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			HiHi : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Hi : BOOL (Usage := Output,
			              RADIX := Decimal,
			              Required := No,
			              Visible := Yes,
			              ExternalAccess := Read Only,
			              DefaultData := 0);
			Lo : BOOL (Usage := Output,
			              RADIX := Decimal,
			              Required := No,
			              Visible := Yes,
			              ExternalAccess := Read Only,
			              DefaultData := 0);
			LoLo : BOOL (Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := Yes,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
		END_LOCAL_TAGS

		ROUTINE Logic 
				N: EQU(errorInteger,0)OTE(OK);
				N: EQU(errorInteger,40)OTE(Lo);
				N: EQU(errorInteger,50)OTE(Hi);
				N: EQU(errorInteger,90)OTE(LoLo);
				N: EQU(errorInteger,100)OTE(HiHi);
				N: EQU(errorInteger,200)OTE(Failure);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION Pump_Cal (Description := "Pump Calibration Module",
	                                        Revision := "1.3",
	                                        RevisionNote := "1.0 Published$N1.1 Using the P_VSD block$N1.2 Included Pump Cal into the AOI$N1,3 Modified to include native PlantPax VSD Block",
	                                        Vendor := "JES Inc.",
	                                        ExecutePrescan := No,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := No,
	                                        CreatedDate := "2021-05-12T06:19:08.959Z",
	                                        CreatedBy := "DESKTOP-C3HAB1M\Win10 x64",
	                                        EditedDate := "2023-05-31T22:30:04.074Z",
	                                        EditedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                        SoftwareRevision := "v32.03")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Cal_CollectionType : BOOL (Description := "0 = Mass, 1 = Volume",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 0);
			Cal_CollectedQuantity : REAL (Description := "Operator Input Collected Mass or Volume obtained",
			                                 Usage := Input,
			                                 RADIX := Float,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 0.00000000e+000);
			Cal_Density : REAL (Description := "Operator Input Density (g/ml)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cal_Duration : REAL (Description := "Operator Input pump run duration (min)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Cal_PumpSpeed : REAL (Description := "Set Pump Speed in %",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			Cal_CmdStart : BOOL (Description := "Start Cal Sequence",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cal_CmdStop : BOOL (Description := "Stop/Abort Cal Sequence",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Cal_Aborted : BOOL (Description := "Calibration Sequence is Aborted",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Cal_Complete : BOOL (Description := "Calibration Sequence is Complete",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Cal_Running : BOOL (Description := "Calibration Sequence is Active",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Cal_EUMax : REAL (Description := "Calculated max EU (mL/min)",
			                     Usage := Output,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0.00000000e+000);
			Cal_Phase2Active : BOOL (Description := "Cal Pump run complete, now calculating Pump EU Max",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Cal_CmdPhase2Accept : BOOL (Description := "Accept button pressed by Operator after inputing collected volume or mass",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 0);
			Cal_Started : BOOL (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Cal_Runtime : REAL (Description := "Accumulation time converted to minutes$N-For HMI-",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0.00000000e+000);
			Drive_Sts_RunningFwd : BOOL (Usage := InOut,
			                                RADIX := Decimal,
			                                Required := Yes,
			                                Visible := Yes);
			Drive_PCmd_Prog : BOOL (Usage := InOut,
			                           RADIX := Decimal,
			                           Required := Yes,
			                           Visible := Yes);
			Drive_Cfg_SpeedRefEUMin : REAL (Usage := InOut,
			                                   RADIX := Float,
			                                   Required := Yes,
			                                   Visible := Yes);
			Drive_Cfg_SpeedRefEUMax : REAL (Usage := InOut,
			                                   RADIX := Float,
			                                   Required := Yes,
			                                   Visible := Yes);
			Drive_Cfg_SpeedFdbkEUMin : REAL (Usage := InOut,
			                                    RADIX := Float,
			                                    Required := Yes,
			                                    Visible := Yes);
			Drive_Cfg_SpeedFdbkEUMax : REAL (Usage := InOut,
			                                    RADIX := Float,
			                                    Required := Yes,
			                                    Visible := Yes);
			Drive_Cfg_MinSpdRef : REAL (Usage := InOut,
			                               RADIX := Float,
			                               Required := Yes,
			                               Visible := Yes);
			Drive_Cfg_MaxSpdRef : REAL (Usage := InOut,
			                               RADIX := Float,
			                               Required := Yes,
			                               Visible := Yes);
			Drive_PSet_SpeedRef : REAL (Usage := InOut,
			                               RADIX := Float,
			                               Required := Yes,
			                               Visible := Yes);
			Drive_PCmd_StartFwd : BOOL (Usage := InOut,
			                               RADIX := Decimal,
			                               Required := Yes,
			                               Visible := Yes);
			Drive_Sts_Prog : BOOL (Usage := InOut,
			                          RADIX := Decimal,
			                          Required := Yes,
			                          Visible := Yes);
			Drive_PCmd_Stop : BOOL (Usage := InOut,
			                           RADIX := Decimal,
			                           Required := Yes,
			                           Visible := Yes);
		END_PARAMETERS

		LOCAL_TAGS
			ONS : DINT (RADIX := Decimal,
			              ExternalAccess := None,
			              DefaultData := 0);
			Cal_RunTimer2 : TIMER (Description := "Run Timer used to calculate how long the pump is running",
			                        ExternalAccess := None,
			                        DefaultData := "[0,0,0]");
			Cal_RunTimer : TIMER (ExternalAccess := None,
			                       DefaultData := "[0,0,0]");
			Cal_CalculatedVol : REAL (Description := "Internal calculated volume if the operator selected volume",
			                            RADIX := Float,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0.00000000e+000);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "============================================================$N"
				    "Pump Calibration Control Module$N"
				    "============================================================";
				N: NOP();
				RC: "Pump Calibration Logic$N"
				    "$N"
				    "When the Operator presses start on the HMI, convert the pump cal duration input by operator to ms for the timer and start the pump.$N"
				    "Once hte pump finished running, the operator will inpu the volume or mass collected and the Pump EU max is calculated.$N"
				    "Set the pump EUMax to the calibrated EUMax after a calibration is completed";
				N: XIC(Cal_CmdStart)RES(Cal_RunTimer)RES(Cal_RunTimer2)CPT(Cal_RunTimer.PRE,Cal_Duration * 60000)CPT(Cal_RunTimer2.PRE,Cal_Duration * 60000 * 2)OTL(Drive_PCmd_Prog)OTU(Cal_CmdStop)OTU(Cal_Complete)OTU(Cal_Aborted)OTL(Cal_Started);
				N: XIC(Cal_Started)XIO(Cal_RunTimer.DN)[MOV(0,Drive_Cfg_SpeedRefEUMin) MOV(0,Drive_Cfg_SpeedFdbkEUMin) MOV(0,Drive_Cfg_MinSpdRef) ,MOV(100,Drive_Cfg_SpeedRefEUMax) MOV(100,Drive_Cfg_SpeedFdbkEUMax) MOV(100,Drive_Cfg_MaxSpdRef) ][MOV(Cal_PumpSpeed,Drive_PSet_SpeedRef) OTL(Drive_PCmd_StartFwd) ,RTO(Cal_RunTimer,?,?) ];
				N: XIC(Cal_Started)XIC(Drive_Sts_Prog)XIC(Drive_Sts_RunningFwd)OTL(Cal_Running);
				N: XIC(Cal_Running)XIC(Cal_RunTimer.DN)OTL(Drive_PCmd_Stop)MOV(0,Drive_PSet_SpeedRef)OTL(Cal_Phase2Active)OTU(Cal_Started);
				N: [XIC(Cal_Started) ,XIC(Cal_Running) ]XIC(Drive_Sts_RunningFwd)RTO(Cal_RunTimer2,?,?);
				N: XIC(Cal_Phase2Active)XIC(Cal_CmdPhase2Accept)[XIC(Cal_CollectionType) [GRT(Cal_Density,0) DIV(Cal_CollectedQuantity,Cal_Density,Cal_CalculatedVol) ,LEQ(Cal_Density,0) MOV(Cal_CollectedQuantity,Cal_CalculatedVol) ] ,XIO(Cal_CollectionType) MOV(Cal_CollectedQuantity,Cal_CalculatedVol) ]CPT(Cal_EUMax,(Cal_CalculatedVol / Cal_Runtime) * (100 / Cal_PumpSpeed))OTU(Cal_Running)OTL(Cal_Complete);
				N: XIC(Cal_Complete)ONS(ONS.2)MOV(Cal_EUMax,Drive_Cfg_SpeedRefEUMax)MOV(Cal_EUMax,Drive_Cfg_SpeedFdbkEUMax)MOV(Cal_EUMax,Drive_Cfg_MaxSpdRef)OTU(Cal_Phase2Active)RES(Cal_RunTimer)RES(Cal_RunTimer2);
				N: XIC(Cal_CmdStop)ONS(ONS.0)MOV(0,Drive_PSet_SpeedRef)OTL(Drive_PCmd_Stop)OTU(Cal_Started)OTU(Cal_Running)OTU(Cal_Phase2Active)OTU(Cal_Complete)OTU(Cal_CmdStop)RES(Cal_RunTimer)RES(Cal_RunTimer2)OTL(Cal_Aborted);
				N: CPT(Cal_Runtime,Cal_RunTimer.ACC / 60000);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_Alarm (Description := "Alarm",
	                                       Revision := "4.10",
	                                       RevisionExtension := ".00 Release",
	                                       RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                       Vendor := "Rockwell Automation",
	                                       ExecutePrescan := Yes,
	                                       ExecutePostscan := No,
	                                       ExecuteEnableInFalse := Yes,
	                                       CreatedDate := "2008-02-29T20:40:04.200Z",
	                                       CreatedBy := "Not Available",
	                                       EditedDate := "2020-12-08T03:29:55.213Z",
	                                       EditedBy := "KEVIN_VM-PC\kevin_VM",
	                                       SoftwareRevision := "v32.02",
	                                       AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis instruction monitors one input condition and provides one Alarm with:$N  * configurable latching (reset required) and acknowledgement requirement$N  * configurable alarm severity$N      1 to 250       = Low  (blue, typ. informational)$N      251 to 500   = Medium  (yelllow, typ. warning)$N      501 to 750   = High  (red, typ. process exception)$N      751 to 1000 = Urgent  (magenta, typ. equip. fault)$N  * configurable minimum ON time (e.g., to ensure it is seen by the HMI)$N  * commands to suppress/unsuppress (Prog), shelve/unshelve (Oper)$N        and disable/enable (Maint) the alarm.$N  * configurable amount of time shelved to automatically unshelve an alarm$N  * FTA&E support for suppressed, shelved and disabled states (V7.0)$N  * a Maintenance $QTest$Q command, which triggers the alarm for the minimum$N     alarm time for testing purposes.$N$NNOTE regarding parameter naming:$N  FTAE names (same as ALMD instruction) are used instead$N  of the ANSI/ISA 18.2-2009 names, as follows:$N   $QDisabled$Q is the equivalent of $QOut of Service$Q in ISA 18.2.$N      (The Disabled state is owned by Maintenance.)$N   $QSuppressed$Q is the equivalent of $QSuppressed by Design$Q in$N      ISA 18.2. (The Suppressed state is owned by Program logic.)$N   $QShelved$Q is the same as in ISA 18.2.$N      (The Shelved state is owned by Operator, but may be cleared$N      by Program logic based on time, shift change, etc.)$N$NThis instruction is usually nested within other instructions, with one instance$Nused for each Alarm generated by the containing instruction.  It may also be$Nused as a standalone instruction for Alarm conditions generated by custom logic.$N$NFTAE Alarm Setup:$N  (object).(alarm).Com_AE.0:  Alarm to FTAE$N    .Com_AE.1:   Ack to/from FTAE$N    .Com_AE.3:   Shelved from FTAE Status$N    .Com_AE.4:   Shelve/Reshelve to FTAE Control (auto reset)$N    .Com_AE.5:   Unshelve to FTAE Control (auto reset)$N    .Com_AE.6:   Suppressed from FTAE Status$N    .Com_AE.7:   Suppress to FTAE Control (auto reset)$N    .Com_AE.8:   Unsuppress to FTAE Control (auto reset)$N    .Com_AE.9:   Disabled from FTAE Status$N    .Com_AE.10: Disable to FTAE Control (auto reset)$N    .Com_AE.11: Enable to FTAE Control (auto reset)$N   all other bits unused$N    .Cfg_MaxShelfT is also used in FTAE config.$N    .Cfg_Severity is used in FTAE for FTView 8.x and later.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Unmodified, up-rev only for Library 4.10.00$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-07 Patch01)$NSee 4.00 Release Notes for details.$N* Changed Inf_Lib and Inf_Type to HMI_Lib and HMI_Type.$N* Deleted Cfg_PCmdClear.  All Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by containing objects.$N* Modified to remove Suppressed from the conditions which show the$N    $QInhibited$Q breadcrumb.$N* Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp : BOOL (Description := "Alarm Condition Input 1=Alarm",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 1);
			Inp_OoS OF Com_AE.2 (Description := "1=Out of Service (from object$'s P_CmdSrc)",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No);
			Inp_Reset : BOOL (Description := "1=Reset Alarm requiring reset",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Cfg_Exists : BOOL (Description := "1=Alarm configured to exist, 0=Does not exist, don$'t scan",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1);
			Cfg_ResetReqd : BOOL (Description := "1=Latched Alarm, a Reset is required to clear this Alarm",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_AckReqd : BOOL (Description := "1=Acknowledge required for this Alarm",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1);
			Cfg_AllowShelve : BOOL (Description := "1=Allow Operator to Shelve this Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 1);
			Cfg_AllowDisable : BOOL (Description := "1=Allow Maintenance to Disable this Alarm",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 1);
			Cfg_Severity : DINT (Description := "Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 750);
			Cfg_MaxShelfT : DINT (Description := "Auto unshelve after shelved this long (1..32767 minutes)",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 480);
			Cfg_AlmMinOnT : DINT (Description := "Minimum time Alm output stays on (sec)",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 5);
			PCfg_AllowExist : BOOL (Description := "1=Alarm can be configured to exist, 0=other configs make alarm meaningless",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 1);
			PCmd_Reset : BOOL (Description := "Program Command to Reset latched alarm",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_Ack : BOOL (Description := "Program Command to Acknowledge alarm",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			PCmd_Suppress : BOOL (Description := "Program Command to Suppress by Design (inhibits new alarm)",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			PCmd_Unsuppress : BOOL (Description := "Program Command to Unsuppress (allows new alarm)",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			PCmd_Unshelve : BOOL (Description := "Program Command to Unshelve (e.g., on shift change)",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Val_Notify : DINT (Description := "Current Alarm Severity and Acknowledgement (enumeration)",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Val_SecToUnshelve : DINT (Description := "Number of Seconds until this alarm unshelves itself (mmm:ss)",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := Yes,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0);
			Val_MinToUnshelve : DINT (Description := "Number of minutes until this alarm unshelves itself (mmm:ss)",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := Yes,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0);
			Alm OF Com_AE.0 (Description := "Alarm output 1=In Alarm",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read/Write);
			Ack OF Com_AE.1 (Description := "Alarm acknowledged status: 1=Ack rcvd",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read/Write);
			Shelved OF Com_AE.3 (Description := "1=Alarm has been Shelved by Operator (inhibits new alarm)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read/Write);
			Suppressed OF Com_AE.6 (Description := "1=Alarm has been Suppressed by Program (inhibits new alarm)",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read/Write);
			Disabled OF Com_AE.9 (Description := "1=Alarm has been Disabled by Maintanance (inhibits new alarm)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read/Write);
			Sts_AlmInh : BOOL (Description := "1=Alarm has been suppressed, shelved or disabled, display $QI$Q icon",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck OF ORdy_Ack (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail Err_ bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Severity : BOOL (Description := "1=Error in Config: Invalid Severity (use 1 to 4)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			P_Alarm : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_Alm : BOOL (Description := "Internal Alarm Status",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Suppressed : BOOL (Description := "Internal Alarm Suppressed Status",
			                         RADIX := Decimal,
			                         ExternalAccess := None,
			                         DefaultData := 0);
			Wrk_AlmMinOnT : TIMER (Description := "Alarm output minimum ON time to be seen by alarm server",
			                        ExternalAccess := None,
			                        DefaultData := "[0,5000,0]");
			Wrk_AutoAckT : TIMER (Description := "Time to clear Ack bit when Ack not required",
			                       ExternalAccess := None,
			                       DefaultData := "[0,5000,0]");
			Wrk_ShelfT : TIMER (Description := "Time to auto Unshelve a Shelved Alarm",
			                     ExternalAccess := Read Only,
			                     DefaultData := "[0,0,0]");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Com_AE : INT (Description := "Communication with HMI / Alarm/Event Server (see bit descriptions)",
			                 COMMENT.0 := "Alarm to AE",
			                 COMMENT.1 := "Acked from AE Status, Ack to AE Control",
			                 COMMENT.2 := "Out of Service (from parent object$'s P_CmdSrc)",
			                 COMMENT.3 := "Shelved from AE Status",
			                 COMMENT.4 := "Shelve to AE Control",
			                 COMMENT.5 := "Unshelve to AE Control",
			                 COMMENT.6 := "Suppressed from AE Status",
			                 COMMENT.7 := "Suppress to AE Control",
			                 COMMENT.8 := "Unsuppress to AE Control",
			                 COMMENT.9 := "Disabled from AE Status",
			                 COMMENT.10 := "Disable to AE Control",
			                 COMMENT.11 := "Enable to AE Control",
			                 COMMENT.12 := "(not used)",
			                 COMMENT.13 := "(not used)",
			                 COMMENT.14 := "(not used)",
			                 COMMENT.15 := "(not used)",
			                 RADIX := Binary,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 2);
			Cfg_Tag : STRING_20 (Description := "Alarm Tag Text (e.g., $QLAHH-101$Q)",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Cond : STRING_20 (Description := "Alarm Condition Text (e.g., $QHigh-High PV$Q)",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[15,'Alarm Condition$00$00$00$00$00']");
			Wrk_SecToUnshelve : DINT (Description := "Number of seconds until this alarm unshelves itself",
			                            RADIX := Decimal,
			                            ExternalAccess := None,
			                            DefaultData := 0);
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			HMI_Type : STRING_16 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[7,'P_Alarm$00$00$00$00$00$00$00$00$00']");
			ORdy_Unshelve : BOOL (Description := "1=Ready for OCmd_Unshelve (enables HMI button)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			ORdy_Shelve : BOOL (Description := "1=Ready for OCmd_Shelve (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			MRdy_Test : BOOL (Description := "1=Ready for MCmd_Test (enables HMI button)",
			                    RADIX := Decimal,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			MRdy_Enable : BOOL (Description := "1=Ready for MCmd_Enable (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			MRdy_Disable : BOOL (Description := "1=Ready for MCmd_Disable (enables HMI button)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			OCmd_Unshelve : BOOL (Description := "Operator Command to Unshelve alarm (allows new alarm)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read/Write,
			                        DefaultData := 0);
			OCmd_Shelve : BOOL (Description := "Operator Command to Shelve Alarm (inhibits new alarm)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			OCmd_Ack : BOOL (Description := "Operator Command to Acknowledge alarm",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Operator Command to Reset latched alarm",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Test : BOOL (Description := "Maintenance Command to Test alarm (issued for minimum alarm time)",
			                    RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
			MCmd_Enable : BOOL (Description := "Maintenance Command to Enable alarm (allows new alarm)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			MCmd_Disable : BOOL (Description := "Maintenance Command to Disable alarm (inhibits new alarm)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read/Write,
			                       DefaultData := 0);
			ORdy_Ack : BOOL (Description := "1=Ready for OCmd_Ack (enables HMI button)",
			                   RADIX := Decimal,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Perform Alarm processing, but Invert Alarm Input ($QInp$Q) for use on LD rung (EnableIn False)")
				RC: "============================================================$N"
				    "P_Alarm: EnableInFalse (False Rung) Handling$N"
				    "============================================================$N"
				    "When EnableIn is FALSE (False Rung), the Input$N"
				    "($QInp$Q) is inverted.  This allows the P_Alarm instruction$N"
				    "to be used on a simple Ladder Diagram rung:$N"
				    "$N"
				    "XIC  (condition)   P_Alarm (Alarm)$N"
				    "$N"
				    "All processing is identical to the normal Logic$N"
				    "routine, except references to Inp are inverted!$N"
				    "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "In the object containing this alarm, other configuration (such as not having$N"
				    "any limit switches) may make this particular alarm meaningless.$N"
				    "The Program Configuration $QAllow Exist$Q is used to hide this alarm$N"
				    "on the object$'s faceplate and other graphics, and forces the Cfg_Exist to 0.";
				N: XIO(PCfg_AllowExist)OTU(Cfg_Exists);
				RC: "$N"
				    "This rung gets the Alarm Minimum ON Time Configuration$N"
				    "and the Auto Unshelve Time Configuration$N"
				    "values and sets the corresponding timer presets.$N"
				    "If the Minimum ON Time Configuration results in a timer preset$N"
				    "less than 5 seconds, the preset is set to 5 seconds.$N"
				    "If the Auto Unshelve Time Configuration results in a negative$N"
				    "timer preset, the preset is set to 28800 seconds (8 hours).$N"
				    "Either bad Config is flagged (Err_Timer).$N"
				    "Bad Config is also flagged if the Cfg_Severity is out of range (valid = 1..1000) (Err_Severity).";
				N: XIC(Cfg_Exists)[[MUL(Cfg_AlmMinOnT,1000,Wrk_AlmMinOnT.PRE) LES(Wrk_AlmMinOnT.PRE,5000) MOV(5,Cfg_AlmMinOnT) MOV(5000,Wrk_AlmMinOnT.PRE) ,MUL(Cfg_MaxShelfT,60000,Wrk_ShelfT.PRE) XIC(Wrk_ShelfT.PRE.31) MOV(480,Cfg_MaxShelfT) MOV(28800000,Wrk_ShelfT.PRE) ] OTE(Err_Timer) ,LIM(1001,Cfg_Severity,0) MOV(1000,Cfg_Severity) OTE(Err_Severity) ]OTE(Sts_Err);
				RC: "The Auto Ack time is ALWAYS five seconds.";
				N: MOV(5000,Wrk_AutoAckT.PRE);
				RC: "When the Alarm initially occurs, the Auto Ack timer is started.$N"
				    "If this Alarm is set for $QAck Not Required$Q, it is automatically $N"
				    "Acknowledged after the AutoAck time expires.$N"
				    "$N"
				    "This pulsing of the Ack bit OFF then ON allows the $QAck Not Required$Q$N"
				    "configuration to be used with View 32, View ME and other legacy$N"
				    "alarm systems that don$'t support optional ack.";
				N: XIO(Ack)TON(Wrk_AutoAckT,?,?);
				RC: "If this alarm does not exist, set it to its default state (no alarm, acknowleded,$N"
				    "uninhibited, unsuppressed, enabled) and clear any received commands.$N"
				    "Then jump over the remainder of the Logic and return.";
				N: XIO(Cfg_Exists)[XIC(Wrk_AutoAckT.DN) OTL(Ack) ,OTU(Wrk_Alm) OTU(Shelved) OTU(Wrk_Suppressed) OTU(Disabled) OTU(Sts_AlmInh) ,OTU(PCmd_Reset) OTU(PCmd_Ack) OTU(PCmd_Unshelve) OTU(PCmd_Suppress) OTU(PCmd_Unsuppress) ,OTU(OCmd_Reset) OTU(OCmd_Ack) OTU(OCmd_Shelve) OTU(OCmd_Unshelve) ,OTU(MCmd_Disable) OTU(MCmd_Enable) RES(Wrk_AlmMinOnT) RES(Wrk_ShelfT) ]JMP(End);
				RC: "============================================================$N"
				    "COMMAND PROCESSING$N"
				    "============================================================$N"
				    "These rungs handle received Commands:$N"
				    "Operator Commands (OCmd_xx) and Maintenance Commands$N"
				    "(MCmd_xx) from the HMI and$N"
				    "Program Command (PCmd_xx) from other objects.$N"
				    "$N"
				    "NOTE:  ALARM COMMANDS ARE ACCEPTED REGARDLESS OF MODE.$N"
				    "$N"
				    "This rung receives the Program Alarm Inhibit Command.$N"
				    "If configured for EDGE, the Command is cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: XIC(PCmd_Suppress)OTU(PCmd_Suppress)OTL(Wrk_Suppressed)OTL(Com_AE.7)OTU(Com_AE.8);
				RC: "This rung receives the Program Alarm Unsuppress Command (Unsuppress wins over Suppress).$N"
				    "If configured for LEVEL, Suppressed is cleared if PCmd_Suppress is cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: XIC(PCmd_Unsuppress)OTU(PCmd_Unsuppress)OTU(Wrk_Suppressed)OTU(Com_AE.7)OTL(Com_AE.8);
				RC: "This rung receives the Operator Shelve Command.$N"
				    "If the command is received while shelved, the shelf timer starts over (reset).";
				N: XIC(OCmd_Shelve)OTU(OCmd_Shelve)XIC(Cfg_AllowShelve)OTL(Shelved)OTL(Com_AE.4)OTU(Com_AE.5)RES(Wrk_ShelfT);
				RC: "This rung times how long the alarm has been shelved.$N"
				    "If the Shelf Timer expires (and its preset > 0), automatically unshelve the alarm.";
				N: XIC(Shelved)TON(Wrk_ShelfT,?,?);
				RC: "This rung receives the Operator Unshelve Command (Unshelve wins over Shelve)$N"
				    "and the Program Unshelve Command$N"
				    "Also Unshelve the alarm if the Shelf Timer expires (if preset > 0).$N"
				    "$N"
				    "NOTE: Shelved can also be set/cleared directly by the HMI (FTA&E support).";
				N: [XIC(OCmd_Unshelve) OTU(OCmd_Unshelve) ,XIC(PCmd_Unshelve) OTU(PCmd_Unshelve) ,XIC(Wrk_ShelfT.DN) NEQ(Wrk_ShelfT.PRE,0) ,XIO(Cfg_AllowShelve) ]OTU(Shelved)OTU(Com_AE.4)OTL(Com_AE.5);
				RC: "This rung receives the Maintenance Alarm Disable Command.";
				N: XIC(MCmd_Disable)OTU(MCmd_Disable)XIC(Cfg_AllowDisable)OTL(Disabled)OTL(Com_AE.10)OTU(Com_AE.11);
				RC: "This rung receives the Maintenance Alarm Enable Command (Enable wins over Disable)$N"
				    "$N"
				    "NOTE: Disabled can also be set/cleared directly by the HMI (FTA&E support).";
				N: [XIC(MCmd_Enable) ,XIO(Cfg_AllowDisable) ]OTU(MCmd_Enable)OTU(Disabled)OTU(Com_AE.10)OTL(Com_AE.11);
				RC: "If the Alarm is Disabled (Maint), or Shelved (Oper),$N"
				    "then post the $Qalarm inhibited$Q breadcrumb and do not$N"
				    "allow a new alarm to be issued.$N"
				    "$N"
				    "NOTE:  If the Alarm is Suppressed (Prog), this is assumed to be $QSuppressed by Design$Q$N"
				    "(ANSI/ISA-18.2-2016) and NOT shown to the operator with an $Qinhibited$Q$N"
				    "breadcrumb!  He just never sees the point as being In Alarm!$N"
				    "$N"
				    "@@@@@  Unlatch and Latch are used to avoid a verification  @@@@@$N"
				    "@@@@@  warning in combination with Rung 2$'s OTU (above)!  @@@@@$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####";
				N: OTU(Sts_AlmInh)[XIC(Disabled) ,XIC(Shelved) ]OTL(Sts_AlmInh);
				RC: "This rung receives the Alarm Acknowledge Commands$N"
				    "$N"
				    "NOTE: Acknowledge can also be set/cleared directly by the HMI.";
				N: [XIC(PCmd_Ack) OTU(PCmd_Ack) ,XIC(OCmd_Ack) OTU(OCmd_Ack) ,XIO(Wrk_AutoAckT.TT) XIO(Cfg_AckReqd) ]OTL(Ack);
				RC: "This rung receives the Alarm Reset Commands.$N"
				    "$N"
				    "If the Alarm Reset Command is received and, either, the Input condition has returned$N"
				    "to normal, or the alarm is out of service, disabled, suppressed or shelved,$N"
				    "the Alarm is CLEARED and ACKNOWLEDGED (to match ALMD behavior!!!).$N"
				    "$N"
				    "@@@@@  $QInp$Q is Inverted in the EnableInFalse Routine!  @@@@@$N"
				    "$N"
				    "#####  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: XIO(Wrk_AutoAckT.TT)[XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ][XIC(Inp) ,XIC(Sts_AlmInh) ,XIC(Wrk_Suppressed) ,XIC(Inp_OoS) ]OTL(Ack)OTU(Wrk_Alm);
				RC: "============================================================$N"
				    "ALARM GENERATION$N"
				    "============================================================$N"
				    "This rung CLEARS the Alarm when the alarm condition clears and its$N"
				    "Minimum On Time has expired, IF Reset is NOT Required.$N"
				    "$N"
				    "@@@@@  $QInp$Q is Inverted in the EnableInFalse Routine!  @@@@@$N"
				    "$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: [[XIC(Inp) ,XIC(Inp_OoS) ] XIO(Cfg_ResetReqd) XIO(Wrk_AlmMinOnT.TT) ,XIC(Disabled) XIO(Wrk_AutoAckT.TT) ]OTU(Wrk_Alm);
				RC: "If the Alarm Input (Inp) is true (inverted in EnableInFalse) and the alarm is (or becomes)$N"
				    "In Service, Enabled, Unsuppressed and Unshelved, this rung sets the Alarm (Alm) bit.$N"
				    "The Acknowledge (Ack) bit is cleared when the Alarm initially occurs.$N"
				    "$N"
				    "@@@@@  $QInp$Q is Inverted in the EnableInFalse Routine!  @@@@@$N"
				    "$N"
				    "#####  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: [XIO(Inp) XIO(Sts_AlmInh) XIO(Wrk_Suppressed) XIO(Inp_OoS) ,XIC(MCmd_Test) OTU(MCmd_Test) ][XIO(Wrk_Alm) OTU(Ack) ,OTL(Wrk_Alm) ];
				RC: "============================================================$N"
				    "OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "This Alarm is ready for (requires) an Acknowledgement if the Alarm$N"
				    "is not Acknowledged (an Acknowledge was Required when the alarm occurred).$N"
				    "$N"
				    "This Alarm is ready for (requires) a Reset if there is an Alarm, Reset is Required,$N"
				    "and either the alarm condition has CLEARED or the alarm is$N"
				    "Out of Service, Shelved, Suppressed or Disabled.$N"
				    ".$N"
				    "If the Alarm is NOT Shelved, it is ready for Shelve.$N"
				    "$N"
				    "If the Alarm IS Shelved, it is ready for Unshelve.$N"
				    "$N"
				    "If the Alarm is NOT Disabled, it is ready for Disable.$N"
				    "$N"
				    "If the Alarm IS Disabled, it is ready for Enable.$N"
				    "$N"
				    "NOTE: This rung appears before the Values/Status rung because the Rdy_Reset$N"
				    "condition is used to eliminate redundant logic in the rung below for Val_Notify.0.$N"
				    "$N"
				    "@@@@@  $QInp$Q is Inverted in the EnableInFalse Routine!  @@@@@$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by containing objects.  #####$N"
				    "#####  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: LBL(End)XIC(Cfg_Exists)[XIO(Wrk_AutoAckT.TT) [XIO(Ack) OTE(ORdy_Ack) ,XIC(Wrk_Alm) XIC(Cfg_ResetReqd) [XIC(Inp) ,XIC(Sts_AlmInh) ,XIC(Wrk_Suppressed) ,XIC(Inp_OoS) ] OTE(ORdy_Reset) ] ,XIC(Cfg_AllowShelve) OTE(ORdy_Shelve) ,XIC(Shelved) OTE(ORdy_Unshelve) ,XIO(Disabled) XIC(Cfg_AllowDisable) OTE(MRdy_Disable) ,XIC(Disabled) OTE(MRdy_Enable) ,XIO(Wrk_Alm) OTE(MRdy_Test) ];
				RC: "============================================================$N"
				    "VALUE / STATUS GENERATION$N"
				    "============================================================$N"
				    "This rung copies the internal working status (Suppressed, In Alarm)$N"
				    "to public Status bits.  Note that internal working bits are used so that$N"
				    "outside objects cannot manipulate the state of this object$N"
				    "by setting/clearing its Status and Alarm bits.$N"
				    "$N"
				    "Public Status is generated for:$N"
				    "Alarm (with minimum ON time to be seen by polling)$N"
				    "Alarm Suppressed$N"
				    "Unsuppressed, Unshelved and Enabled are generated for HMI (FTVSE 7).$N"
				    "$N"
				    "(Ack, Shelved and Disabled can be set/cleared by the HMI directly.$N"
				    "Note that these bits are $Qread/write$Q outputs in the parameter definition.)";
				N: [XIC(Wrk_Alm) OTE(Alm) TON(Wrk_AlmMinOnT,?,?) ,XIC(Wrk_Suppressed) OTE(Suppressed) ];
				RC: "Notify Level (color, blink) is determined here.$N"
				    "@@@@@  Note how the bottom 3 bits of the Severity are shifted left 1 for Val_Notify.  @@@@@$N"
				    "$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "NOTE that the alarm bell icon will blink, even though the alarm is Acknowledged,$N"
				    "if an Alarm Reset is required (to get the Operator$'s attention).";
				N: [[XIO(Ack) ,XIC(ORdy_Reset) ] OTE(Val_Notify.0) ,XIC(Wrk_Alm) [[LIM(1,Cfg_Severity,250) ,LIM(501,Cfg_Severity,750) ] OTE(Val_Notify.1) ,LIM(251,Cfg_Severity,750) OTE(Val_Notify.2) ,LIM(751,Cfg_Severity,1000) OTE(Val_Notify.3) ] ,OTU(Val_Notify.4) OTU(Val_Notify.5) OTU(Val_Notify.6) OTU(Val_Notify.7) ];
				RC: "This rung calculates the number of seconds until this alarm $Qunshelves$Q itself.$N"
				    "If the alarm is already unshelved, clear this number.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Modified to optimize scan time.  ####";
				N: XIO(Shelved)CLR(Val_MinToUnshelve)CLR(Val_SecToUnshelve);
				RC: "This rung takes the time remaining until the alarm will be automatically unshelved (milliseconds),$N"
				    "converts it to seconds, then reports it in  minutes : seconds format for display on the HMI.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Modified to optimize scan time.  ####";
				N: XIC(Shelved)CPT(Wrk_SecToUnshelve,(Wrk_ShelfT.PRE-Wrk_ShelfT.ACC)/1000)DIV(Wrk_SecToUnshelve,60,Val_MinToUnshelve)MOD(Wrk_SecToUnshelve,60,Val_SecToUnshelve);
		END_ROUTINE

		ROUTINE Logic (Description := "Perform Alarm processing: delay, latch/reset, acknowledge, enable/disable, inhibit/uninhibit, suppress/unsuppress")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_Alarm:  PROCESS -- ALARM (sub-block)$N"
				    "============================================================$N"
				    "Revision 4.10.00 Release  2019-03-08:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, and V3.x: Revision History archived.$N"
				    "V4.00.00  2018-06-07:  Changed Inf_ items to HMI_. Deleted Cfg_PCmdClear.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyAck and Sts_RdyReset for use by containing objects.$N"
				    "Modified to remove Suppressed from the conditions which show$N"
				    "the $QInhibited$Q breadcrumb.$N"
				    "Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.$N"
				    "V4.10.00  2019-03-08:  Unmodified, up-rev only for Library 4.10.00$N"
				    "============================================================$N"
				    "This instruction monitors one input condition and provides one Alarm with:$N"
				    "  * configurable latching (reset required) and acknowledgement requirement$N"
				    "  * configurable alarm severity$N"
				    "1..250 = Low  (blue, typ. informational)$N"
				    "251-500 = Medium  (yelllow, typ. warning)$N"
				    "501-750 = High  (red, typ. process exception)$N"
				    "751-1000 = Urgent  (magenta, typ. equip. fault)$N"
				    "* configurable minimum ON time (e.g., to ensure it is seen by the HMI)$N"
				    "* commands to suppress/unsuppress (Prog), shelve/unshelve (Oper)$N"
				    "and disable/enable (Maint) the alarm.$N"
				    "* configurable amount of time shelved to automatically unshelve an alarm$N"
				    "* FTA&E support for suppressed, shelved and disabled states (V7.0)$N"
				    "$N"
				    "NOTE regarding parameter naming:$N"
				    "FTA&E names (same as ALMD instruction) are used instead$N"
				    "of the ANSI/ISA 18.2-2016 names, as follows:$N"
				    "$QDisabled$Q is the equivalent of $QOut of Service$Q in ISA 18.2.$N"
				    "(the Disabled state is owned by Maintenance)$N"
				    "$QSuppressed$Q is the equivalent of $QSuppressed by Design$Q in ISA 18.2.$N"
				    "(the Suppressed state is owned by Program logic)$N"
				    "$QShelved$Q is the same as in ISA 18.2.$N"
				    "(the Shelved state is owned by Operator, but may be cleared$N"
				    "by Program logic based on time, shift change, etc.)$N"
				    "$N"
				    "This instruction is usually nested within other instructions, with one instance$N"
				    "used for each Alarm generated by the containing instruction.  It may also be$N"
				    "used as a standalone instruction for Alarm conditions generated by custom logic.$N"
				    "________________________________________$N"
				    "$N"
				    "FTAE Alarm Setup:$N"
				    "________________________________________$N"
				    "$N"
				    "(object).(alarm).Com_AE.0:  Alarm to FTAE$N"
				    ".Com_AE.1:   Ack to/from FTAE$N"
				    ".Com_AE.2:  Out of Service (from object$'s P_CmdSrc)$N"
				    ".Com_AE.3:   Shelved from FTAE Status$N"
				    ".Com_AE.4:   Shelve/Reshelve to FTAE Control (auto reset)$N"
				    ".Com_AE.5:   Unshelve to FTAE Control (auto reset)$N"
				    ".Com_AE.6:   Suppressed from FTAE Status$N"
				    ".Com_AE.7:   Suppress to FTAE Control (auto reset)$N"
				    ".Com_AE.8:   Unsuppress to FTAE Control (auto reset)$N"
				    ".Com_AE.9:   Disabled from FTAE Status$N"
				    ".Com_AE.10: Disable to FTAE Control (auto reset)$N"
				    ".Com_AE.11: Enable to FTAE Control (auto reset)$N"
				    "all other bits unused$N"
				    "    .Cfg_MaxShelfT is also used in FTAE config.$N"
				    ".Cfg_Severity is used by FTAE in FTView 8.x.$N"
				    "============================================================$N"
				    "POWERUP / INVALID STATE HANDLING$N"
				    "============================================================$N"
				    "All internal Work (state) bits maintain states through a power cycle and are$N"
				    "independent.  No first-scan logic is required.  See the Prescan routine for$N"
				    "powerup / prescan code.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.";
				N: JMP(SkipText)LOWER(Cfg_Tag,Cfg_Cond)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "In the object containing this alarm, other configuration (such as not having$N"
				    "any limit switches) may make this particular alarm meaningless.$N"
				    "The Program Configuration $QAllow Exist$Q is used to hide this alarm$N"
				    "on the object$'s faceplate and other graphics, and forces the Cfg_Exist to 0.";
				N: LBL(SkipText)XIO(PCfg_AllowExist)OTU(Cfg_Exists);
				RC: "$N"
				    "This rung gets the Alarm Minimum ON Time Configuration$N"
				    "and the Auto Unshelve Time Configuration$N"
				    "values and sets the corresponding timer presets.$N"
				    "If the Minimum ON Time Configuration results in a timer preset$N"
				    "less than 5 seconds, the preset is set to 5 seconds.$N"
				    "If the Auto Unshelve Time Configuration results in a negative$N"
				    "timer preset, the preset is set to 28800 seconds (8 hours).$N"
				    "Either bad Config is flagged (Err_Timer).$N"
				    "Bad Config is also flagged if the Cfg_Severity is out of range (valid = 1..1000) (Err_Severity).";
				N: XIC(Cfg_Exists)[[MUL(Cfg_AlmMinOnT,1000,Wrk_AlmMinOnT.PRE) LES(Wrk_AlmMinOnT.PRE,5000) MOV(5,Cfg_AlmMinOnT) MOV(5000,Wrk_AlmMinOnT.PRE) ,MUL(Cfg_MaxShelfT,60000,Wrk_ShelfT.PRE) XIC(Wrk_ShelfT.PRE.31) MOV(480,Cfg_MaxShelfT) MOV(28800000,Wrk_ShelfT.PRE) ] OTE(Err_Timer) ,LIM(1001,Cfg_Severity,0) MOV(1000,Cfg_Severity) OTE(Err_Severity) ]OTE(Sts_Err);
				RC: "The Auto Ack time is ALWAYS five seconds.";
				N: MOV(5000,Wrk_AutoAckT.PRE);
				RC: "When the Alarm initially occurs, the Auto Ack timer is started.$N"
				    "If this Alarm is set for $QAck Not Required$Q, it is automatically $N"
				    "Acknowledged after the AutoAck time expires.$N"
				    "$N"
				    "This pulsing of the Ack bit OFF then ON allows the $QAck Not Required$Q$N"
				    "configuration to be used with View 32, View ME and other legacy$N"
				    "alarm systems that don$'t support optional ack.";
				N: XIO(Ack)TON(Wrk_AutoAckT,?,?);
				RC: "If this alarm does not exist, set it to its default state (no alarm, acknowleded,$N"
				    "uninhibited, unsuppressed, enabled) and clear any received commands.$N"
				    "Then jump over the remainder of the Logic and return.";
				N: XIO(Cfg_Exists)[XIC(Wrk_AutoAckT.DN) OTL(Ack) ,OTU(Wrk_Alm) OTU(Shelved) OTU(Wrk_Suppressed) OTU(Disabled) OTU(Sts_AlmInh) ,OTU(PCmd_Reset) OTU(PCmd_Ack) OTU(PCmd_Unshelve) OTU(PCmd_Suppress) OTU(PCmd_Unsuppress) ,OTU(OCmd_Reset) OTU(OCmd_Ack) OTU(OCmd_Shelve) OTU(OCmd_Unshelve) ,OTU(MCmd_Disable) OTU(MCmd_Enable) RES(Wrk_AlmMinOnT) RES(Wrk_ShelfT) ]JMP(End);
				RC: "============================================================$N"
				    "COMMAND PROCESSING$N"
				    "============================================================$N"
				    "These rungs handle received Commands:$N"
				    "Operator Commands (OCmd_xx) and Maintenance Commands$N"
				    "(MCmd_xx) from the HMI and$N"
				    "Program Command (PCmd_xx) from other objects.$N"
				    "$N"
				    "NOTE:  ALARM COMMANDS ARE ACCEPTED REGARDLESS OF MODE.$N"
				    "$N"
				    "This rung receives the Program Alarm Inhibit Command.$N"
				    "If configured for EDGE, the Command is cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: XIC(PCmd_Suppress)OTU(PCmd_Suppress)OTL(Wrk_Suppressed)OTL(Com_AE.7)OTU(Com_AE.8);
				RC: "This rung receives the Program Alarm Unsuppress Command (Unsuppress wins over Suppress).$N"
				    "If configured for LEVEL, Suppressed is cleared if PCmd_Suppress is cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: XIC(PCmd_Unsuppress)OTU(PCmd_Unsuppress)OTU(Wrk_Suppressed)OTU(Com_AE.7)OTL(Com_AE.8);
				RC: "This rung receives the Operator Shelve Command.$N"
				    "If the command is received while shelved, the shelf timer starts over (reset).";
				N: XIC(OCmd_Shelve)OTU(OCmd_Shelve)XIC(Cfg_AllowShelve)OTL(Shelved)OTL(Com_AE.4)OTU(Com_AE.5)RES(Wrk_ShelfT);
				RC: "This rung times how long the alarm has been shelved.$N"
				    "If the Shelf Timer expires (and its preset > 0), automatically unshelve the alarm.";
				N: XIC(Shelved)TON(Wrk_ShelfT,?,?);
				RC: "This rung receives the Operator Unshelve Command (Unshelve wins over Shelve)$N"
				    "and the Program Unshelve Command$N"
				    "Also Unshelve the alarm if the Shelf Timer expires (if preset > 0).$N"
				    "$N"
				    "NOTE: Shelved can also be set/cleared directly by the HMI (FTA&E support).";
				N: [XIC(OCmd_Unshelve) OTU(OCmd_Unshelve) ,XIC(PCmd_Unshelve) OTU(PCmd_Unshelve) ,XIC(Wrk_ShelfT.DN) NEQ(Wrk_ShelfT.PRE,0) ,XIO(Cfg_AllowShelve) ]OTU(Shelved)OTU(Com_AE.4)OTL(Com_AE.5);
				RC: "This rung receives the Maintenance Alarm Disable Command.";
				N: XIC(MCmd_Disable)OTU(MCmd_Disable)XIC(Cfg_AllowDisable)OTL(Disabled)OTL(Com_AE.10)OTU(Com_AE.11);
				RC: "This rung receives the Maintenance Alarm Enable Command (Enable wins over Disable)$N"
				    "$N"
				    "NOTE: Disabled can also be set/cleared directly by the HMI (FTA&E support).";
				N: [XIC(MCmd_Enable) ,XIO(Cfg_AllowDisable) ]OTU(MCmd_Enable)OTU(Disabled)OTU(Com_AE.10)OTL(Com_AE.11);
				RC: "If the Alarm is Disabled (Maint), or Shelved (Oper),$N"
				    "then post the $Qalarm inhibited$Q breadcrumb and do not$N"
				    "allow a new alarm to be issued.$N"
				    "$N"
				    "NOTE:  If the Alarm is Suppressed (Prog), this is assumed to be $QSuppressed by Design$Q$N"
				    "(ANSI/ISA-18.2-2016) and NOT shown to the operator with an $Qinhibited$Q$N"
				    "breadcrumb!  He just never sees the point as being In Alarm!$N"
				    "$N"
				    "@@@@@  Unlatch and Latch are used to avoid a verification  @@@@@$N"
				    "@@@@@  warning in combination with Rung 2$'s OTU (above)!  @@@@@$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####";
				N: OTU(Sts_AlmInh)[XIC(Disabled) ,XIC(Shelved) ]OTL(Sts_AlmInh);
				RC: "This rung receives the Alarm Acknowledge Commands$N"
				    "$N"
				    "NOTE: Acknowledge can also be set/cleared directly by the HMI.";
				N: [XIC(PCmd_Ack) OTU(PCmd_Ack) ,XIC(OCmd_Ack) OTU(OCmd_Ack) ,XIO(Wrk_AutoAckT.TT) XIO(Cfg_AckReqd) ]OTL(Ack);
				RC: "This rung receives the Alarm Reset Commands.$N"
				    "$N"
				    "If the Alarm Reset Command is received and, either, the Input condition has returned$N"
				    "to normal, or the alarm is out of service, disabled, suppressed or shelved,$N"
				    "the Alarm is CLEARED and ACKNOWLEDGED (to match ALMD behavior!!!).$N"
				    "$N"
				    "#####  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: XIO(Wrk_AutoAckT.TT)[XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ][XIO(Inp) ,XIC(Sts_AlmInh) ,XIC(Wrk_Suppressed) ,XIC(Inp_OoS) ]OTL(Ack)OTU(Wrk_Alm);
				RC: "============================================================$N"
				    "ALARM GENERATION$N"
				    "============================================================$N"
				    "This rung CLEARS the Alarm when the alarm condition clears and its$N"
				    "Minimum On Time has expired, IF Reset is NOT Required.$N"
				    "$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: [[XIO(Inp) ,XIC(Inp_OoS) ] XIO(Cfg_ResetReqd) XIO(Wrk_AlmMinOnT.TT) ,XIC(Disabled) XIO(Wrk_AutoAckT.TT) ]OTU(Wrk_Alm);
				RC: "If the Alarm Input (Inp) is true (inverted in EnableInFalse) and the alarm is (or becomes)$N"
				    "In Service, Enabled, Unsuppressed and Unshelved, this rung sets the Alarm (Alm) bit.$N"
				    "The Acknowledge (Ack) bit is cleared when the Alarm initially occurs.$N"
				    "$N"
				    "#####  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: [XIC(Inp) XIO(Sts_AlmInh) XIO(Wrk_Suppressed) XIO(Inp_OoS) ,XIC(MCmd_Test) OTU(MCmd_Test) ][XIO(Wrk_Alm) OTU(Ack) ,OTL(Wrk_Alm) ];
				RC: "============================================================$N"
				    "OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "This Alarm is ready for (requires) an Acknowledgement if the Alarm$N"
				    "is not Acknowledged (an Acknowledge was Required when the alarm occurred).$N"
				    "$N"
				    "This Alarm is ready for (requires) a Reset if there is an Alarm, Reset is Required,$N"
				    "and either the alarm condition has CLEARED or the alarm is $N"
				    "Out of Service, Shelved, Suppressed or Disabled.$N"
				    ".$N"
				    "If the Alarm is NOT Shelved, it is ready for Shelve.$N"
				    "$N"
				    "If the Alarm IS Shelved, it is ready for Unshelve.$N"
				    "$N"
				    "If the Alarm is NOT Disabled, it is ready for Disable.$N"
				    "$N"
				    "If the Alarm IS Disabled, it is ready for Enable.$N"
				    "$N"
				    "NOTE: This rung appears before the Values/Status rung because the Rdy_Reset$N"
				    "condition is used to eliminate redundant logic in the rung below for Val_Notify.0.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by containing objects.  #####$N"
				    "#####  Modified to remove Suppressed from the conditions to show the $QInhibited$Q breadcrumb.  #####$N"
				    "#####  Added Inp_OoS for Out of Service from parent object$'s P_CmdSrc.  #####";
				N: LBL(End)XIC(Cfg_Exists)[XIO(Wrk_AutoAckT.TT) [XIO(Ack) OTE(ORdy_Ack) ,XIC(Wrk_Alm) XIC(Cfg_ResetReqd) [XIO(Inp) ,XIC(Sts_AlmInh) ,XIC(Wrk_Suppressed) ,XIC(Inp_OoS) ] OTE(ORdy_Reset) ] ,XIC(Cfg_AllowShelve) OTE(ORdy_Shelve) ,XIC(Shelved) OTE(ORdy_Unshelve) ,XIO(Disabled) XIC(Cfg_AllowDisable) OTE(MRdy_Disable) ,XIC(Disabled) OTE(MRdy_Enable) ,XIO(Wrk_Alm) OTE(MRdy_Test) ];
				RC: "============================================================$N"
				    "VALUE / STATUS GENERATION$N"
				    "============================================================$N"
				    "This rung copies the internal working status (Suppressed, In Alarm)$N"
				    "to public Status bits.  Note that internal working bits are used so that$N"
				    "outside objects cannot manipulate the state of this object$N"
				    "by setting/clearing its Status and Alarm bits.$N"
				    "$N"
				    "Public Status is generated for:$N"
				    "Alarm (with minimum ON time to be seen by polling)$N"
				    "Alarm Suppressed$N"
				    "Unsuppressed, Unshelved and Enabled are generated for HMI (FTVSE 7).$N"
				    "$N"
				    "(Ack, Shelved and Disabled can be set/cleared by the HMI directly.$N"
				    "Note that these bits are $Qread/write$Q outputs in the parameter definition.)";
				N: [XIC(Wrk_Alm) OTE(Alm) TON(Wrk_AlmMinOnT,?,?) ,XIC(Wrk_Suppressed) OTE(Suppressed) ];
				RC: "Notify Level (color, blink) is determined here.$N"
				    "@@@@@  Note how the bottom 3 bits of the Severity are shifted left 1 for Val_Notify.  @@@@@$N"
				    "$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "NOTE that the alarm bell icon will blink, even though the alarm is Acknowledged,$N"
				    "if an Alarm Reset is required (to get the Operator$'s attention).";
				N: [[XIO(Ack) ,XIC(ORdy_Reset) ] OTE(Val_Notify.0) ,XIC(Wrk_Alm) [[LIM(1,Cfg_Severity,250) ,LIM(501,Cfg_Severity,750) ] OTE(Val_Notify.1) ,LIM(251,Cfg_Severity,750) OTE(Val_Notify.2) ,LIM(751,Cfg_Severity,1000) OTE(Val_Notify.3) ] ,OTU(Val_Notify.4) OTU(Val_Notify.5) OTU(Val_Notify.6) OTU(Val_Notify.7) ];
				RC: "This rung calculates the number of seconds until this alarm $Qunshelves$Q itself.$N"
				    "If the alarm is already unshelved, clear this number.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Modified to optimize scan time.  ####";
				N: XIO(Shelved)CLR(Val_MinToUnshelve)CLR(Val_SecToUnshelve);
				RC: "This rung takes the time remaining until the alarm will be automatically unshelved (milliseconds),$N"
				    "converts it to seconds, then reports it in  minutes : seconds format for display on the HMI.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Modified to optimize scan time.  ####";
				N: XIC(Shelved)CPT(Wrk_SecToUnshelve,(Wrk_ShelfT.PRE-Wrk_ShelfT.ACC)/1000)DIV(Wrk_SecToUnshelve,60,Val_MinToUnshelve)MOD(Wrk_SecToUnshelve,60,Val_SecToUnshelve);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, clear any $Qlurking$Q Commands.$N"
				    "Unshelve and Unsuppress all alarms, but$N"
				    "only Enable alarms for which Disable is not allowed.$N"
				    "(Let Maintenance Disable persist through a power cycle...)$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [OTU(PCmd_Reset) OTU(PCmd_Ack) OTU(PCmd_Suppress) OTU(PCmd_Unsuppress) OTU(PCmd_Unshelve) ,OTU(OCmd_Reset) OTU(OCmd_Ack) OTU(OCmd_Shelve) OTU(OCmd_Unshelve) ,OTU(MCmd_Disable) OTU(MCmd_Enable) ,OTU(Shelved) OTU(Com_AE.4) OTL(Com_AE.5) ,OTU(Wrk_Suppressed) OTU(Suppressed) OTU(Com_AE.7) OTL(Com_AE.8) ,XIO(Cfg_AllowDisable) OTU(Disabled) OTU(Com_AE.10) OTL(Com_AE.11) ];
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_Gate (Description := "Condition Gate/Delay",
	                                      Revision := "4.10",
	                                      RevisionExtension := ".00 Release",
	                                      RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                      Vendor := "Rockwell Automation",
	                                      ExecutePrescan := Yes,
	                                      ExecutePostscan := No,
	                                      ExecuteEnableInFalse := Yes,
	                                      CreatedDate := "2012-10-01T18:56:53.162Z",
	                                      CreatedBy := "Not Available",
	                                      EditedDate := "2020-12-08T03:31:27.787Z",
	                                      EditedBy := "KEVIN_VM-PC\kevin_VM",
	                                      SoftwareRevision := "v32.02",
	                                      AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction provides a $Qgate$Q for a discrete Input signal and$Nprovides on-delay and off-delay timing for the gated signal.$N$NWhen the Gate input is true, the instruction Input is passed through$Nto the Output, with on-delay and off-delay timing applied.$N$NWhen the Gate input is false, the Output is kept off$N(note: off-delay still applies!)$N$NThis instruction is usually used between a comparison$N(analog threshold with deadband or discrete logic)$Nand a P_Alarm instance, but may be used as a$Ngated on-delay/off-delay timer generally.$N$NWhen EnableIn  is FALSE (e.g., on a false LD rung), the Input $QInp$Q$Nis inverted.  Note that the Gate input (Inp_Gate) is NOT inverted!!!$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Unmodified, up-rev only for Library 4.10.00$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-01)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_ (e.g., HMI_Lib, HMI_Type).$N* Changed delay time configuration items to REAL seconds$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp : BOOL (Description := "Input Condition: e.g., result of comparison",
			               Usage := Input,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               DefaultData := 0);
			Inp_Gate : BOOL (Description := "Gate Input: 1=enable On Delay / Off Delay after Gate Delay, 0=disable",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 1);
			Cfg_GateDly : REAL (Description := "Gate Delay (s): time after Gate Input true to enable On/Off Delay",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_OnDly : REAL (Description := "On Delay (s): If Gate Delay done, time Inp must be true to set Out true",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0.00000000e+000);
			Cfg_OffDly : REAL (Description := "Off Delay (s): Time after Inp  or Gate goes to 0 for Out to go to 0",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0.00000000e+000);
			Out : BOOL (Description := "Output after On Delay, Off Delay, enabled by Gate",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0);
			Sts_Gate : BOOL (Description := "1=Gate Delay done, Output is enabled",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config (see detail Err_ bits for reason), display icon",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: On Delay, Off Delay, Gate Delay Time Invalid (use 0 to 2147483 s)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			P_Gate : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_OffDlyT : TIMER (Description := "Off Delay Timer",
			                      ExternalAccess := Read Only,
			                      DefaultData := "[0,0,0]");
			Wrk_OnDlyT : TIMER (Description := "On Delay Timer",
			                     ExternalAccess := Read Only,
			                     DefaultData := "[0,0,0]");
			Wrk_GateT : TIMER (Description := "Gate Delay Timer",
			                    ExternalAccess := Read Only,
			                    DefaultData := "[0,0,0]");
			Cfg_InpCond : STRING_20 (Description := "Displayed text of P_Gate$'s Input (Inp) Condition",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[15,'Input Condition$00$00$00$00$00']");
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			HMI_Type : STRING_16 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[6,'P_Gate$00$00$00$00$00$00$00$00$00$00']");
			Cfg_GateCond : STRING_20 (Description := "Displayed text of P_Gate$'s Gating (Inp_Gate) Condition",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[16,'Gating Condition$00$00$00$00']");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Same as main Logic routine, except Inp is inverted (for use in LD logic)  (Inp_Gate is NOT inverted!!!)")
				RC: "============================================================$N"
				    "EnableIn FALSE :  CONFIGURATION PROCESSING$N"
				    "============================================================$N"
				    "Flag a Configuration Error if the Gate Delay, On Delay$N"
				    "or Off Delay timer preset is invalid$N"
				    "(and set timer to default zero preset, non-faulting value).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Changed delay time configuration items to REAL seconds.  #####";
				N: [MUL(Cfg_GateDly,1000.0,Wrk_GateT.PRE) XIC(Wrk_GateT.PRE.31) CLR(Wrk_GateT.PRE) ,MUL(Cfg_OnDly,1000.0,Wrk_OnDlyT.PRE) XIC(Wrk_OnDlyT.PRE.31) CLR(Wrk_OnDlyT.PRE) ,MUL(Cfg_OffDly,1000.0,Wrk_OffDlyT.PRE) XIC(Wrk_OffDlyT.PRE.31) CLR(Wrk_OffDlyT.PRE) ]OTE(Err_Timer)OTE(Sts_Err);
				RC: "============================================================$N"
				    "GATE DELAY, ON DELAY, OFF DELAY PROCESSING$N"
				    "============================================================$N"
				    "FOR THE ENABLE_IN_FALSE ROUTINE, the CONDITION Input is$N"
				    "INVERTED, to support the   XIC (condition)  P_Gate (P_Gate backing tag)$N"
				    "construct for instantiation.  This will use Inp = 1,$N"
				    "making the condition input follow the rung condition.$N"
				    "$N"
				    "If the Gate Input is true, run the Gate Delay timer.$N"
				    "Once the Gate Delay is complete, enable the$N"
				    "On Delay and Off Delay that follow the INVERTED input.$N"
				    "$N"
				    "Report the Gate Delay status and the final Output status (after all delays).$N"
				    "$N"
				    "@@@@@  NOTE: Doubled TONs are used to ensure that  @@@@@$N"
				    "@@@@@  .DN bit transitions on same scan if Preset = 0 !  @@@@@";
				N: [XIC(Inp_Gate) TON(Wrk_GateT,?,?) TON(Wrk_GateT,?,?) ,XIC(Wrk_GateT.DN) OTE(Sts_Gate) XIO(Inp) TON(Wrk_OnDlyT,?,?) TON(Wrk_OnDlyT,?,?) ,[XIC(Inp) ,XIO(Inp_Gate) ] TON(Wrk_OffDlyT,?,?) TON(Wrk_OffDlyT,?,?) ,XIC(Wrk_OnDlyT.DN) OTL(Out) ,XIC(Wrk_OffDlyT.DN) OTU(Out) ];
		END_ROUTINE

		ROUTINE Logic (Description := "Gate the input and apply on-delay and off-delay timing")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_Gate:  PROCESS -- CONDITION GATE / DELAY$N"
				    "============================================================$N"
				    "Revision 4.10.00 Release  2019-03-08:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, and V3.x Revision History archived.$N"
				    "V4.00.00  2018-06-07:  Changed Inf_ items to HMI_ (e.g., HMI_Lib, HMI_Type).$N"
				    "Changed delay time configuration items to REAL seconds.$N"
				    "V4.10.00  2019-03-08:  Unmodified, up-rev only for Library 4.10.00$N"
				    "============================================================$N"
				    "This Instruction provides a $Qgate$Q for a discrete Input signal and$N"
				    "provides on-delay and off-delay timing for the gated signal.$N"
				    "$N"
				    "When the Gate input is true, the instruction Input is passed through$N"
				    "to the Output, with on-delay and off-delay timing applied.$N"
				    "$N"
				    "When the Gate input is false, the Output is kept off$N"
				    "(note: off-delay still applies!)$N"
				    "$N"
				    "This instruction is usually used between a comparison$N"
				    "(analog threshold with deadband or discrete logic)$N"
				    "and a P_Alarm instance, but may be used as a$N"
				    "gated on-delay/off-delay timer generally.$N"
				    "$N"
				    "When EnableIn  is FALSE (e.g., on a false LD rung),$N"
				    "the Input $QInp$Q is inverted.  Note that the Gate$N"
				    "input (Inp_Gate) is NOT inverted!!!$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.";
				N: JMP(SkipText)LOWER(Cfg_InpCond,Cfg_GateCond)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "CONFIGURATION PROCESSING$N"
				    "============================================================$N"
				    "Flag a Configuration Error if the Gate Delay, On Delay$N"
				    "or Off Delay timer preset is invalid$N"
				    "(and set timer to default zero preset, non-faulting value).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-07:  Changed delay time configuration items to REAL seconds.  #####";
				N: LBL(SkipText)[MUL(Cfg_GateDly,1000.0,Wrk_GateT.PRE) XIC(Wrk_GateT.PRE.31) CLR(Wrk_GateT.PRE) ,MUL(Cfg_OnDly,1000.0,Wrk_OnDlyT.PRE) XIC(Wrk_OnDlyT.PRE.31) CLR(Wrk_OnDlyT.PRE) ,MUL(Cfg_OffDly,1000.0,Wrk_OffDlyT.PRE) XIC(Wrk_OffDlyT.PRE.31) CLR(Wrk_OffDlyT.PRE) ]OTE(Err_Timer)OTE(Sts_Err);
				RC: "============================================================$N"
				    "GATE DELAY, ON DELAY, OFF DELAY PROCESSING$N"
				    "============================================================$N"
				    "If the Gate Input is true, run the Gate Delay timer.$N"
				    "Once the Gate Delay is complete, enable the$N"
				    "On Delay and Off Delay that follow the input.$N"
				    "$N"
				    "Report the Gate Delay status and the final Output status (after all delays).$N"
				    "$N"
				    "@@@@@  NOTE: Doubled TONs are used to ensure that  @@@@@$N"
				    "@@@@@  .DN bit transitions on same scan if Preset = 0 !  @@@@@";
				N: [XIC(Inp_Gate) TON(Wrk_GateT,?,?) TON(Wrk_GateT,?,?) ,XIC(Wrk_GateT.DN) OTE(Sts_Gate) XIC(Inp) TON(Wrk_OnDlyT,?,?) TON(Wrk_OnDlyT,?,?) ,[XIO(Inp) ,XIO(Inp_Gate) ] TON(Wrk_OffDlyT,?,?) TON(Wrk_OffDlyT,?,?) ,XIC(Wrk_OnDlyT.DN) OTL(Out) ,XIC(Wrk_OffDlyT.DN) OTU(Out) ];
		END_ROUTINE

		ROUTINE Prescan (Description := "Set the Gate Input to 1 (default value) on prescan")
				RC: "============================================================$N"
				    "PRESCAN PROCESSING$N"
				    "============================================================$N"
				    "Set the Gate Input to 1 (default value) on Prescan to enable$N"
				    "statuses / alarms that have Gate input unconnected.";
				N: OTL(Inp_Gate);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_AInAdv (Description := "Advanced Analog Input",
	                                        Revision := "4.10",
	                                        RevisionExtension := ".00 Release",
	                                        RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                        Vendor := "Rockwell Automation",
	                                        ExecutePrescan := Yes,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := Yes,
	                                        CreatedDate := "2008-03-13T19:51:06.608Z",
	                                        CreatedBy := "Not Available",
	                                        EditedDate := "2020-12-08T03:29:41.294Z",
	                                        EditedBy := "KEVIN_VM-PC\kevin_VM",
	                                        SoftwareRevision := "v32.02",
	                                        AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction monitors an Analog Input from a flow, level, pressure,$Ntemperature, or any other analog sensor, and provides:$N$N*  Scaling, from Input (Raw) to PV (Engineering) Units$N*  High-High, High, Low and Low-Low Status and Alarms, with Gate$N    inputs and configurable on-delay, off-delay and gate delay times$N*  Monitoring of bad/uncertain PV status, floating point exceptions$N    and out-of-range conditions, with PV Fail alarm$N*  Setting of a simulated input signal for process simulation$N*  Capturing of the lowest and highest PV excursion values$N*  Configuration for status thresholds, deadbands and range limits$N*  Maintenance Commands to allow manual override of the input signal (Substitute PV)$N$N**  Calculation of (filtered) signal rate of change with High Rate of Change alarm$N**  Square Root characterization for flow scaling based on differential-pressure input$N**  Reference (setpoint) value entry and alarms for deviation from reference (high, low)$N$N** = advanced capabilities in this instruction$N*  = basic capabilities included in P_AIn (analog input basic) instruction$NAlarms are provided by P_Alarm AOI instances.$NGating of status provided by P_Gate AOI instances.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.01)$NSee 4.10 Release Notes for details.$N* Added Control Limits.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.00 Release Notes for details.$N* Modified handling of SrcQ_IO and SrcQ.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-03)$NSee 4.00 Release Notes for details.$N* Removed P_Mode, PSet/Val_Owner and related OSets,$N   PSets and Vals.  Thresholds are now Cfgs.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for Channel object.$N* Added Err_Rate.$N* Changed Out-of-Range limit checks to use raw Input (Inp_PV)$N   instead of scaled PV (Val).  Changing EU scaling will not$N   necessitate changing fail thresholds and deadband.$N* Deleted Cfg_PCmdClear.  All Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N* Removed Err_DB, code ensures Status Deadband configs are always valid.$N* Added configurable decimal places for display on HMI.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_PV : REAL (Description := "Input Signal (process variable) from Sensor",
			                  Usage := Input,
			                  RADIX := Float,
			                  Required := No,
			                  Visible := Yes,
			                  DefaultData := 0.00000000e+000);
			Inp_PVSrcQ : DINT (Description := "Input Source and Quality (from Channel object, if available) (enum)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Inp_PVNotify : DINT (Description := "Related PV object alarm prio and ack status (enum)",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Inp_PVBad : BOOL (Description := "1=PV or I/O Comms Status Bad, 0=OK",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Inp_PVUncertain : BOOL (Description := "1=PV Value Not Reliable, 0=OK",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=Use simulated PV (Set_SimPV); 0=Use Input (Inp_PV)",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_HiHiGate OF HiHiGate.Inp_Gate (Description := "High-High Status Gate, 1=enabled",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			Inp_HiGate OF HiGate.Inp_Gate (Description := "High Status Gate, 1=enabled",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_LoGate OF LoGate.Inp_Gate (Description := "Low Status Gate, 1=enabled",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_LoLoGate OF LoLoGate.Inp_Gate (Description := "Low-Low Status Gate, 1=enabled",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			Inp_HiRoCGate OF HiRoCGate.Inp_Gate (Description := "High Rate of Change Status Gate, 1=enabled",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			Inp_HiDevGate OF HiDevGate.Inp_Gate (Description := "High Deviation Status Gate, 1=enabled",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			Inp_LoDevGate OF LoDevGate.Inp_Gate (Description := "Low Deviation Status Gate, 1=enabled",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			Inp_FailGate OF FailGate.Inp_Gate (Description := "Fail Status Gate, 1=enabled",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			Inp_Reset : BOOL (Description := "1=Reset all Alarms requiring reset",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_UseSqRt : BOOL (Description := "1=Use Square Root characterization for DP to flow; 0=Linear",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Cfg_HasRoC : BOOL (Description := "1=Enables the Rate of Change calc and HiRoC alarm",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Cfg_HasDev : BOOL (Description := "1=Enables Reference entry and Deviation calc and alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Cfg_NoSubstPV : BOOL (Description := "1=Disallow selection of Substitute PV",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_HasChanObj : BOOL (Description := "1=Tells HMI a Channel object (AIChan, etc.) is used for Inp_PV",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_UseChanSrcQ : BOOL (Description := "1=Pass thru connected Channel$'s SrcQ value, 0=generate SrcQ",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_PVDecPlcs : DINT (Description := "Number of decimal places for PV display (0..6)",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 2);
			Cfg_HasHiHiAlm OF HiHi.Cfg_Exists (Description := "1=High-High Alarm exists and will be checked",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			Cfg_HasHiAlm OF Hi.Cfg_Exists (Description := "1=High Alarm exists and will be checked",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			Cfg_HasLoAlm OF Lo.Cfg_Exists (Description := "1=Low Alarm exists and will be checked",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			Cfg_HasLoLoAlm OF LoLo.Cfg_Exists (Description := "1=Low-Low Alarm exists and will be checked",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			Cfg_HasHiRoCAlm OF HiRoC.Cfg_Exists (Description := "1=High Rate of Change Alarm exists and will be checked",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_HasHiDevAlm OF HiDev.Cfg_Exists (Description := "1=High Deviation Alarm exists and will be checked",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_HasLoDevAlm OF LoDev.Cfg_Exists (Description := "1=Low Deviation Alarm exists and will be checked",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_HasFailAlm OF Fail.Cfg_Exists (Description := "1=Analog Input Failure Alarm exists and should be scanned",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			Cfg_HiHiResetReqd OF HiHi.Cfg_ResetReqd (Description := "1=Reset required to clear High-High Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_HiResetReqd OF Hi.Cfg_ResetReqd (Description := "1=Reset required to clear High Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_LoResetReqd OF Lo.Cfg_ResetReqd (Description := "1=Reset required to clear Low Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_LoLoResetReqd OF LoLo.Cfg_ResetReqd (Description := "1=Reset required to clear Low-Low Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_HiRoCResetReqd OF HiRoC.Cfg_ResetReqd (Description := "1=Reset required to clear High Rate of Change Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_HiDevResetReqd OF HiDev.Cfg_ResetReqd (Description := "1=Reset required to clear High Deviation Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_LoDevResetReqd OF LoDev.Cfg_ResetReqd (Description := "1=Reset required to clear Low Deviation Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_FailResetReqd OF Fail.Cfg_ResetReqd (Description := "1=Reset required to clear Analog InputFailure Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_HiHiAckReqd OF HiHi.Cfg_AckReqd (Description := "1=Acknowledge required for High-High Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_HiAckReqd OF Hi.Cfg_AckReqd (Description := "1=Acknowledge required for High Alarm",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			Cfg_LoAckReqd OF Lo.Cfg_AckReqd (Description := "1=Acknlowledge required for Low Alarm",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			Cfg_LoLoAckReqd OF LoLo.Cfg_AckReqd (Description := "1=Acknowledge required for Low-Low Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_HiRoCAckReqd OF HiRoC.Cfg_AckReqd (Description := "1=Acknowledge required for High Rate of Change Alarm",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_HiDevAckReqd OF HiDev.Cfg_AckReqd (Description := "1=Acknowledge required for High Deviation Alarm",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_LoDevAckReqd OF LoDev.Cfg_AckReqd (Description := "1=Acknowledge required for Low Deviation Alarm",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_FailAckReqd OF Fail.Cfg_AckReqd (Description := "1=Acknowledge required for Analog Input Failure Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_HiHiSeverity OF HiHi.Cfg_Severity (Description := "High-High Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_HiSeverity OF Hi.Cfg_Severity (Description := "High Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			Cfg_LoSeverity OF Lo.Cfg_Severity (Description := "Low Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			Cfg_LoLoSeverity OF LoLo.Cfg_Severity (Description := "Low-Low Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_HiRoCSeverity OF HiRoC.Cfg_Severity (Description := "High Rate of Change Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_HiDevSeverity OF HiDev.Cfg_Severity (Description := "High Deviation Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_LoDevSeverity OF LoDev.Cfg_Severity (Description := "Low Deviation Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_FailSeverity OF Fail.Cfg_Severity (Description := "Failure Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_InpRawMin : REAL (Description := "Input (unscaled) Minimum for Scaling",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			Cfg_InpRawMax : REAL (Description := "Input (unscaled) Maximum for Scaling",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 1.00000000e+002);
			Cfg_PVEUMin : REAL (Description := "PV (Output) Minimum for Scaling to EU",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_PVEUMax : REAL (Description := "PV (Output) Maximum for Scaling to EU",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+002);
			Cfg_FiltTC : REAL (Description := "PV Filter Time Constant (sec),$N0.0 = unfiltered",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0.00000000e+000);
			Cfg_RateTime : REAL (Description := "PV Rate of Change time base (sec) 60=/min, 3600=/hr",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+000);
			Cfg_Ref : REAL (Description := "Analog Reference for Deviation Alarms (EU)",
			                   Usage := Input,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := Yes,
			                   DefaultData := 0.00000000e+000);
			Cfg_CtrlHiHiLim : REAL (Description := "Current High-High Control Threshold",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 1.50000000e+038);
			Cfg_CtrlHiHiDB : REAL (Description := "High-High Control Deadband (EU)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 1.00000000e+000);
			Cfg_CtrlHiLim : REAL (Description := "Current High Control Threshold",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 1.50000000e+038);
			Cfg_CtrlHiDB : REAL (Description := "High Control Deadband (EU)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+000);
			Cfg_CtrlLoLim : REAL (Description := "Current Low Control Threshold",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := -1.50000000e+038);
			Cfg_CtrlLoDB : REAL (Description := "Low Control Deadband (EU)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+000);
			Cfg_CtrlLoLoLim : REAL (Description := "Current Low-Low Control Threshold",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := -1.50000000e+038);
			Cfg_CtrlLoLoDB : REAL (Description := "Low-Low Control Deadband (EU)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 1.00000000e+000);
			Cfg_HiHiLim : REAL (Description := "Current High-High Status Threshold",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1.50000000e+038);
			Cfg_HiHiDB : REAL (Description := "High-High Status Deadband (EU)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1.00000000e+000);
			Cfg_HiHiOnDly OF HiHiGate.Cfg_OnDly (Description := "Minimum time above High-High Limit to raise Status (sec)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No);
			Cfg_HiHiOffDly OF HiHiGate.Cfg_OffDly (Description := "Minimum time below High-High Limit (minus deadband) to clear Status (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No);
			Cfg_HiHiGateDly OF HiHiGate.Cfg_GateDly (Description := "High-High Status Gate Delay (s)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No);
			Cfg_HiLim : REAL (Description := "Current High Status Threshold",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 1.50000000e+038);
			Cfg_HiDB : REAL (Description := "High Status Deadband (EU)",
			                    Usage := Input,
			                    RADIX := Float,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 1.00000000e+000);
			Cfg_HiOnDly OF HiGate.Cfg_OnDly (Description := "Minimum time above High Limit to raise Status (sec)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No);
			Cfg_HiOffDly OF HiGate.Cfg_OffDly (Description := "Minimum time below High Limit (minus deadband) to clear Status (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No);
			Cfg_HiGateDly OF HiGate.Cfg_GateDly (Description := "High Status Gate Delay (s)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No);
			Cfg_LoLim : REAL (Description := "Current Low Status Threshold",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := -1.50000000e+038);
			Cfg_LoDB : REAL (Description := "Low Status Deadband (EU)",
			                    Usage := Input,
			                    RADIX := Float,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 1.00000000e+000);
			Cfg_LoOnDly OF LoGate.Cfg_OnDly (Description := "Minimum time below Low Limit to raise Status (sec)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No);
			Cfg_LoOffDly OF LoGate.Cfg_OffDly (Description := "Minimum time above Low Limit (plus deadband) to clear Status (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No);
			Cfg_LoGateDly OF LoGate.Cfg_GateDly (Description := "Low Status Gate Delay (s)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No);
			Cfg_LoLoLim : REAL (Description := "Current Low-Low Status Threshold",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := -1.50000000e+038);
			Cfg_LoLoDB : REAL (Description := "Low-Low Status Deadband (EU)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1.00000000e+000);
			Cfg_LoLoOnDly OF LoLoGate.Cfg_OnDly (Description := "Minimum time below Low-Low Limit to raise Status (sec)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No);
			Cfg_LoLoOffDly OF LoLoGate.Cfg_OffDly (Description := "Minimum time above Low-Low Limit (plus deadband) to clear Status (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No);
			Cfg_LoLoGateDly OF LoLoGate.Cfg_GateDly (Description := "Low-Low Status Gate Delay (s)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No);
			Cfg_HiRoCLim : REAL (Description := "Current High Rate of Change Status Threshold",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := 1.50000000e+038);
			Cfg_HiRoCDB : REAL (Description := "High Rate of Change Status Deadband (EU/rate time)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+000);
			Cfg_HiRoCOnDly OF HiRoCGate.Cfg_OnDly (Description := "Minimum time above High Rate of Change Limit to raise Status (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No);
			Cfg_HiRoCOffDly OF HiRoCGate.Cfg_OffDly (Description := "Minimum time below High Rate of Change Limit (minus deadband) to clear Status (sec)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No);
			Cfg_HiRoCGateDly OF HiRoCGate.Cfg_GateDly (Description := "High Rate of Change Status Gate Delay (s)",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No);
			Cfg_HiDevLim : REAL (Description := "Current High Deviation Status Threshold",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := 1.50000000e+038);
			Cfg_HiDevDB : REAL (Description := "High Deviation Status Deadband (EU)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+000);
			Cfg_HiDevOnDly OF HiDevGate.Cfg_OnDly (Description := "Minimum time above High Deviation Limit to raise Status (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No);
			Cfg_HiDevOffDly OF HiDevGate.Cfg_OffDly (Description := "Minimum time below High Deviation Limit (minus deadband) to clear Status (sec)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No);
			Cfg_HiDevGateDly OF HiDevGate.Cfg_GateDly (Description := "High Deviation Status Gate Delay (s)",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No);
			Cfg_LoDevLim : REAL (Description := "Current Low Deviation Status Threshold",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := -1.50000000e+038);
			Cfg_LoDevDB : REAL (Description := "Low Deviation Status Deadband (EU)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+000);
			Cfg_LoDevOnDly OF LoDevGate.Cfg_OnDly (Description := "Minimum time below Low Deviation Limit to raise Status (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No);
			Cfg_LoDevOffDly OF LoDevGate.Cfg_OffDly (Description := "Minimum time above Low Deviation Limit (plus deadband) to clear Status (sec)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No);
			Cfg_LoDevGateDly OF LoDevGate.Cfg_GateDly (Description := "Low Deviation Status Gate Delay (s)",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No);
			Cfg_FailHiLim : REAL (Description := "Out-of-Range (fail) High Limit (EU)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 1.03958336e+002);
			Cfg_FailLoLim : REAL (Description := "Out-of-Range (fail) Low Limit (EU)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := -2.08333325e+000);
			Cfg_FailDB : REAL (Description := "Out-of-Range (fail) High/Low Deadband (EU)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 4.16666657e-001);
			Cfg_FailOnDly OF FailGate.Cfg_OnDly (Description := "Minimum time Bad or Out of Range to raise Fail Status (sec)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No);
			Cfg_FailOffDly OF FailGate.Cfg_OffDly (Description := "Minimum time OK or In Range to clear Fail Status (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No);
			Cfg_FailGateDly OF FailGate.Cfg_GateDly (Description := "Fail Status Gate Delay (s)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No);
			MSet_SubstPV : REAL (Description := "Maintenance-Entered Substitute PV (EU)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Set_SimPV : REAL (Description := "PV used in Simulation (Inp_Sim=1) (EU)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0.00000000e+000);
			PCmd_ClearCapt : BOOL (Description := "Program Command to Clear the captured min / max PV excursion values",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			PCmd_Reset : BOOL (Description := "Program Command to Reset all Alarms requiring Reset",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_HiHiAck OF HiHi.PCmd_Ack (Description := "Program Command to Acknowledge High-High Alarm",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			PCmd_HiHiSuppress OF HiHi.PCmd_Suppress (Description := "Program Command to Suppress High-High Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_HiHiUnsuppress OF HiHi.PCmd_Unsuppress (Description := "Program Command to Unsuppress High-High Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_HiHiUnshelve OF HiHi.PCmd_Unshelve (Description := "Program Command to Unshelve High-High Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_HiAck OF Hi.PCmd_Ack (Description := "Program Command to Acknowledge High Alarm",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			PCmd_HiSuppress OF Hi.PCmd_Suppress (Description := "Program Command to Suppress High Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_HiUnsuppress OF Hi.PCmd_Unsuppress (Description := "Program Command to Unsuppress High Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_HiUnshelve OF Hi.PCmd_Unshelve (Description := "Program Command to Unshelve High Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_LoAck OF Lo.PCmd_Ack (Description := "Program Command to Acknowledge Low Alarm",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			PCmd_LoSuppress OF Lo.PCmd_Suppress (Description := "Program Command to Suppress Low Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_LoUnsuppress OF Lo.PCmd_Unsuppress (Description := "Program Command to Unsuppress Low Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_LoUnshelve OF Lo.PCmd_Unshelve (Description := "Program Command to Unshelve Low Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_LoLoAck OF LoLo.PCmd_Ack (Description := "Program Command to Acknowledge Low-Low Alarm",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			PCmd_LoLoSuppress OF LoLo.PCmd_Suppress (Description := "Program Command to Suppress Low-Low Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_LoLoUnsuppress OF LoLo.PCmd_Unsuppress (Description := "Program Command to Unsuppress Low-Low Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_LoLoUnshelve OF LoLo.PCmd_Unshelve (Description := "Program Command to Unshelve Low-Low Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_HiRoCAck OF HiRoC.PCmd_Ack (Description := "Program Command to Acknowledge High Rate of Change Alarm",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			PCmd_HiRoCSuppress OF HiRoC.PCmd_Suppress (Description := "Program Command to Suppress High Rate of Change Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_HiRoCUnsuppress OF HiRoC.PCmd_Unsuppress (Description := "Program Command to Unsuppress High Rate of Change Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_HiRoCUnshelve OF HiRoC.PCmd_Unshelve (Description := "Program Command to Unshelve High Rate of Change Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_HiDevAck OF HiDev.PCmd_Ack (Description := "Program Command to Acknowledge High Deviation Alarm",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			PCmd_HiDevSuppress OF HiDev.PCmd_Suppress (Description := "Program Command to Suppress High Deviation Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_HiDevUnsuppress OF HiDev.PCmd_Unsuppress (Description := "Program Command to Unsuppress High Deviation Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_HiDevUnshelve OF HiDev.PCmd_Unshelve (Description := "Program Command to Unshelve High Deviation Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_LoDevAck OF LoDev.PCmd_Ack (Description := "Program Command to Acknowledge Low Deviation Alarm",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No);
			PCmd_LoDevSuppress OF LoDev.PCmd_Suppress (Description := "Program Command to Suppress Low Deviation Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_LoDevUnsuppress OF LoDev.PCmd_Unsuppress (Description := "Program Command to Unsuppress Low Deviation Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_LoDevUnshelve OF LoDev.PCmd_Unshelve (Description := "Program Command to Unshelve Low Deviation Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_FailAck OF Fail.PCmd_Ack (Description := "Program Command to Acknowldege Analog Input Failure Alarm",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			PCmd_FailSuppress OF Fail.PCmd_Suppress (Description := "Program Command to Suppress Analog Input Failure Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_FailUnsuppress OF Fail.PCmd_Unsuppress (Description := "Program Command to Unsuppress Analog Input Failure Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_FailUnshelve OF Fail.PCmd_Unshelve (Description := "Program Command to Unshelve Analog Input Failure Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Val : REAL (Description := "Analog Input Value (incl. Manual Override, if used)",
			               Usage := Output,
			               RADIX := Float,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0.00000000e+000);
			Val_InpPV : REAL (Description := "Analog Input Value (actual, before Substitute PV selection)",
			                     Usage := Output,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0.00000000e+000);
			Val_RoC : REAL (Description := "Analog Value Rate of Change (EU/rate time)",
			                   Usage := Output,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0.00000000e+000);
			Val_Dev : REAL (Description := "Calculated Deviation from Reference (EU)",
			                   Usage := Output,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0.00000000e+000);
			Val_PVMinCapt : REAL (Description := "Captured PV Minimum (excursion) since last cleared",
			                         Usage := Output,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 1.50000000e+038);
			Val_PVMaxCapt : REAL (Description := "Captured PV Maximum (excursion) since last cleared",
			                         Usage := Output,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := -1.50000000e+038);
			Val_PVEUMin : REAL (Description := "Minimum of scaled range = MIN (Cfg_PVEUMin, Cfg_PVEUMax)",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0.00000000e+000);
			Val_PVEUMax : REAL (Description := "Maximum of scaled range = MAX (Cfg_PVEUMin, Cfg_PVEUMax)",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 1.00000000e+002);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=none, 20=Lo, 21=Hi, 22=LoDev, 23=HiDev, 24=LoLo, 25=HiHi, 26=HiRoC 32=Fail, 34=CfgErr",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + channel (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_SubstPV : BOOL (Description := "1=Using Substitute PV (Input being overridden)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_PVBad : BOOL (Description := "1=PV Bad quality or Out of Range",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_PVUncertain : BOOL (Description := "1=PV Value is Uncertain (quality)",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=A Maintenance Bypass is Active, display icon",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=An Alarm is Shelved, Disabled or Suppressed: display icon",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Raw : BOOL (Description := "1=Error in Config: Raw Input Scaling Min = Max",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_EU : BOOL (Description := "1=Error in Config: Scaled EU Min = Max",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: On-Delay, Off-Delay, Gate Delay Time Invalid (use 0 to 2147483 s)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Rate : BOOL (Description := "1=Error in Config: Invalid Rate Time (use 1.0, 60.0, 3600.0, 86400.0...)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Err_Filt : BOOL (Description := "1=-Error in Config: PV filter params (RateTime, TC)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_CtrlHiHi : BOOL (Description := "1=Analog Input is above High-High Control limit",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_CtrlHi : BOOL (Description := "1=Analog Input is above High Control limit",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_CtrlLo : BOOL (Description := "1=Analog Input is above Low Control limit",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_CtrlLoLo : BOOL (Description := "1=Analog Input is above Low-Low Control limit",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_HiHiCmp OF HiHiGate.Inp (Description := "PV High-High comparison result 1=High-High",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_HiHiGate OF HiHiGate.Sts_Gate (Description := "PV High-High Gate Delay Status, 1=done",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_HiHi OF HiHi.Inp (Description := "1=Analog Input is above High-High limit",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read/Write);
			Alm_HiHi OF HiHi.Alm (Description := "1=Analog Input is in High-High Alarm",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Ack_HiHi OF HiHi.Ack (Description := "1=High-High Alarm has been acknowledged",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Sts_HiHiDisabled OF HiHi.Disabled (Description := "1=High-High Alarm has been Disabled by Maintenance",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_HiHiShelved OF HiHi.Shelved (Description := "1=High-High Alarm has been Shelved by Operator",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_HiHiSuppressed OF HiHi.Suppressed (Description := "1=High-High Alarm has been Suppressed by Program",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_HiCmp OF HiGate.Inp (Description := "PV High comparison result 1=High",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Sts_HiGate OF HiGate.Sts_Gate (Description := "PV High Gate Delay Status, 1=done",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_Hi OF Hi.Inp (Description := "1=Analog Input is above High limit",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read/Write);
			Alm_Hi OF Hi.Alm (Description := "1=Analog Input is in High Alarm",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write);
			Ack_Hi OF Hi.Ack (Description := "1=High Alarm has been acknowledged",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write);
			Sts_HiDisabled OF Hi.Disabled (Description := "1=High Alarm has been Disabled by Maintenance",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Sts_HiShelved OF Hi.Shelved (Description := "1=High Alarm has been Shelved by Operator",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_HiSuppressed OF Hi.Suppressed (Description := "1=High Alarm has been Suppressed by Program",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_LoCmp OF LoGate.Inp (Description := "PV Low comparison result 1=Low",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Sts_LoGate OF LoGate.Sts_Gate (Description := "PV Low Gate Delay Status, 1=done",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_Lo OF Lo.Inp (Description := "1=Analog Input is below Low limit",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read/Write);
			Alm_Lo OF Lo.Alm (Description := "1=Analog Input is in Low Alarm",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write);
			Ack_Lo OF Lo.Ack (Description := "1=Low Alarm has been acknowledged",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write);
			Sts_LoDisabled OF Lo.Disabled (Description := "1=Low Alarm has been Disabled by Maintenance",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Sts_LoShelved OF Lo.Shelved (Description := "1=Low Alarm has been Shelved by Operator",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_LoSuppressed OF Lo.Suppressed (Description := "1=Low Alarm has been Suppressed by Program",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_LoLoCmp OF LoLoGate.Inp (Description := "PV Low-Low comparison result 1=Low-Low",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_LoLoGate OF LoLoGate.Sts_Gate (Description := "PV Low-Low Gate Delay Status, 1=done",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_LoLo OF LoLo.Inp (Description := "1=Analog Input is below Low-Low limit",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read/Write);
			Alm_LoLo OF LoLo.Alm (Description := "1=Analog Input is in Low-Low Alarm",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Ack_LoLo OF LoLo.Ack (Description := "1=Low-Low Alarm has been acknowledged",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Sts_LoLoDisabled OF LoLo.Disabled (Description := "1=Low-Low Alarm has been Disabled by Maintenance",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_LoLoShelved OF LoLo.Shelved (Description := "1=Low-Low Alarm has been Shelved by Operator",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_LoLoSuppressed OF LoLo.Suppressed (Description := "1=Low Low Alarm has been Suppressed by Program",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_HiRoCCmp OF HiRoCGate.Inp (Description := "PV High Rate of Change comparison result 1=High",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read/Write);
			Sts_HiRoCGate OF HiRoCGate.Sts_Gate (Description := "PV High Rate of Change Gate Delay Status, 1=done",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_HiRoC OF HiRoC.Inp (Description := "1=Analog Input Rate of Change is above High limit",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read/Write);
			Alm_HiRoC OF HiRoC.Alm (Description := "1=Analog Input Rate of Change is in High Alarm",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Ack_HiRoC OF HiRoC.Ack (Description := "1=High Rate of Change Alarm has been acknowledged",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Sts_HiRoCDisabled OF HiRoC.Disabled (Description := "1=High Rate of Change Alarm has been Disabled by Maintenance",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Sts_HiRoCShelved OF HiRoC.Shelved (Description := "1=High Rate of Change Alarm has been Shelved by Operator",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_HiRoCSuppressed OF HiRoC.Suppressed (Description := "1=High Rate of Change Alarm has been Suppressed by Program",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_HiDevCmp OF HiDevGate.Inp (Description := "PV High Deviation comparison result 1=Dev High",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read/Write);
			Sts_HiDevGate OF HiDevGate.Sts_Gate (Description := "PV High Deviation Gate Delay Status, 1=done",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_HiDev OF HiDev.Inp (Description := "1=Analog Input Deviation is above High limit",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read/Write);
			Alm_HiDev OF HiDev.Alm (Description := "1=Analog Input Deviation is in High Alarm",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Ack_HiDev OF HiDev.Ack (Description := "1=High Deviation Alarm has been acknowledged",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Sts_HiDevDisabled OF HiDev.Disabled (Description := "1=High Deviation Alarm has been Disabled by Maintenance",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Sts_HiDevShelved OF HiDev.Shelved (Description := "1=High Deviation Alarm has been Shelved by Operator",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_HiDevSuppressed OF HiDev.Suppressed (Description := "1=High Deviation Alarm has been Suppressed by Program",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_LoDevCmp OF LoDevGate.Inp (Description := "PV Low Deviation comparison result 1=Dev Low",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read/Write);
			Sts_LoDevGate OF LoDevGate.Sts_Gate (Description := "PV Low Deviation Gate Delay Status, 1=done",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_LoDev OF LoDev.Inp (Description := "1=Analog Input Deviation is below Low limit",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read/Write);
			Alm_LoDev OF LoDev.Alm (Description := "1=Analog Input Deviation is in Low Alarm",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Ack_LoDev OF LoDev.Ack (Description := "1=Low Deviation Alarm has been acknowledged",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write);
			Sts_LoDevDisabled OF LoDev.Disabled (Description := "1=Low Deviation Alarm has been Disabled by Maintenance",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Sts_LoDevShelved OF LoDev.Shelved (Description := "1=Low Deviation Alarm has been Shelved by Operator",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_LoDevSuppressed OF LoDev.Suppressed (Description := "1=Low Deviation Alarm has been Suppressed by Program",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_FailCmp OF FailGate.Inp (Description := "PV Fail comparison result 1=Out of Range",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_FailGate OF FailGate.Sts_Gate (Description := "PV Fail Gate Delay Status, 1=done",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_Fail OF Fail.Inp (Description := "1=Analog Input is Out of Range or PV Bad",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read/Write);
			Alm_Fail OF Fail.Alm (Description := "1=Analog Input Failure Alarm (Bad or Out of Range)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Ack_Fail OF Fail.Ack (Description := "1=Analog Input Failure Alarm has been acknowledged",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Sts_FailDisabled OF Fail.Disabled (Description := "1=Analog input Failure Alarm has been Disabled by Maintenance",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_FailShelved OF Fail.Shelved (Description := "1=Analog Input Failure Alarm has been Shelved by Operator",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_FailSuppressed OF Fail.Suppressed (Description := "1=Analog Input Failure Alarm has been Suppressed by Program",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			P_AInAdv : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			LoLo : P_Alarm (Description := "Low-Low Alarm",
			               ExternalAccess := Read/Write,
			               DefaultData := "[961,750,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Lo : P_Alarm (Description := "Low Alarm",
			             ExternalAccess := Read/Write,
			             DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Hi : P_Alarm (Description := "High Alarm",
			             ExternalAccess := Read/Write,
			             DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			HiHi : P_Alarm (Description := "High-High Alarm",
			               ExternalAccess := Read/Write,
			               DefaultData := "[961,750,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_EU : STRING_8 (Description := "Engineering Units for display on HMI",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[1,'%$00$00$00$00$00$00$00']");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[8,'P_AinAdv$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[12,'Analog Input$00$00$00$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Fail : P_Alarm (Description := "Analog Input Failure Alarm (bad quality or out of range)",
			               ExternalAccess := Read/Write,
			               DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_SubstPV : BOOL (Description := "Internal flag: Using Substitute PV",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_PVSq : REAL (Description := "Square of PV, for square root characterization",
			                   RADIX := Float,
			                   ExternalAccess := None,
			                   DefaultData := 0.00000000e+000);
			Wrk_EUMinSq : REAL (Description := "Square of EU Min, for square root characterization",
			                      RADIX := Float,
			                      ExternalAccess := None,
			                      DefaultData := 0.00000000e+000);
			Wrk_EUMaxSq : REAL (Description := "Square of EU Max, for square root characterization",
			                      RADIX := Float,
			                      ExternalAccess := None,
			                      DefaultData := 0.00000000e+000);
			Wrk_UnfiltPV : REAL (Description := "Unfiltered PV, input to 1st order filter",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_ScanTime : REAL (Description := "Time since this instance was last scanned",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_FiltPV : REAL (Description := "Filtered PV",
			                     RADIX := Float,
			                     ExternalAccess := None,
			                     DefaultData := 0.00000000e+000);
			Wrk_RoC : REAL (Description := "Calculated Rate of Change of PV",
			                  RADIX := Float,
			                  ExternalAccess := None,
			                  DefaultData := 0.00000000e+000);
			Wrk_PrevPV : REAL (Description := "Previous scan$'s value of Filtered PV",
			                     RADIX := Float,
			                     ExternalAccess := None,
			                     DefaultData := 0.00000000e+000);
			LoDev : P_Alarm (Description := "Low Deviation Alarm",
			                ExternalAccess := Read/Write,
			                DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			HiDev : P_Alarm (Description := "High Deviation Alarm",
			                ExternalAccess := Read/Write,
			                DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			HiRoC : P_Alarm (Description := "High Rate of Change Alarm",
			                ExternalAccess := Read/Write,
			                DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Wrk_ScanT : TIMER (Description := "Scan Timer (milliseconds, always runs)",
			                    ExternalAccess := None,
			                    DefaultData := "[0,2147483647,0]");
			Wrk_Alpha : REAL (Description := "Filter multiplier = (1 / (1+TC/dT) )",
			                    RADIX := Float,
			                    ExternalAccess := None,
			                    DefaultData := 0.00000000e+000);
			Wrk_ValidONS : BOOL (Description := "Selected PV goes from Infinite or Not a Number to VALID",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_InpInfNaN : BOOL (Description := "Input (Inp_PV or Set_SimPV) Infinite or Not a Number",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_InpDINT : DINT (Description := "Input REAL bit pattern as a DINT (check for Inf/NaN)",
			                      RADIX := Hex,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_SelPVDINT : DINT (Description := "Selected PV check for Infinite or Non A Number",
			                        RADIX := Hex,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_SelPVInfNaN : BOOL (Description := "Selected PV (Input or Substitute) is Infinite or NaN",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			HMI_Type : STRING_16 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[8,'P_AInAdv$00$00$00$00$00$00$00$00']");
			Wrk_HiRoC : BOOL (Description := "Internal flag: High Rate of Change Status",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_LoDev : BOOL (Description := "Internal flag: Low Deviation Status",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_HiDev : BOOL (Description := "Internal flag: High Deviation Status",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_Fail : BOOL (Description := "Internal flag: Fail Status",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_LoLo : BOOL (Description := "Internal flag: Low-Low Status",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_Lo : BOOL (Description := "Internal flag: Low Status",
			                 RADIX := Decimal,
			                 ExternalAccess := None,
			                 DefaultData := 0);
			Wrk_HiHi : BOOL (Description := "Internal flag: High-High Status",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_Hi : BOOL (Description := "Internal flag: High Status",
			                 RADIX := Decimal,
			                 ExternalAccess := None,
			                 DefaultData := 0);
			LoDevGate : P_Gate (Description := "Low Deviation Alarm Gate / Delay Block",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[16,'PV Deviation Low$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			HiRoCGate : P_Gate (Description := "High Rate of Change Alarm Gate / Delay Block",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[20,'PV Hi Rate of Change'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			HiDevGate : P_Gate (Description := "High Deviation Alarm Gate / Delay Block",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[17,'PV Deviation High$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			LoLoGate : P_Gate (Description := "Low-Low Alarm Gate / Delay Block",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			LoGate : P_Gate (Description := "Low Alarm Gate / Delay Block",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			HiHiGate : P_Gate (Description := "High-High Alarm Gate / Delay Block",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			HiGate : P_Gate (Description := "High Alarm Gate / Delay Block",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			FailGate : P_Gate (Description := "Fail Alarm Gate / Delay Block",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Val_Notify : DINT (Description := "Highest Alarm prio and ack status this object only (enum)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			OCmd_ResetAckAll : BOOL (Description := "Operator Command to Reset and Acknowledge all Alarms",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Operator Command to Reset all Alarms requiring Reset",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			OCmd_ClearCapt : BOOL (Description := "Operator Command to Clear the captured min / max PV excursion values",
			                         RADIX := Decimal,
			                         ExternalAccess := Read/Write,
			                         DefaultData := 0);
			MCmd_InpPV : BOOL (Description := "Maintenance Command to use Input PV (normal)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_SubstPV : BOOL (Description := "Maintenance Command to use Substitute PV (override input)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read/Write,
			                       DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_InpPV : BOOL (Description := "1=Ready for MCmd_InpPV (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_SubstPV : BOOL (Description := "1=Ready for MCmd_SubstPV (enables HMI button)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Wrk_RawPV : REAL (Description := "Value of raw PV to be used for Out of Range checking",
			                    RADIX := Float,
			                    ExternalAccess := None,
			                    DefaultData := 0.00000000e+000);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Off-Scan: no Val update or alarm checking.  PV Bad Quality ($Qstale$Q) is asserted.")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Deleted rungs for Mode, Owner.  #####$N"
				    "$N"
				    "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "This rung publishes the Values for the scaled range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the configuration of a PID, so the AIn and PID ranges are in lockstep.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added configurable decimal places for display on HMI.  #####";
				N: [GEQ(Cfg_PVEUMax,Cfg_PVEUMin) MOV(Cfg_PVEUMin,Val_PVEUMin) MOV(Cfg_PVEUMax,Val_PVEUMax) ,LES(Cfg_PVEUMax,Cfg_PVEUMin) MOV(Cfg_PVEUMin,Val_PVEUMax) MOV(Cfg_PVEUMax,Val_PVEUMin) ,LIM(7,Cfg_PVDecPlcs,-1) MOV(2,Cfg_PVDecPlcs) ];
				RC: "If a Threshold Deadband is invalid, set it to a valid value.  (Zero is valid for all deadbands!)$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed Err_DB, code ensures Status Deadband configs are always valid.  #####$N"
				    "#####  V4.10.00  2019-03-12:  Added Control Limits, code ensure Control Deadbands are always valid.  #####";
				N: [LES(Cfg_HiHiDB,0.0) CLR(Cfg_HiHiDB) ,LES(Cfg_HiDB,0.0) CLR(Cfg_HiDB) ,LES(Cfg_LoDB,0.0) CLR(Cfg_LoDB) ,LES(Cfg_LoLoDB,0.0) CLR(Cfg_LoLoDB) ,LES(Cfg_CtrlHiHiDB,0.0) CLR(Cfg_CtrlHiHiDB) ,LES(Cfg_CtrlHiDB,0.0) CLR(Cfg_CtrlHiDB) ,LES(Cfg_CtrlLoDB,0.0) CLR(Cfg_CtrlLoDB) ,LES(Cfg_CtrlLoLoDB,0.0) CLR(Cfg_CtrlLoLoDB) ,[GEQ(Cfg_HiRoCDB,Cfg_HiRoCLim) NEQ(Cfg_HiRoCLim,0.0) ,LES(Cfg_HiRoCDB,0.0) ] CLR(Cfg_HiRoCDB) ,LES(Cfg_HiDevDB,0.0) CLR(Cfg_HiDevDB) ,LES(Cfg_LoDevDB,0.0) CLR(Cfg_LoDevDB) ,LES(Cfg_FailDB,0.0) CLR(Cfg_FailDB) ];
				RC: "Flag a Configuration Error if the raw input range or scaled PV range$N"
				    "max and min are set the same (invalid range).$N"
				    "$N"
				    "Since this Analog Input is disabled, indicate that the PV is bad$N"
				    "(Val is not being updated.)$N"
				    "Indicate that this Analog Input is DISABLED (Val_Sts = 33);$N"
				    "if there is a Configuration Error, indicate that as well (Val_Fault=34).";
				N: [OTU(Sts_MaintByp) OTL(Sts_PVBad) ,CLR(Wrk_Fault) ,[EQU(Cfg_InpRawMax,Cfg_InpRawMin) OTE(Err_Raw) ,EQU(Cfg_PVEUMax,Cfg_PVEUMin) OTE(Err_EU) ,LES(Cfg_FiltTC,0.0) OTE(Err_Filt) ] OTE(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ANALOG INPUT PROCESSING$N"
				    "============================================================$N"
				    "This rung checks the bit pattern of the REAL input (by copying to a DINT) to see if$N"
				    "the input is +Infinity, -Infinity or Not a Number.  Per ANSI 32-bit Float$N"
				    "format, in these cases the Exponent bits (.30 thru .23) will all be 1s:$N"
				    "0111 1111 1000 0000 0000 0000 0000 0000 = +Infinity$N"
				    "1111 1111 1000 0000 0000 0000 0000 0000 = -Infinity$N"
				    "x111 1111 1xxx xxxx xxxx xxxx xxxx xxxx = Not a Number";
				N: [XIO(Inp_Sim) COP(Inp_PV,Wrk_InpDINT,1) ,XIC(Inp_Sim) COP(Set_SimPV,Val_InpPV,1) COP(Set_SimPV,Wrk_InpDINT,1) ]MEQ(Wrk_InpDINT,16#7F80_0000,16#7F80_0000)OTE(Wrk_InpInfNaN);
				RC: "The Process Variable Value (Val_PV) shows the selected input,$N"
				    "regardless of Mode, EVEN WHEN EnableIn IS FALSE!$N"
				    "$N"
				    "Here$'s where we select the input or the substitue PV,$N"
				    "and for the input PV, do the scaling to Engineering Units.$N"
				    "$N"
				    "Scale to the squares of the EUMax and EUMin, then take the Square Root, $N"
				    "if the Square Root characterization is selected.  (This must work even for non-zero-based$N"
				    "inputs, say, +/- 20$Q WC, and show +/- flow, scaled on a square root curve each side of zero!)$N"
				    "$N"
				    "If Square Root characterization is not selected, just do linear scaling.";
				N: [XIO(Err_Raw) XIO(Err_EU) XIO(Wrk_InpInfNaN) [XIO(Inp_Sim) [XIO(Cfg_UseSqRt) CPT(Val_InpPV,(Inp_PV-Cfg_InpRawMin)*(Cfg_PVEUMax-Cfg_PVEUMin)/(Cfg_InpRawMax-Cfg_InpRawMin)+Cfg_PVEUMin) ,XIC(Cfg_UseSqRt) [CPT(Wrk_EUMinSq,Cfg_PVEUMin*ABS(Cfg_PVEUMin)) CPT(Wrk_EUMaxSq,Cfg_PVEUMax*ABS(Cfg_PVEUMax)) ,CPT(Wrk_PVSq,(Inp_PV-Cfg_InpRawMin)*(Wrk_EUMaxSq-Wrk_EUMinSq)/(Cfg_InpRawMax-Cfg_InpRawMin)+Wrk_EUMinSq) ,LES(Wrk_PVSq,0.0) CPT(Val_InpPV,-SQR(-Wrk_PVSq)) ,GEQ(Wrk_PVSq,0.0) SQR(Wrk_PVSq,Val_InpPV) ] ,MOV(Inp_PV,Wrk_RawPV) ] ,XIC(Inp_Sim) [XIO(Cfg_UseSqRt) CPT(Wrk_RawPV,(Set_SimPV-Cfg_PVEUMin)*(Cfg_InpRawMax-Cfg_InpRawMin)/(Cfg_PVEUMax-Cfg_PVEUMin)+Cfg_InpRawMin) ,XIC(Cfg_UseSqRt) [CPT(Wrk_PVSq,Set_SimPV*(ABS(Set_SimPV))) ,CPT(Wrk_EUMinSq,Cfg_PVEUMin*ABS(Cfg_PVEUMin)) CPT(Wrk_EUMaxSq,Cfg_PVEUMax*ABS(Cfg_PVEUMax)) ,CPT(Wrk_RawPV,(Wrk_PVSq-Wrk_EUMinSq)*(Cfg_InpRawMax-Cfg_InpRawMin)/(Wrk_EUMaxSq-Wrk_EUMinSq)+Cfg_InpRawMin) ] ,MOV(Set_SimPV,Val_InpPV) ] ] ,[XIC(Err_Raw) ,XIC(Err_EU) ] MOV(Cfg_PVEUMin,Val_InpPV) MOV(Cfg_InpRawMin,Wrk_RawPV) ,XIC(Wrk_InpInfNaN) COP(Wrk_InpDINT,Val_InpPV,1) COP(Wrk_InpDINT,Wrk_RawPV,1) ];
				RC: "When this Analog Input is not simulated,$N"
				    "the Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Remove P_Mode, threshold settings are now configs (Cfg_xxxLim).  #####$N"
				    "#####  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: XIO(Inp_Sim)COP(Val_InpPV,Set_SimPV,1);
				RC: "The Process Variable Input Value (Val_InpPV) shows the scaled input,$N"
				    "regardless of the settings of Mode, Substitute PV, etc., EVEN WHEN EnableIn IS FALSE!$N"
				    "$N"
				    "If NOT in simulation, if the scaling configuration is valid, the Raw Input is scaled to Engineering Units.$N"
				    "In Simulation the Simulated Input must be provided in Engineering Units.";
				N: XIC(Wrk_InpInfNaN)JMP(DoSrcQ);
				RC: "If the Analog Value rises above the Fail High Limit or falls below the$N"
				    "Fail Low Limit, raise the Fail Status Flag.$N"
				    "$N"
				    "If the Analog Value is back in range, that is, it is below the Fail High Limit (minus$N"
				    "deadband) and above the Fail Low Limit (plus deadband),$N"
				    "clear the Fail Status Flag.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####$N"
				    "#####  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: XIO(Err_Raw)[[GEQ(Wrk_RawPV,Cfg_FailHiLim) ,LEQ(Wrk_RawPV,Cfg_FailLoLim) ] ,XIC(FailGate.Out) [CMP(Wrk_RawPV>=(Cfg_FailHiLim-Cfg_FailDB)) ,CMP(Wrk_RawPV<=(Cfg_FailLoLim+Cfg_FailDB)) ] ]OTE(Wrk_Fail);
				RC: "============================================================$N"
				    "ENUMERATED STATUS VALUES$N"
				    "============================================================$N"
				    "Source and Quality (Srcq) for Val_InpPV$N"
				    "Start with the Srcq from the Input Channel object if it$'s available.$N"
				    "Otherwise, start based on bad/uncertain input bits.$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Modified to correct precedence and value of Simulated PV.  #####$N"
				    "#####  V4.00.01  2018-08-29:  Modified handling of Simulated PV and scaling config errors.  #####";
				N: LBL(DoSrcQ)[XIO(Cfg_UseChanSrcQ) MOV(1,Wrk_SrcQ) ,XIC(Cfg_UseChanSrcQ) MOV(Inp_PVSrcQ,Wrk_SrcQ) ,XIC(Inp_PVUncertain) MOV(16,Wrk_SrcQ) ,XIC(Inp_PVBad) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(10,Wrk_SrcQ) ,[XIC(Wrk_InpInfNaN) ,XIC(Sts_FailCmp) ] [XIO(Cfg_UseChanSrcQ) ,XIC(Inp_Sim) ] MOV(32,Wrk_SrcQ) ,[XIC(Err_Raw) ,XIC(Err_EU) ] MOV(35,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality (SrcQ) for Val (primary value)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(19,SrcQ);
				RC: "$QLurking$Q Operator Commands are cleared, as well as the Program Reset.";
				N: OTU(MCmd_InpPV)OTU(MCmd_SubstPV)OTU(OCmd_Reset)OTU(OCmd_ResetAckAll)OTU(PCmd_Reset);
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Remove Rdy_OSet -- AOI no longer has Mode / Owner.  #####";
				N: OTU(MRdy_InpPV)OTU(MRdy_SubstPV)OTU(ORdy_Reset)OTU(Sts_RdyAck)OTU(ORdy_ResetAckAll);
				RC: "The first-order filter$'s scan timer must run and clear every scan, whether the Instruction$N"
				    "is true or not.  Doing so here avoids a bump in the Value on transition to EnableIn TRUE.";
				N: TON(Wrk_ScanT,?,?)CLR(Wrk_ScanT.ACC);
				RC: "Set up the filter initialization one-shot so filter of $QVal$Q in main Logic$N"
				    "will start from first valid value on transition from false to true.";
				N: OTU(Wrk_ValidONS);
				RC: "Clear the Alarms and the Notify Status, and show the Alarms Inhibited breadcrumb.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count including attached Channel object.  #####";
				N: [OTU(Alm_HiHi) OTU(Alm_Hi) OTU(Alm_Lo) OTU(Alm_LoLo) ,OTU(Alm_HiRoC) OTU(Alm_HiDev) OTU(Alm_LoDev) OTU(Alm_Fail) ,OTU(Sts_HiHi) OTU(Sts_Hi) OTU(Sts_Lo) OTU(Sts_LoLo) ,OTU(Sts_HiRoC) OTU(Sts_HiDev) OTU(Sts_LoDev) OTU(Sts_Fail) ,OTL(Sts_AlmInh) CLR(Val_Notify) CLR(Val_NotifyAll) CLR(Val_UnackAlmC) ];
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan - PV is scaled and alarms are generated")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_AInAdv:  PROCESS -- ADVANCED ANALOG INPUT$N"
				    "============================================================$N"
				    "Revision 4.10.00 Release  2019-03-12:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-06-25:  Removed P_Mode, PSet/Val_Owner and related OSets,$N"
				    "   PSets and Vals.  Thresholds are now Cfgs.$N"
				    "Changed Inf_ items to HMI_, and added Cfg_Area for security.$N"
				    "Added notify and unack count rollup for Channel object. Added Err_Rate.$N"
				    "Changed Out-of-Range limit checks to use raw Input (Inp_PV)$N"
				    "   instead of scaled PV (Val).  Changing EU scaling will not$N"
				    "   necessitate changing fail thresholds and deadband.$N"
				    "Deleted Cfg_PCmdClear.  All Program Commands are now self-clearing.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N"
				    "Removed Err_DB, code ensures Status Deadband configs are always valid.$N"
				    "Added configurable decimal places for display on HMI.$N"
				    "V4.00.01  2018-08-29:  Modified handling of SrcQ_IO and SrcQ.$N"
				    "V4.10.00  2019-03-12: Added Control Limits. Added Cfg_HasMoreObj.$N"
				    "============================================================$N"
				    "This Instruction monitors an Analog Input from a flow, level, pressure,$N"
				    "temperature, or any other analog sensor, and provides:$N"
				    "$N"
				    "*  Scaling, from Input (Raw) to PV (Engineering) Units$N"
				    "*  High-High, High, Low and Low-Low Status and Alarms, with Gate$N"
				    "inputs and configurable on-delay, off-delay and gate delay times$N"
				    "*  Monitoring of bad/uncertain PV status, floating point exceptions$N"
				    "and out-of-range conditions, with PV Fail alarm$N"
				    "*  Setting of a simulated input signal for process simulation$N"
				    "*  Capturing of the lowest and highest PV excursion values$N"
				    "*  Configurable status thresholds, deadbands and range limits$N"
				    "*  Maintenance Commands to allow manual override of the input signal (Substitute PV)$N"
				    "$N"
				    "**  Calculation of (filtered) signal rate of change with High Rate of Change alarm$N"
				    "**  Square Root characterization for flow scaling based on differential-pressure input$N"
				    "**  Reference (setpoint) value entry and alarms for deviation from reference (high, low)$N"
				    "$N"
				    "** = advanced capabilities in this instruction$N"
				    "*  = basic capabilities included in P_AIn (analog input basic) instruction$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00-00  2018-06-25:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####$N"
				    "#####  Removed two rungs with Mode, Owner functions.  #####$N"
				    "";
				N: JMP(SkipText)LOWER(Cfg_Desc,Cfg_Label)CONCAT(Cfg_Tag,Cfg_Area,Cfg_EU)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "CONFIGURATION PROCESSING$N"
				    "============================================================$N"
				    "This rung publishes the Values for the scaled range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the configuration of a PID, so the AIn and PID ranges are in lockstep.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added configurable decimal places for display on HMI.  #####";
				N: LBL(SkipText)[GEQ(Cfg_PVEUMax,Cfg_PVEUMin) MOV(Cfg_PVEUMin,Val_PVEUMin) MOV(Cfg_PVEUMax,Val_PVEUMax) ,LES(Cfg_PVEUMax,Cfg_PVEUMin) MOV(Cfg_PVEUMin,Val_PVEUMax) MOV(Cfg_PVEUMax,Val_PVEUMin) ,LIM(7,Cfg_PVDecPlcs,-1) MOV(2,Cfg_PVDecPlcs) ];
				RC: "If a Threshold Deadband is invalid, set it to a valid value.  (Zero is valid for all deadbands!)$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed Err_DB, code ensures Status Deadband configs are always valid.  #####$N"
				    "#####  V4.10.00  2019-03-12:  Added Control Limits, code ensure Control Deadbands are always valid.  #####";
				N: [LES(Cfg_HiHiDB,0.0) CLR(Cfg_HiHiDB) ,LES(Cfg_HiDB,0.0) CLR(Cfg_HiDB) ,LES(Cfg_LoDB,0.0) CLR(Cfg_LoDB) ,LES(Cfg_LoLoDB,0.0) CLR(Cfg_LoLoDB) ,LES(Cfg_CtrlHiHiDB,0.0) CLR(Cfg_CtrlHiHiDB) ,LES(Cfg_CtrlHiDB,0.0) CLR(Cfg_CtrlHiDB) ,LES(Cfg_CtrlLoDB,0.0) CLR(Cfg_CtrlLoDB) ,LES(Cfg_CtrlLoLoDB,0.0) CLR(Cfg_CtrlLoLoDB) ,[GEQ(Cfg_HiRoCDB,Cfg_HiRoCLim) NEQ(Cfg_HiRoCLim,0.0) ,LES(Cfg_HiRoCDB,0.0) ] CLR(Cfg_HiRoCDB) ,LES(Cfg_HiDevDB,0.0) CLR(Cfg_HiDevDB) ,LES(Cfg_LoDevDB,0.0) CLR(Cfg_LoDevDB) ,LES(Cfg_FailDB,0.0) CLR(Cfg_FailDB) ];
				RC: "Ensure each Deviation Deadband is set to a value that allows the Deviation Status to clear.";
				N: [GRT(Cfg_HiDevDB,Cfg_HiDevLim) MOV(Cfg_HiDevLim,Cfg_HiDevDB) ,CMP(Cfg_LoDevDB>(-Cfg_LoDevLim)) NEG(Cfg_LoDevLim,Cfg_LoDevDB) ];
				RC: "Flag a Configuration Error if the raw input range or$N"
				    "scaled PV range max and min are set the same (invalid range),$N"
				    "if the Analog Input Filter Time Constant is set to a negative value,$N"
				    "or if the time used in Rate of Change calculations is less than or equal to zero.$N"
				    "$N"
				    "#####  V4.00.00  2018-03-31:  Added Err_Rate.  #####";
				N: [EQU(Cfg_InpRawMax,Cfg_InpRawMin) OTE(Err_Raw) ,EQU(Cfg_PVEUMax,Cfg_PVEUMin) OTE(Err_EU) ,LES(Cfg_FiltTC,0.0) OTE(Err_Filt) ,LEQ(Cfg_RateTime,0.0) OTE(Err_Rate) ];
				RC: "============================================================$N"
				    "SUBSTITUTE PV / INPUT PV COMMAND PROCESSING$N"
				    "============================================================$N"
				    "These rungs handle the Substitute PV and Input PV Commands:$N"
				    "$N"
				    "MCmd_SubstPV: Maintenance Command to select Maintenance-entered substitute PV$N"
				    "$N"
				    "Do not allow this Command if Cfg_NoSubstPV is set.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed check for Maintenance Mode.  #####";
				N: XIC(MCmd_SubstPV)OTU(MCmd_SubstPV)XIO(Cfg_NoSubstPV)OTL(Wrk_SubstPV);
				RC: "MCmd_InpPV: Maintenance Command to cancel Substitute PV and return to Live Input PV.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed check for Maintenance Mode.  #####";
				N: [XIC(MCmd_InpPV) OTU(MCmd_InpPV) ,XIC(Cfg_NoSubstPV) ]OTU(Wrk_SubstPV);
				RC: "Show the Substitute / Input PV selection Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed Sts_InpPV.  (It was simply the inverse of Sts_SubstPV!)  #####";
				N: XIC(Wrk_SubstPV)OTE(Sts_SubstPV);
				RC: "Substitute PV is the only Maintenance Bypass for an Analog Input.";
				N: XIC(Sts_SubstPV)OTE(Sts_MaintByp);
				RC: "In Maintenance Mode, commands for Substitue PV and Input PV are available$N"
				    "based on the current state of the internal toggle bit.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed check for Maintenance Mode.  #####";
				N: XIO(Cfg_NoSubstPV)[XIO(Wrk_SubstPV) OTE(MRdy_SubstPV) ,XIC(Wrk_SubstPV) OTE(MRdy_InpPV) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(PCmd_HiHiAck) OTL(PCmd_HiAck) ,OTL(PCmd_LoAck) OTL(PCmd_LoLoAck) ,OTL(PCmd_HiRoCAck) OTL(PCmd_HiDevAck) ,OTL(PCmd_LoDevAck) OTL(PCmd_FailAck) ] ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ][OTL(HiHi.PCmd_Reset) OTL(Hi.PCmd_Reset) OTL(Lo.PCmd_Reset) OTL(LoLo.PCmd_Reset) ,OTL(HiRoC.PCmd_Reset) OTL(HiDev.PCmd_Reset) OTL(LoDev.PCmd_Reset) OTL(Fail.PCmd_Reset) ];
				RC: "============================================================$N"
				    "ANALOG INPUT PROCESSING$N"
				    "============================================================$N"
				    "This rung checks the bit pattern of the REAL input (by copying to a DINT) to see if$N"
				    "the input is +Infinity, -Infinity or Not a Number.  Per ANSI 32-bit Float$N"
				    "format, in these cases the Exponent bits (.30 thru .23) will all be 1s:$N"
				    "0111 1111 1000 0000 0000 0000 0000 0000 = +Infinity$N"
				    "1111 1111 1000 0000 0000 0000 0000 0000 = -Infinity$N"
				    "x111 1111 1xxx xxxx xxxx xxxx xxxx xxxx = Not a Number";
				N: [XIO(Inp_Sim) COP(Inp_PV,Wrk_InpDINT,1) ,XIC(Inp_Sim) COP(Set_SimPV,Val_InpPV,1) COP(Set_SimPV,Wrk_InpDINT,1) ]MEQ(Wrk_InpDINT,16#7F80_0000,16#7F80_0000)OTE(Wrk_InpInfNaN);
				RC: "The Process Variable Value (Val_PV) shows the selected input,$N"
				    "regardless of Mode, EVEN WHEN EnableIn IS FALSE!$N"
				    "$N"
				    "Here$'s where we select the input or the substitue PV,$N"
				    "and for the input PV, do the scaling to Engineering Units.$N"
				    "$N"
				    "Scale to the squares of the EUMax and EUMin, then take the Square Root, $N"
				    "if the Square Root characterization is selected.  (This must work even for non-zero-based$N"
				    "inputs, say, +/- 20$Q WC, and show +/- flow, scaled on a square root curve each side of zero!)$N"
				    "$N"
				    "If Square Root characterization is not selected, just do linear scaling.";
				N: [XIO(Err_Raw) XIO(Err_EU) XIO(Wrk_InpInfNaN) [XIO(Inp_Sim) [XIO(Cfg_UseSqRt) CPT(Val_InpPV,(Inp_PV-Cfg_InpRawMin)*(Cfg_PVEUMax-Cfg_PVEUMin)/(Cfg_InpRawMax-Cfg_InpRawMin)+Cfg_PVEUMin) ,XIC(Cfg_UseSqRt) [CPT(Wrk_EUMinSq,Cfg_PVEUMin*ABS(Cfg_PVEUMin)) CPT(Wrk_EUMaxSq,Cfg_PVEUMax*ABS(Cfg_PVEUMax)) ,CPT(Wrk_PVSq,(Inp_PV-Cfg_InpRawMin)*(Wrk_EUMaxSq-Wrk_EUMinSq)/(Cfg_InpRawMax-Cfg_InpRawMin)+Wrk_EUMinSq) ,LES(Wrk_PVSq,0.0) CPT(Val_InpPV,-SQR(-Wrk_PVSq)) ,GEQ(Wrk_PVSq,0.0) SQR(Wrk_PVSq,Val_InpPV) ] ,MOV(Inp_PV,Wrk_RawPV) ] ,XIC(Inp_Sim) [XIO(Cfg_UseSqRt) CPT(Wrk_RawPV,(Set_SimPV-Cfg_PVEUMin)*(Cfg_InpRawMax-Cfg_InpRawMin)/(Cfg_PVEUMax-Cfg_PVEUMin)+Cfg_InpRawMin) ,XIC(Cfg_UseSqRt) [CPT(Wrk_PVSq,Set_SimPV*(ABS(Set_SimPV))) ,CPT(Wrk_EUMinSq,Cfg_PVEUMin*ABS(Cfg_PVEUMin)) CPT(Wrk_EUMaxSq,Cfg_PVEUMax*ABS(Cfg_PVEUMax)) ,CPT(Wrk_RawPV,(Wrk_PVSq-Wrk_EUMinSq)*(Cfg_InpRawMax-Cfg_InpRawMin)/(Wrk_EUMaxSq-Wrk_EUMinSq)+Cfg_InpRawMin) ] ,MOV(Set_SimPV,Val_InpPV) ] ] ,[XIC(Err_Raw) ,XIC(Err_EU) ] MOV(Cfg_PVEUMin,Val_InpPV) MOV(Cfg_InpRawMin,Wrk_RawPV) ,XIC(Wrk_InpInfNaN) COP(Wrk_InpDINT,Val_InpPV,1) COP(Wrk_InpDINT,Wrk_RawPV,1) ];
				RC: "When this Analog Input is not simulated,$N"
				    "the Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Remove P_Mode, threshold settings are now configs (Cfg_xxxLim).  #####$N"
				    "#####  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: XIO(Inp_Sim)COP(Val_InpPV,Set_SimPV,1);
				RC: "============================================================$N"
				    "SELECT NORMAL OR SUBSTITUTE PV$N"
				    "============================================================$N"
				    "This rung selects the input to the PV filter.$N"
				    "In normal operation, it$'s the value (Val_InpPV) selected above:$N"
				    "the scaled Input (Inp_PV) or Simulatied PV (Set_SimPV)$N"
				    "(and this value tracks back into the Substitute PV setting).$N"
				    "With Substitute PV enabled, it$'s the value of the entered MSet_SubstPV.";
				N: XIO(Wrk_SubstPV)COP(Val_InpPV,Wrk_UnfiltPV,1)COP(Val_InpPV,MSet_SubstPV,1);
				N: XIC(Wrk_SubstPV)COP(MSet_SubstPV,Wrk_UnfiltPV,1);
				RC: "============================================================$N"
				    "PV FIRST-ORDER FILTER PROCESSING$N"
				    "============================================================$N"
				    "This rung determines whether the Analog PV (unfiltered) is +/-Infinity or +/- NotANumber.$N"
				    "In either case, the value cannot be passed into the filter calculation.  Instead, it is$N"
				    "just copied to the PV directly.";
				N: COP(Wrk_UnfiltPV,Wrk_SelPVDINT,1)MEQ(Wrk_SelPVDINT,16#7F80_0000,16#7F80_0000)OTE(Wrk_SelPVInfNaN);
				RC: "If tracking is enabled, copy the Untiltered PV to the Substitute PV Setting.";
				N: COP(Wrk_UnfiltPV,MSet_SubstPV,1);
				RC: "In preparation for calculating the Filtered PV, this rung$N"
				    "determines the time since the previous scan, using a non-stop TON timer.$N"
				    "When we get here, we read the accumulator (in milliseconds, so$N"
				    "divide by 1000.0 to get seconds), then clear the accumulator.  Next scan the accumulator will have$N"
				    "incremented up to the number of milliseconds since last scan.  (Works for scan times up to 2 million seconds.....)";
				N: MOV(2147483647,Wrk_ScanT.PRE)TON(Wrk_ScanT,?,?)DIV(Wrk_ScanT.ACC,1000.0,Wrk_ScanTime)CLR(Wrk_ScanT.ACC);
				RC: "If the input was +/-Infinity or Not a Number and it becomes a valid number,$N"
				    "initialize the filter to start from the first valid value.";
				N: XIO(Wrk_SelPVInfNaN)ONS(Wrk_ValidONS)MOV(Wrk_UnfiltPV,Wrk_FiltPV)MOV(Wrk_UnfiltPV,Wrk_PrevPV);
				RC: "Calculate the FILTERED PV. $N"
				    "First, calculate $Qalpha$Q, the portion of the difference between input and previous value to move toward the input.$N"
				    "Then calculate the new value.";
				N: [GRT(Cfg_FiltTC,0.0) CPT(Wrk_Alpha,1.0/(1.0+Wrk_ScanTime/Cfg_FiltTC)) ,LEQ(Cfg_FiltTC,0.0) CLR(Wrk_Alpha) ,XIO(Wrk_SelPVInfNaN) CPT(Wrk_FiltPV,(Wrk_Alpha*Wrk_FiltPV)+((1.0-Wrk_Alpha)*Wrk_UnfiltPV)) ];
				RC: "Sts_PVBad and Sts_PVUncertain take care of the PV Quality.$N"
				    "As for the ultimate Value (Val):$N"
				    "If the number is being filtered, pass thru the output of the filter.  It$'s a $Qreal$Q number.$N"
				    "If the number is not being filtered because it is not a number or infinite, pass that thru.";
				N: [XIO(Wrk_SelPVInfNaN) MOV(Wrk_FiltPV,Val) ,XIC(Wrk_SelPVInfNaN) COP(Wrk_UnfiltPV,Val,1) ];
				RC: "============================================================$N"
				    "PV RATE OF CHANGE PROCESSING$N"
				    "============================================================$N"
				    "If the input is NOT being simulated, calculate the instantaneous PV RATE OF CHANGE.$N"
				    "Then stash the current PV away for use in next scan$'s calculation.";
				N: XIC(Cfg_HasRoC)XIO(Wrk_SelPVInfNaN)[XIO(Inp_Sim) GRT(Wrk_ScanTime,0.0) CPT(Wrk_RoC,(Val-Wrk_PrevPV)/Wrk_ScanTime*Cfg_RateTime) ,LEQ(Wrk_ScanTime,0.0) CLR(Wrk_RoC) ,MOV(Val,Wrk_PrevPV) ];
				RC: "If we are using the Substitute PV, NOT using the Rate of Change, or if the PV is$N"
				    "Infinite or Not a Number, just set the Rate of Change Value  to zero.$N"
				    "Otherwise, publish the calculated rate of change.$N"
				    "";
				N: [XIO(Sts_SubstPV) XIC(Cfg_HasRoC) XIO(Wrk_SelPVInfNaN) MOV(Wrk_RoC,Val_RoC) ,[XIC(Sts_SubstPV) ,XIO(Cfg_HasRoC) ,XIC(Wrk_SelPVInfNaN) ] CLR(Val_RoC) ];
				RC: "============================================================$N"
				    "PV DEVIATION FROM REFERENCE PROCESSING$N"
				    "============================================================$N"
				    "The difference between the Value (Val) and the entered$N"
				    "Reference (setpoint) (Val_Ref) is the Deviation (Val_Dev).$N"
				    "If we$'re not using the Deviation, or if the PV is Infinite or Not a Number,$N"
				    "zero the deviation.";
				N: [XIC(Cfg_HasDev) XIO(Wrk_SelPVInfNaN) SUB(Val,Cfg_Ref,Val_Dev) ,[XIO(Cfg_HasDev) ,XIC(Wrk_SelPVInfNaN) ] CLR(Val_Dev) ];
				RC: "============================================================$N"
				    "CAPTURE MIN / MAX PV EXCURSION$N"
				    "============================================================$N"
				    "Capture the PV Maximum Excursion (highest value reached) and$N"
				    "PV Minimum Excursion (lowest value reached) since last cleared.";
				N: XIO(Wrk_SelPVInfNaN)[GRT(Val,Val_PVMaxCapt) MOV(Val,Val_PVMaxCapt) ,LES(Val,Val_PVMinCapt) MOV(Val,Val_PVMinCapt) ];
				RC: "============================================================$N"
				    "CLEAR CAPTURED MIN / MAX COMMAND PROCESSING$N"
				    "============================================================$N"
				    "This rung $Qclears$Q the captured Minimum and Maximum$N"
				    "by setting them to the current PV Value.";
				N: [XIC(OCmd_ClearCapt) OTU(OCmd_ClearCapt) ,XIC(PCmd_ClearCapt) OTU(PCmd_ClearCapt) ]XIO(Wrk_SelPVInfNaN)MOV(Val,Val_PVMaxCapt)MOV(Val,Val_PVMinCapt);
				RC: "============================================================$N"
				    "ANALOG THRESHOLD STATUS PROCESSING$N"
				    "============================================================$N"
				    "If the Analog Value is Infinite or Not a Number, skip the compares$N"
				    "to avoid Minor Faults and just flag the value as Bad below.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####$N"
				    "#####  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: XIC(Wrk_SelPVInfNaN)JMP(FailCheck);
				RC: "If the Analog Value exceeds the Control High-High limit,$N"
				    "issue the Control High-High Status.$N"
				    "If the Analog Value falls back below the limit (minus deadband),$N"
				    "clear the Control High-High Status.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-12: Added Control High-High Limit.  #####";
				N: [GEQ(Val,Cfg_CtrlHiHiLim) ,XIC(Sts_CtrlHiHi) CMP(Val>=(Cfg_CtrlHiHiLim-Cfg_CtrlHiHiDB)) ]OTE(Sts_CtrlHiHi);
				RC: "If the Analog Value exceeds the Control High limit,$N"
				    "issue the Control High Status.$N"
				    "If the Analog Value falls back below the limit (minus deadband),$N"
				    "clear the Control High Status.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-12: Added Control High Limit.  #####";
				N: [GEQ(Val,Cfg_CtrlHiLim) ,XIC(Sts_CtrlHi) CMP(Val>=(Cfg_CtrlHiLim-Cfg_CtrlHiDB)) ]OTE(Sts_CtrlHi);
				RC: "If the Analog Value falls below the Control Low limit,$N"
				    "issue the Control Low Status.$N"
				    "If the Analog Value rises back above the limit (plus deadband), $N"
				    "clear the Control Low Status.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-12: Added Control Low Limit.  #####";
				N: [LEQ(Val,Cfg_CtrlLoLim) ,XIC(Sts_CtrlLo) CMP(Val<=(Cfg_CtrlLoLim+Cfg_CtrlLoDB)) ]OTE(Sts_CtrlLo);
				RC: "If the Analog Value falls below the Control Low-Low limit,$N"
				    "issue the Control Low-Low Status.$N"
				    "If the Analog Value rises back above the limit (plus deadband), $N"
				    "clear the Control Low-Low Status.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-12: Added Control Low-Low Limit.  #####";
				N: [LEQ(Val,Cfg_CtrlLoLoLim) ,XIC(Sts_CtrlLoLo) CMP(Val<=(Cfg_CtrlLoLoLim+Cfg_CtrlLoLoDB)) ]OTE(Sts_CtrlLoLo);
				RC: "If the Analog Value exceeds the High-High limit,$N"
				    "issue the High-High Status Flag.$N"
				    "If the Analog Value falls back below the limit (minus deadband),$N"
				    "clear the High-High Status Flag.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [GEQ(Val,Cfg_HiHiLim) ,XIC(HiHiGate.Out) CMP(Val>=(Cfg_HiHiLim-Cfg_HiHiDB)) ]OTE(Wrk_HiHi);
				RC: "If the Analog Value exceeds the High limit,$N"
				    "issue the High Status Flag.$N"
				    "If the Analog Value falls back below the limit (minus deadband), $N"
				    "clear the High Status Flag.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [GEQ(Val,Cfg_HiLim) ,XIC(HiGate.Out) CMP(Val>=(Cfg_HiLim-Cfg_HiDB)) ]OTE(Wrk_Hi);
				RC: "If the Analog Value falls below the Low limit,$N"
				    "issue the Low Status Flag.$N"
				    "If the Analog Value rises back above the limit (plus deadband), $N"
				    "clear the Low Status Flag.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [LEQ(Val,Cfg_LoLim) ,XIC(LoGate.Out) CMP(Val<=(Cfg_LoLim+Cfg_LoDB)) ]OTE(Wrk_Lo);
				RC: "If the Analog Value falls below the Low-Low limit,$N"
				    "issue the Low-Low Status Flag.$N"
				    "If the Analog Value rises back above the limit (plus deadband),$N"
				    "clear the Low-Low Status Flag.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [LEQ(Val,Cfg_LoLoLim) ,XIC(LoLoGate.Out) CMP(Val<=(Cfg_LoLoLim+Cfg_LoLoDB)) ]OTE(Wrk_LoLo);
				RC: "If the absolute value of the PV Rate of Change exceeds the High limit$N"
				    "for the On-Delay Time, issue the PV High Rate of Change Status.$N"
				    "If the absolute value of the PV Rate of Change falls back below the limit$N"
				    "(minus deadband) for the Off-Delay Time, clear the PV High Rate of Change Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [CMP(ABS(Val_RoC)>=Cfg_HiRoCLim) ,XIC(HiRoCGate.Out) CMP(ABS(Val_RoC)>(Cfg_HiRoCLim-Cfg_HiRoCDB)) ]OTE(Wrk_HiRoC);
				RC: "If the Analog Value exceeds the Reference value by more than the$N"
				    "High Deviation limit for the On-Delay Time, issue the PV High Deviation Status.$N"
				    "If the Analog Value Deviation falls back below the limit (minus deadband) for the$N"
				    "Off-Delay Time, clear the PV High Deviation Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [GRT(Val_Dev,Cfg_HiDevLim) ,XIC(HiDevGate.Out) CMP(Val_Dev>(Cfg_HiDevLim-Cfg_HiDevDB)) ]OTE(Wrk_HiDev);
				RC: "If the Analog Value falls below the Reference value by more than the$N"
				    "Low Deviation limit for the On-Delay Time, issue the PV Low Deviation Status.$N"
				    "If the Analog Value Deviation rises back above the limit (plus deadband) for the$N"
				    "Off-Delay Time, clear the PV Low Deviation Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####";
				N: [LES(Val_Dev,Cfg_LoDevLim) ,XIC(LoDevGate.Out) CMP(Val_Dev<(Cfg_LoDevLim+Cfg_LoDevDB)) ]OTE(Wrk_LoDev);
				RC: "If the selected input (real or simulated) is Infinite or NaN, skip the (raw) fail limit check.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: LBL(FailCheck)XIC(Wrk_InpInfNaN)JMP(Alarms);
				RC: "If the Analog Value rises above the Fail High Limit or falls below the$N"
				    "Fail Low Limit, raise the Fail Status Flag.$N"
				    "$N"
				    "If the Analog Value is back in range, that is, it is below the Fail High Limit (minus$N"
				    "deadband) and above the Fail Low Limit (plus deadband),$N"
				    "clear the Fail Status Flag.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed limits from Values to Configurations (removed Mode, Settings).  #####$N"
				    "#####  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: XIO(Err_Raw)[[GEQ(Wrk_RawPV,Cfg_FailHiLim) ,LEQ(Wrk_RawPV,Cfg_FailLoLim) ] ,XIC(FailGate.Out) [CMP(Wrk_RawPV>=(Cfg_FailHiLim-Cfg_FailDB)) ,CMP(Wrk_RawPV<=(Cfg_FailLoLim+Cfg_FailDB)) ] ]OTE(Wrk_Fail);
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "If the High-High Status Flag is set for a time that exceeds the On-Delay Time,$N"
				    "issue the PV High-High Status.$N"
				    "If the High-High Status Flag resets for a time that exceeds the Off-Delay Time, $N"
				    "clear the PV High-High Status.";
				N: LBL(Alarms)[XIC(Wrk_HiHi) OTE(Sts_HiHiCmp) ,P_Gate(HiHiGate) ,XIC(HiHiGate.Out) OTE(Sts_HiHi) ];
				RC: "If the High Status Flag is set for a time that exceeds the On-Delay Time,$N"
				    "issue the PV High Status.$N"
				    "If the High Status Flag resets for a time that exceeds the Off-Delay Time, $N"
				    "clear the PV High Status.";
				N: [XIC(Wrk_Hi) OTE(Sts_HiCmp) ,P_Gate(HiGate) ,XIC(HiGate.Out) OTE(Sts_Hi) ];
				RC: "If the Low Status Flag is set for a time that exceeds the On-Delay Time,$N"
				    "issue the PV Low Status.$N"
				    "If the Low Status Flag resets for a time that exceeds the Off-Delay Time, $N"
				    "clear the PV Low Status.";
				N: [XIC(Wrk_Lo) OTE(Sts_LoCmp) ,P_Gate(LoGate) ,XIC(LoGate.Out) OTE(Sts_Lo) ];
				RC: "If the Low-Low Status Flag is set for a time that exceeds the On-Delay Time,$N"
				    "issue the PV Low-Low Status.$N"
				    "If the Low-Low Status Flag resets for a time that exceeds the Off-Delay Time, $N"
				    "clear the PV Low-Low Status.";
				N: [XIC(Wrk_LoLo) OTE(Sts_LoLoCmp) ,P_Gate(LoLoGate) ,XIC(LoLoGate.Out) OTE(Sts_LoLo) ];
				RC: "If the absolute value of the PV Rate of Change exceeds the High limit$N"
				    "for the On-Delay Time, issue the PV High Rate of Change Status.$N"
				    "If the absolute value of the PV Rate of Change falls back below the limit$N"
				    "(minus deadband) for the Off-Delay Time, clear the PV High Rate of Change Status.";
				N: [XIC(Wrk_HiRoC) OTE(Sts_HiRoCCmp) ,P_Gate(HiRoCGate) ,XIC(HiRoCGate.Out) OTE(Sts_HiRoC) ];
				RC: "If the Analog Value exceeds the Reference value by more than the$N"
				    "High Deviation limit for the On-Delay Time, issue the PV High Deviation Status.$N"
				    "If the Analog Value Deviation falls back below the limit (minus deadband) for the$N"
				    "Off-Delay Time, clear the PV High Deviation Status.";
				N: [XIC(Wrk_HiDev) OTE(Sts_HiDevCmp) ,P_Gate(HiDevGate) ,XIC(HiDevGate.Out) OTE(Sts_HiDev) ];
				RC: "If the Analog Value falls below the Reference value by more than the$N"
				    "Low Deviation limit for the On-Delay Time, issue the PV Low Deviation Status.$N"
				    "If the Analog Value Deviation rises back above the limit (plus deadband) for the$N"
				    "Off-Delay Time, clear the PV Low Deviation Status.";
				N: [XIC(Wrk_LoDev) OTE(Sts_LoDevCmp) ,P_Gate(LoDevGate) ,XIC(LoDevGate.Out) OTE(Sts_LoDev) ];
				RC: "If the Fail Status Flag is set for a time that exceeds the On-Delay Time,$N"
				    "issue the PV Fail Status.$N"
				    "If the Fail Status Flag resets for a time that exceeds the Off-Delay Time, $N"
				    "clear the PV Fail Status, AND if the Bad PV input clears or the input is Siimulated,$N"
				    "AND if the value is NOT INF/NAN and there are no configuration errors,$N"
				    "clear the PV Fail Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed Sts_InpPV (it was simply inverse of Sts_SubstPV).  #####$N"
				    "#####  Changed PV Out of Range comparisons to use RAW (INPUT) PV, not scaled/filtered value (Val).  #####";
				N: [XIC(Wrk_Fail) OTE(Sts_FailCmp) ,P_Gate(FailGate) ,[XIC(FailGate.Out) ,XIO(Inp_Sim) [XIC(Inp_PVBad) ,XIC(Cfg_UseChanSrcQ) GEQ(Inp_PVSrcQ,32) ] ,XIC(Wrk_InpInfNaN) ,XIC(Err_Raw) ,XIC(Err_EU) ] OTE(Sts_Fail) ];
				RC: "If the PV is not substituted and it has a total Failure (rung above), or if it$N"
				    "is Infinite or Not a Number, flag it as BAD.$N"
				    "If the Uncertain input is set and the PV is not simulated or substituted,$N"
				    "flag it as UNCERTAIN.";
				N: XIO(Wrk_SubstPV)[XIO(Inp_Sim) [XIC(Inp_PVUncertain) ,XIC(Cfg_UseChanSrcQ) LIM(16,Inp_PVSrcQ,31) ] OTE(Sts_PVUncertain) ,XIC(Sts_Fail) OTE(Sts_PVBad) ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1), EXCEPT:$N"
				    "* If the Rate of Change function is configured to not exist, the high rate of change alarm cannot exist.$N"
				    "* If the Deviation function is configured to not exist, the high and low deviation alarms cannot exist.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [OTL(HiHi.PCfg_AllowExist) OTL(Hi.PCfg_AllowExist) OTL(Lo.PCfg_AllowExist) OTL(LoLo.PCfg_AllowExist) OTL(Fail.PCfg_AllowExist) ,XIC(Cfg_HasRoC) OTE(HiRoC.PCfg_AllowExist) ,XIC(Cfg_HasDev) OTE(HiDev.PCfg_AllowExist) OTE(LoDev.PCfg_AllowExist) ];
				RC: "Handle PV High-High Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(HiHi);
				RC: "Handle PV High Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(Hi);
				RC: "Handle PV Low Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(Lo);
				RC: "Handle PV Low-Low Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(LoLo);
				RC: "Handle PV High Rate of Change Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(HiRoC);
				RC: "Handle PV High Deviation from Reference Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(HiDev);
				RC: "Handle PV Low Deviation from Reference Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(LoDev);
				RC: "Handle Input Failure Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(Fail);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).";
				N: [XIC(HiHi.Sts_AlmInh) ,XIC(Hi.Sts_AlmInh) ,XIC(Lo.Sts_AlmInh) ,XIC(LoLo.Sts_AlmInh) ,XIC(HiRoC.Sts_AlmInh) ,XIC(HiDev.Sts_AlmInh) ,XIC(LoDev.Sts_AlmInh) ,XIC(Fail.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "Flag a Configuration Error if any Status On-Delay, Off-Delay$N"
				    "or Gate Delay timer preset is invalid$N"
				    "(and set timer to a default, non-faulting value).";
				N: [XIC(HiHiGate.Sts_Err) ,XIC(HiGate.Sts_Err) ,XIC(LoGate.Sts_Err) ,XIC(LoLoGate.Sts_Err) ,XIC(HiRoCGate.Sts_Err) ,XIC(HiDevGate.Sts_Err) ,XIC(LoDevGate.Sts_Err) ,XIC(FailGate.Sts_Err) ]OTE(Err_Timer);
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Bad Raw Scaling configs$N"
				    "Bad Engineering Units Scaling configs$N"
				    "Bad 1st-Order Filter configs$N"
				    "Bad Alarm Deadband configs$N"
				    "Bad Alarm Minimum Duration configs$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "";
				N: [XIC(Err_Raw) ,XIC(Err_EU) ,XIC(Err_Filt) ,XIC(Err_Timer) ,[XIC(HiHi.Sts_Err) ,XIC(Hi.Sts_Err) ,XIC(Lo.Sts_Err) ,XIC(LoLo.Sts_Err) ,XIC(HiRoC.Sts_Err) ,XIC(HiDev.Sts_Err) ,XIC(LoDev.Sts_Err) ,XIC(Fail.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "============================================================$N"
				    "ENUMERATED STATUS VALUES$N"
				    "============================================================$N"
				    "Source and Quality (Srcq) for Val_InpPV$N"
				    "Start with the Srcq from the Input Channel object if it$'s available.$N"
				    "Otherwise, start based on bad/uncertain input bits.$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Modified to correct precedence and value of Simulated PV.  #####$N"
				    "#####  V4.00.01  2018-08-29:  Modified handling of Simulated PV and scaling config errors.  #####";
				N: [XIO(Cfg_UseChanSrcQ) MOV(1,Wrk_SrcQ) ,XIC(Cfg_UseChanSrcQ) MOV(Inp_PVSrcQ,Wrk_SrcQ) ,XIC(Inp_PVUncertain) MOV(16,Wrk_SrcQ) ,XIC(Inp_PVBad) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(10,Wrk_SrcQ) ,[XIC(Wrk_InpInfNaN) ,XIC(Sts_FailCmp) ] [XIO(Cfg_UseChanSrcQ) ,XIC(Inp_Sim) ] MOV(32,Wrk_SrcQ) ,[XIC(Err_Raw) ,XIC(Err_EU) ] MOV(35,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality (SrcQ) for Val (primary value)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Modified to allow Substitute PV to control SrcQ despite alarm for failed PV.  #####$N"
				    "#####  V4.00.01  2018-08-29:  Modified handling of Substitute PV and Channel SrcQ.  #####";
				N: [MOV(SrcQ_IO,Wrk_SrcQ) ,XIC(Sts_SubstPV) MOV(18,Wrk_SrcQ) ,[XIC(Wrk_SelPVInfNaN) ,XIC(FailGate.Out) ] MOV(32,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ) ];
				RC: "This rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "20 = Lo$N"
				    "21 = Hi$N"
				    "22 = Lo Deviation$N"
				    "23 = Hi Deviation$N"
				    "24 = Lo-Lo$N"
				    "25 = Hi-Hi$N"
				    "26 = Hi Rate of Change$N"
				    "32 = Failed (I/O fault or out of range)$N"
				    "34 = Config Error";
				N: [CLR(Wrk_Fault) ,XIC(Sts_Lo) MOV(20,Wrk_Fault) ,XIC(Sts_Hi) MOV(21,Wrk_Fault) ,XIC(Sts_LoDev) MOV(22,Wrk_Fault) ,XIC(Sts_HiDev) MOV(23,Wrk_Fault) ,XIC(Sts_LoLo) MOV(24,Wrk_Fault) ,XIC(Sts_HiHi) MOV(25,Wrk_Fault) ,XIC(Sts_HiRoC) MOV(26,Wrk_Fault) ,[XIC(Sts_Fail) ,XIC(SrcQ.5) ] MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count including attached Channel object.  #####";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) OTU(Wrk_Notify.0) ,GRT(HiHi.Val_Notify,Wrk_Notify) MOV(HiHi.Val_Notify,Wrk_Notify) ,GRT(Hi.Val_Notify,Wrk_Notify) MOV(Hi.Val_Notify,Wrk_Notify) ,GRT(Lo.Val_Notify,Wrk_Notify) MOV(Lo.Val_Notify,Wrk_Notify) ,GRT(LoLo.Val_Notify,Wrk_Notify) MOV(LoLo.Val_Notify,Wrk_Notify) ,GRT(HiRoC.Val_Notify,Wrk_Notify) MOV(HiRoC.Val_Notify,Wrk_Notify) ,GRT(HiDev.Val_Notify,Wrk_Notify) MOV(HiDev.Val_Notify,Wrk_Notify) ,GRT(LoDev.Val_Notify,Wrk_Notify) MOV(LoDev.Val_Notify,Wrk_Notify) ,GRT(Fail.Val_Notify,Wrk_Notify) MOV(Fail.Val_Notify,Wrk_Notify) ,[XIC(HiHi.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(Hi.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(Lo.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(LoLo.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(HiRoC.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(HiDev.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(LoDev.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(Fail.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTL(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "Roll up the notification from the input Channel object.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count including attached PV (e.g., P_AIChan) object.  #####";
				N: [GRT(Inp_PVNotify,Wrk_Notify) MVM(Inp_PVNotify,2#1111_1110,Wrk_Notify) ,XIC(Inp_PVNotify.0) OTL(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_NotifyAll) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(HiHi.Sts_RdyAck) ,XIC(Hi.Sts_RdyAck) ,XIC(Lo.Sts_RdyAck) ,XIC(LoLo.Sts_RdyAck) ,XIC(HiRoC.Sts_RdyAck) ,XIC(HiDev.Sts_RdyAck) ,XIC(LoDev.Sts_RdyAck) ,XIC(Fail.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(HiHi.Sts_RdyReset) ,XIC(Hi.Sts_RdyReset) ,XIC(Lo.Sts_RdyReset) ,XIC(LoLo.Sts_RdyReset) ,XIC(HiRoC.Sts_RdyReset) ,XIC(HiDev.Sts_RdyReset) ,XIC(LoDev.Sts_RdyReset) ,XIC(Fail.Sts_RdyReset) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownership. clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "$QLurking$Q Operator Commands are cleared, as well as the Program Reset.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Removed rung for PSet_ / Val_Owner.  #####";
				N: OTU(MCmd_InpPV)OTU(MCmd_SubstPV)OTU(OCmd_Reset)OTU(OCmd_ResetAckAll)OTU(PCmd_Reset);
				RC: "Set up the filter initialization one-shot so filter will start from first valid value.";
				N: OTU(Wrk_ValidONS);
				RC: "Set up the PV Min/Max Capture function to $Qclear$Q on first scan,$N"
				    "thus capturing the first PV value as $Qmin$Q and $Qmax$Q";
				N: OTL(PCmd_ClearCapt);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_CmdSrc (Description := "Command Source",
	                                        Revision := "4.10",
	                                        RevisionExtension := ".01 Release",
	                                        RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                        Vendor := "Rockwell Automation",
	                                        ExecutePrescan := Yes,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := Yes,
	                                        CreatedDate := "2008-06-11T19:19:37.168Z",
	                                        CreatedBy := "Not Available",
	                                        EditedDate := "2020-10-30T17:37:57.872Z",
	                                        EditedBy := "AB-Rockwell-PC\AB-Rockwell",
	                                        SoftwareRevision := "v30.00",
	                                        AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis instruction provides selection of Command Source for a Device-$Nlevel object  (from highest priority to lowest):$N* Not Initialized$N* Hand (hardwired control, not controllable from I/O)$N* POoS (Programmed Out of Service) (EnableIn is false)$N* MOoS (Maintenance Out of Service)$N* Maint (Maintenance)$N* Ovrd (Override) (typically used for process overrides)$N* External (e.g.: local/field devices or upstream SCADA)$N* Prog (Program) (automated control, and default if Cfg_ProgDefault = 1)$N* Oper (Operator (manual control, and default if Cfg_ProgDefault = 0)$N$N(Program and Operator have the same priority.)$N$NThe current command source is shown with individual Status bits$Nand also a bit field (Sts_bSrc) and an enumeration (Sts_eSrc).$N$NWhen EnableIn is false, all source acquire/release and lock/unlock$NCommands are processed $Qbehind the scenes$Q, but the source$N$QProgram Out of Service$Q (POoS) is selected.  When EnableIn$Nbecomes true, the source selection takes into account the$NCommands received -- in other words, the command source$Nbecomes the one that would have been in effect had the EnableIn$NFalse / Out of Service condition never occurred.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* Added clear of internal $QExt$Q latch if Ext does not exist.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.01)$NSee 4.10 Release Notes for details.$N* Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.$N* Added XRdy_Acq, XRdy_Rel so XCmd_Acq, XCmd_Rel can be used on HMI.$N* Corrected parameter external access.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.00 Release Notes for details.$NMinor change to initialization, handling of level commands in EnableInFalse. $N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (P_Mode V3.5-01)$NSee 4.00 Release Notes for details.$N* Derived from P_Mode V3.5-01. P_Mode version history archived.$N* Added Out of Service (OoS), External (Ext); removed $QNoMode$Q$N* Added configuration for sources to exist, commands for $Qopposite$Q source.$N* Aligned ready bit naming with command bit names.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_Hand : BOOL (Description := "1=Acquire Hand (typ. hardwired local), 0=Release Hand",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Inp_Ovrd : BOOL (Description := "1=Acquire Override (higher priority program logic), 0=Release Override",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Inp_ExtInh : BOOL (Description := "1=Inhibit External Acquisition, 0=Allow External Acquisition",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 0);
			Cfg_HasOper : BOOL (Description := "1=Operator (unlocked) exists, can be selected",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1);
			Cfg_HasOperLocked : BOOL (Description := "1=Operator Locked exists, can be selected",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_HasProg : BOOL (Description := "1=Program (unlocked) exists, can be selected",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1);
			Cfg_HasProgLocked : BOOL (Description := "1=Program Locked exists, can be selected",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_HasExt : BOOL (Description := "1=External exists, can be selected",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Cfg_HasMaint : BOOL (Description := "1=Maintenance exists, can be selected",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1);
			Cfg_HasMOoS : BOOL (Description := "1=Maintenance Out of Service exists, can be selected",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1);
			Cfg_OvrdOverLock : BOOL (Description := "1=Override supersedes Prog/Oper Lock, 0=don$'t override Lock",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 1);
			Cfg_ExtOverLock : BOOL (Description := "1=External supersedes Prog/Oper Lock, 0=don$'t override Lock",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_ProgPwrUp : BOOL (Description := "1=Power Up to Prog, 0=Power Up to Oper",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_ProgNormal : BOOL (Description := "Normal Source: 1=Program if no requests; 0=Operator if no requests",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_PCmdPriority : BOOL (Description := "Command Priority: 1=Program Cmds Win; 0=Operator Cmds Win",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_PCmdProgAsLevel : BOOL (Description := "1=PCmd_Prog used as a Level (1=Prog, 0=Oper)",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 0);
			Cfg_PCmdLockAsLevel : BOOL (Description := "1=PCmd_Lock used as a Level (1=Lock, 0=Unlock)",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 0);
			Cfg_ExtAcqAsLevel : BOOL (Description := "1=XCmd_Acq used as Level (1=Acq, 0=Rel)",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			PCmd_Oper : BOOL (Description := "Program Command to select Operator (Prog to Oper)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			PCmd_Prog : BOOL (Description := "Program Command to select Program (Oper to Prog)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			PCmd_Lock : BOOL (Description := "Program Command to Lock Program (disallow Operator)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			PCmd_Unlock : BOOL (Description := "Program Command to Unlock Program (allow Oper to acquire)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			PCmd_Normal : BOOL (Description := "Program Command to select Normal (Oper or Prog)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			MCmd_OoS : BOOL (Description := "Maintenance Command to select Out Of Service",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			MCmd_IS : BOOL (Description := "Maintenance Command to select In Service",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			MCmd_Acq : BOOL (Description := "Maintenance Command to Acquire (Oper/Prog/Ovrd to Maint)",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			MCmd_Rel : BOOL (Description := "Maintenance Command to Release (Maint to Oper/Prog/Ovrd)",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_Acq : BOOL (Description := "External Command to Acquire",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_Rel : BOOL (Description := "External Command to Release",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			OCmd_Oper : BOOL (Description := "Operator Command to select Operator (Prog to Oper)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			OCmd_Prog : BOOL (Description := "Operator Command to select Program (Oper to Prog)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			OCmd_Lock : BOOL (Description := "Operator Command to Lock Operator (disallow Program)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			OCmd_Unlock : BOOL (Description := "Operator Command to Unlock Operator (allow Prog to acquire)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			OCmd_Normal : BOOL (Description := "Operator Command to select Normal (Oper or Prog)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Sts_eSrc : INT (Description := "Selection enum: .8=Ext, .7=OoS, .6=Oper, .5=Prog, .4=Ovrd, .3=Maint, .2=Hand, .1=Norm, .0=Lock",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_bSrc : INT (Description := "Active Selection bitmap (for HMI totem pole)",
			                    COMMENT.0 := "Hand",
			                    COMMENT.1 := "Programmable Out of Service",
			                    COMMENT.2 := "Maintenance Out of Service",
			                    COMMENT.3 := "Maintenance",
			                    COMMENT.4 := "Override",
			                    COMMENT.5 := "External",
			                    COMMENT.6 := "Program Locked",
			                    COMMENT.7 := "Program",
			                    COMMENT.8 := "Operator Locked",
			                    COMMENT.9 := "Operator",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_Hand : BOOL (Description := "1=Hand is selected (supersedes OoS, Maint, Ovrd, Ext, Prog, Oper)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_OoS : BOOL (Description := "1=Out of Service is selected (supersedes Maint, Ovrd, Ext, Prog, Oper)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_Maint : BOOL (Description := "1=Maintenance is selected (supersedes Ovrd, Ext, Prog, Oper)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Ovrd : BOOL (Description := "1=Override is selected (supersedes Ext, Prog, Oper)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_Ext : BOOL (Description := "1=External is selected (supersedes Prog, Oper)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_Prog : BOOL (Description := "1=Program is selected",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_ProgLocked : BOOL (Description := "1=Program is selected and Locked",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_Oper : BOOL (Description := "1=Operator is selected",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_OperLocked : BOOL (Description := "1=Operator is selected and Locked",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_ProgOperSel : BOOL (Description := "Prog/Oper selection (latch) state, 1=Program, 0=Operator",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Sts_ProgOperLock : BOOL (Description := "Prog/Oper lock (latch) state, 1=Locked, 0=Unlocked",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Sts_Normal : BOOL (Description := "1=Selection equals the Normal (Prog or Oper)",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_ProgReqInh : BOOL (Description := "1=Program request inhibited, cannot Get to Program from Current State",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_ExtReqInh : BOOL (Description := "1=External request inhibited",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_MAcqRcvd : BOOL (Description := "1=Maintenance Acquire command received this scan",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			MRdy_OoS : BOOL (Description := "1=Ready for MCmd_OoS (enables HMI button)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			MRdy_IS : BOOL (Description := "1=Ready for MCmd_IS (enables HMI button)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			MRdy_Acq : BOOL (Description := "1=Ready for MCmd_Acq (enables HMI button)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			MRdy_Rel : BOOL (Description := "1=Ready for MCmd_Rel (enables HMI button)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			XRdy_Acq : BOOL (Description := "1=Ready for XCmd_Acq (enables HMI button)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			XRdy_Rel : BOOL (Description := "1=Ready for XCmd_Rel (enables HMI button)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			ORdy_Oper : BOOL (Description := "1=Ready for OCmd_Oper (enables HMI button)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_Prog : BOOL (Description := "1=Ready for OCmd_Prog (enables HMI button)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_Lock : BOOL (Description := "1=Ready for OCmd_Lock (enables HMI button)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_Unlock : BOOL (Description := "1=Ready for OCmd_Unlock (enables HMI button)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			ORdy_Normal : BOOL (Description := "1=Ready for OCmd_Normal (enables HMI button)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			P_CmdSrc : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_ProgOperSel : BOOL (Description := "Internal Program (1) / Operator (0) selection result",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_ProgOperLock : BOOL (Description := "Internal Prog/Oper Lock (1) / Unlock (0) selection result",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_Prog : BOOL (Description := "Internal Program (1) / Operator (0) selection progress",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_MOoS : BOOL (Description := "Internal Maintenance Out of Service (1) / In Service (0) latch",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_Maint : BOOL (Description := "Internal Maintenance Acquire (1) / Release (0) latch",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_Lock : BOOL (Description := "Internal Prog/Oper Lock (1) / Unlock (0) selection progress",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_Init : BOOL (Description := "1=Initialized, 0=Initialization is required (e.g., powerup)",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_HasProgLocked : BOOL (Description := "Stored copy of Cfg_HasProgLocked",
			                            RADIX := Decimal,
			                            ExternalAccess := None,
			                            DefaultData := 0);
			Wrk_HasProg : BOOL (Description := "Stored copy of Cfg_HasProg",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_HasOperLocked : BOOL (Description := "Stored copy of Cfg_HasOperLocked",
			                            RADIX := Decimal,
			                            ExternalAccess := None,
			                            DefaultData := 0);
			Wrk_HasOper : BOOL (Description := "Stored copy of Cfg_HasOper",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			HMI_Type : STRING_12 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[8,'P_CmdSrc$00$00$00$00']");
			HMI_Lib : STRING_8 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00']");
			Wrk_Ext : BOOL (Description := "Internal latch of External selection (1=Ext acquired)",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Processes received Commands, but shows $QProgrammed Out of Service$Q")
				RC: "============================================================$N"
				    "P_CmdSrc:  EnableInFalse Handling$N"
				    "============================================================$N"
				    "When EnableIn is False, this Routine is scanned instead of the $QLogic$Q Routine.$N"
				    "All Commands are processed $Qbehind the scenes$Q, but the Command Source$N"
				    "is shown as $QOut of Service$Q.  When EnableIn becomes true, the AOI$N"
				    "takes into account the Commands received -- in other words, the Command$N"
				    "Source becomes the one that would have been in effect had the EnableIn$N"
				    "False / Out of Service condition never occurred.$N"
				    "============================================================$N"
				    "INITIALIZATION$N"
				    "============================================================$N"
				    "If initialization has been completed, skip the following few rungs.";
				N: XIO(S:FS)XIC(Wrk_Init)JMP(SkipInit);
				RC: "Initialization:  This rung clears any $Qlurking$Q commands and releases External source.$N"
				    "$N"
				    "#####  V4.00.01  2018-08-23:  Added PCmd_Prog, PCmd_Lock to commands cleared.  #####$N"
				    "#####  V4.10.00  2018-01-14:  Added XCmd_Acq, XCmd_Rel, Ext latch to items cleared.  #####";
				N: [OTU(MCmd_Acq) OTU(MCmd_Rel) OTU(MCmd_OoS) OTU(MCmd_IS) ,OTU(Inp_ExtInh) OTU(XCmd_Acq) OTU(XCmd_Rel) OTU(Wrk_Ext) ,OTU(PCmd_Prog) OTU(PCmd_Lock) ];
				N: LBL(SkipInit)[OTU(OCmd_Oper) OTU(OCmd_Prog) OTU(OCmd_Lock) OTU(OCmd_Unlock) OTU(OCmd_Normal) ,OTU(PCmd_Oper) OTU(PCmd_Unlock) OTU(PCmd_Normal) ];
				RC: "Initialization:  This rung processes the Configuration (.Cfg_) bits to be$N"
				    "sure the configuration is valid.  It sets the initial states of the$N"
				    "Program / Operator (selection) latch and the Prog/Oper Lock latch.$N"
				    "$N"
				    "#####  V4.00.01  2018-08-23:  Corrected selection of Normal when no HasOper/HasProg.  #####";
				N: [OTU(Wrk_Lock) OTU(Wrk_ProgOperLock) OTU(Wrk_Prog) OTU(Wrk_ProgOperSel) ,XIO(Cfg_HasOper) XIO(Cfg_HasProg) [XIC(Cfg_ProgPwrUp) OTL(Cfg_ProgNormal) OTL(Cfg_HasProg) ,XIO(Cfg_ProgPwrUp) OTU(Cfg_ProgNormal) OTL(Cfg_HasOper) ] ,XIO(Cfg_HasOper) XIO(Cfg_HasOperLocked) OTL(Cfg_ProgNormal) OTL(Cfg_ProgPwrUp) ,XIO(Cfg_HasProg) XIO(Cfg_HasProgLocked) OTU(Cfg_ProgNormal) OTU(Cfg_ProgPwrUp) ,[XIO(Cfg_ProgPwrUp) XIO(Cfg_HasOper) ,XIC(Cfg_ProgPwrUp) OTL(Wrk_ProgOperSel) OTL(Wrk_Prog) XIO(Cfg_HasProg) ] OTL(Wrk_ProgOperLock) OTL(Wrk_Lock) ];
				RC: "The Prog/Oper existence options are stored on initialization and enforced thereafter.$N"
				    "Changes must be made with controller in PROG mode to take effect.$N"
				    "-----  Initialization complete.  -----";
				N: [OTU(Wrk_HasOper) XIC(Cfg_HasOper) OTL(Wrk_HasOper) ,OTU(Wrk_HasOperLocked) XIC(Cfg_HasOperLocked) OTL(Wrk_HasOperLocked) ,OTU(Wrk_HasProg) XIC(Cfg_HasProg) OTL(Wrk_HasProg) ,OTU(Wrk_HasProgLocked) XIC(Cfg_HasProgLocked) OTL(Wrk_HasProgLocked) ,OTL(Wrk_Init) ];
				RC: "This rung restores the saved initial Program / Operator existence configurations,$N"
				    "overwriting any changes made while in controller RUN mode.";
				N: [XIC(Wrk_HasOper) OTL(Cfg_HasOper) ,XIO(Wrk_HasOper) OTU(Cfg_HasOper) ,XIC(Wrk_HasOperLocked) OTL(Cfg_HasOperLocked) ,XIO(Wrk_HasOperLocked) [OTU(Cfg_HasOperLocked) ,XIO(Wrk_HasOper) OTL(Cfg_ProgPwrUp) OTL(Cfg_ProgNormal) OTL(Cfg_PCmdPriority) ] ,XIC(Wrk_HasProg) OTL(Cfg_HasProg) ,[XIO(Wrk_HasProg) OTU(Cfg_HasProg) ,XIO(Wrk_HasOper) ] OTU(Cfg_PCmdProgAsLevel) ,XIC(Wrk_HasProgLocked) OTL(Cfg_HasProgLocked) ,XIO(Wrk_HasProgLocked) [[OTU(Cfg_HasProgLocked) ,OTU(Cfg_PCmdLockAsLevel) ] ,XIO(Wrk_HasProg) OTU(Cfg_ProgPwrUp) OTU(Cfg_ProgNormal) OTU(Cfg_PCmdPriority) ] ];
				RC: "Commands configured as level are preserved;$N"
				    "commands configured as edge are cleared.$N"
				    "$N"
				    "#####  V4.00.01  2018-08-23:  Added 2 rungs.  #####";
				N: XIO(Cfg_PCmdProgAsLevel)OTU(PCmd_Prog);
				N: XIO(Cfg_PCmdLockAsLevel)OTU(PCmd_Lock);
				RC: "Cfg_OvrdOverLock=0, Cfg_ExtOverLock=1 is an illegal combination.$N"
				    "$N"
				    "#####  V4.00.01  2018-08-23:  Added check for Cfg_HasExt.  #####";
				N: XIO(Cfg_OvrdOverLock)XIC(Cfg_HasExt)XIC(Cfg_ExtOverLock)OTL(Cfg_OvrdOverLock);
				RC: "Release External if:$N"
				    "* XCmd_Rel is received and External is EDGE;$N"
				    "* XCmd_Acq is cleared and External is LEVEL; or$N"
				    "* External is inhibited by logic.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Added clear of internal Ext latch if Ext does not exist.  #####";
				N: [XIC(XCmd_Rel) OTU(XCmd_Rel) XIO(Cfg_ExtAcqAsLevel) ,XIC(Cfg_HasExt) XIC(Cfg_ExtAcqAsLevel) XIO(XCmd_Acq) ,XIC(Inp_ExtInh) ,XIO(Cfg_HasExt) ]OTU(Wrk_Ext);
				RC: "If an External Acquire command is received:$N"
				    "* If External is configured to exist and it is NOT inhibited, acquire External;$N"
				    "* If the External commands are configured as EDGE, clear the command.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####";
				N: XIC(XCmd_Acq)[XIC(Cfg_HasExt) XIO(Inp_ExtInh) OTL(Wrk_Ext) ,XIO(Cfg_ExtAcqAsLevel) OTU(XCmd_Acq) ];
				RC: "If a Maintenance Release command is received, or if Maintenance is configured$N"
				    "to not exist, release Maintenance.";
				N: [XIC(MCmd_Rel) ,XIO(Cfg_HasMaint) ]OTU(MCmd_Rel)OTU(Wrk_Maint);
				RC: "If a Maintenance Acquire command is received, set the $QMaintenance Acquire$N"
				    "Received$Q status bit.  If Maintenance is configured to exist, go to Maintenance.";
				N: XIC(MCmd_Acq)OTU(MCmd_Acq)OTE(Sts_MAcqRcvd)XIC(Cfg_HasMaint)OTL(Wrk_Maint);
				RC: "If a Maintenance In Service command is received, or if Maintenance Out of Service$N"
				    "is configured to not exist, place In Service (release MOoS).";
				N: [XIC(MCmd_IS) ,XIO(Cfg_HasMOoS) ]OTU(MCmd_IS)OTU(Wrk_MOoS);
				RC: "If a Maintenance Out of Service command is received, and if Maintenance Out of Service$N"
				    "is configured to exist, place Out of Service (acquire MOoS).";
				N: XIC(MCmd_OoS)OTU(MCmd_OoS)XIC(Cfg_HasMOoS)OTL(Wrk_MOoS);
				RC: "============================================================$N"
				    "MAINTENANCE, EXTERNAL AND OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "This rung generates the $QORdy_$Q, $QMRdy_$Q and $QXRdy_$Q bits that signify to the$N"
				    "HMI that the corresponding command should $Qdo$Q something$N"
				    "and the command button should be enabled on the display.$N"
				    "$N"
				    "NOTE ON MAINTENANCE ACQUIRE: Ready for MCmd_Acq if Maintenance$N"
				    "is allowed and the internal Maintenance latch is NOT set.  However,$N"
				    "we need to display Ready even if latch IS set so that Sts_MAcqRcvd$N"
				    "can blink to reset an external Maintenance expiration timer!!!$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XRdy_Acq, XRdy_Rel so External Acq/Rel can be used on HMI .  #####";
				N: [XIC(Cfg_HasMaint) [OTE(MRdy_Acq) ,XIC(Wrk_Maint) OTE(MRdy_Rel) ] ,XIC(Cfg_HasMOoS) [XIC(Wrk_MOoS) OTE(MRdy_IS) ,XIO(Wrk_MOoS) OTE(MRdy_OoS) ] ,XIC(Cfg_HasExt) XIO(Cfg_ExtAcqAsLevel) [XIC(Wrk_Ext) OTE(XRdy_Rel) ,XIO(Wrk_Ext) XIO(Inp_ExtInh) OTE(XRdy_Acq) ] ,OTU(ORdy_Lock) OTU(ORdy_Unlock) OTU(ORdy_Oper) OTU(ORdy_Prog) OTU(ORdy_Normal) ];
				RC: "============================================================$N"
				    "STATUS AND ENUMERATED STATUS$N"
				    "============================================================$N"
				    "This rung provides the various Status bits and Enumerated Status value$N"
				    "for the valid selections when on a false rung, as follows:$N"
				    "$N"
				    "HAND:  Sts_Hand if Inp_Hand is set$N"
				    "POoS: Sts_OOS if Inp_Hand is NOT set.$N"
				    "$N"
				    "Enum:$N"
				    "= 4  if HAND$N"
				    "= 129 if POoS";
				N: [OTU(Sts_Maint) OTU(Sts_Ovrd) OTU(Sts_Ext) OTU(Sts_ProgLocked) OTU(Sts_Prog) OTU(Sts_OperLocked) OTU(Sts_Oper) ,OTU(Sts_eSrc.1) OTU(Sts_eSrc.3) OTU(Sts_eSrc.4) OTU(Sts_eSrc.5) OTU(Sts_eSrc.6) OTU(Sts_eSrc.8) ,XIC(Inp_Hand) OTE(Sts_Hand) OTE(Sts_eSrc.2) ,XIO(Inp_Hand) OTE(Sts_OoS) OTE(Sts_eSrc.7) OTE(Sts_eSrc.0) ];
				RC: "Adjust O/P state based on level and power up configurations and input conditions$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Modified handling of PCmd_Lock, PCmd_Prog when configured as LEVEL.  #####";
				N: [XIC(Wrk_Prog) ,XIO(Wrk_Lock) ][XIC(Cfg_PCmdLockAsLevel) [XIO(PCmd_Lock) OTU(Wrk_Lock) OTU(Wrk_Prog) XIC(Cfg_HasProg) XIC(Cfg_ProgPwrUp) ,XIC(PCmd_Lock) OTL(Wrk_Lock) ] OTL(Wrk_Prog) ,XIC(Cfg_PCmdProgAsLevel) XIO(Wrk_Lock) [XIO(PCmd_Prog) OTU(Wrk_Prog) ,XIC(PCmd_Prog) OTL(Wrk_Prog) ] ];
				RC: "============================================================$N"
				    "STATUS AND ENUMERATED STATUS GENERATION$N"
				    "============================================================$N"
				    "This rung provides bitmapped status for use on the HMI $QTotem Pole$Q object:$N"
				    ".0 = Hand$N"
				    ".1 = Programmed Out of Service (always set here)$N"
				    ".2 = Maintenance Out of Service$N"
				    ".3 = Maintenance$N"
				    ".4= Override$N"
				    ".5 = External$N"
				    ".6 = Program Locked$N"
				    ".7 = Program$N"
				    ".8 = Operator Locked$N"
				    ".9 = Operator$N"
				    "In addition, the final selections of the Program / Operator selection latch$N"
				    "and the Prog/Oper lock latch are captured for use next scan.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####";
				N: [XIC(Inp_Hand) OTE(Sts_bSrc.0) ,OTL(Sts_bSrc.1) ,XIC(Wrk_MOoS) OTE(Sts_bSrc.2) ,XIC(Wrk_Maint) OTE(Sts_bSrc.3) ,XIC(Inp_Ovrd) [XIC(Cfg_OvrdOverLock) ,XIO(Cfg_OvrdOverLock) [XIO(Wrk_Lock) ,XIC(Sts_bSrc.4) ] ] OTE(Sts_bSrc.4) ,XIC(Wrk_Ext) XIC(Cfg_HasExt) XIO(Inp_ExtInh) OTE(Sts_bSrc.5) ,XIC(Wrk_Prog) OTL(Wrk_ProgOperSel) [XIC(Wrk_Lock) OTE(Sts_bSrc.6) ,XIO(Wrk_Lock) OTE(Sts_bSrc.7) ] ,XIO(Wrk_Prog) OTU(Wrk_ProgOperSel) [XIC(Wrk_Lock) OTE(Sts_bSrc.8) ,XIO(Wrk_Lock) OTE(Sts_bSrc.9) ] ,XIC(Wrk_Lock) OTL(Wrk_ProgOperLock) ,XIO(Wrk_Lock) OTU(Wrk_ProgOperLock) ];
				RC: "The final states of the internal Program / Operator selection latch and the$N"
				    "Prog/Oper Lock latch are made available as Status bits.";
				N: [XIC(Wrk_ProgOperSel) OTE(Sts_ProgOperSel) ,XIC(Wrk_ProgOperLock) OTE(Sts_ProgOperLock) ];
				RC: "Because the final selection is either Hand or Programmed Out of Service,$N"
				    "the selection is not the normal one (Program or Operator) and it is not possible$N"
				    "to command the selection to Program from here.";
				N: OTU(Sts_Normal)OTL(Sts_ProgReqInh)OTL(Sts_ExtReqInh);
		END_ROUTINE

		ROUTINE Logic (Description := "Selects Hand, OOS, Maint, Ovrd, Ext, Oper, Prog based on Inputs and Commands")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_CmdSrc:  PROCESS -- COMMAND SOURCE SELECTOR$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-16:  See V4.10.xx Release Notes for details.$N"
				    "V4.00.00  2018-03-15:  New instruction for V4.0 Library of Process Objects.$N"
				    "(Derived from P_Mode V3.5-01. P_Mode version history archived.)$N"
				    "Added Out of Service (OoS), External (Ext); removed $QNoMode$Q$N"
				    "Added configuration for sources to exist, commands for $Qopposite$Q source.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "V4.00.01  2018-08-23:  Minor change to initialization, handling of level commands in EIF. $N"
				    "V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.$N"
				    "Added XRdy_Acq, XRdy_Rel so XCmd_Acq, XCmd_Rel can be used on HMI.$N"
				    "Corrected parameter external access.$N"
				    "V4.10.01  2019-10-16:  Added clear of internal $QExt$Q latch if Ext does not exist.$N"
				    "============================================================$N"
				    "This instruction provides selection of Command Source for a$N"
				    "Device-level object  (from highest priority to lowest):$N"
				    "* Not Initialized$N"
				    "* Hand (hardwired control, not controllable from I/O)$N"
				    "* POoS (programmed Out of Service) (EnableIn is false)$N"
				    "* MOoS (maintenance Out of Service)$N"
				    "* Maint (Maintenance)$N"
				    "*  Ovrd (Override) (typically used for process overrides)$N"
				    "* External (e.g.: field pilot controls or upstream SCADA)$N"
				    "*  Prog  (Program) (automated control, and default if Cfg_ProgNormal = 1)$N"
				    "*  Oper (Operator (manual control, and default if Cfg_ProgNormal = 0)$N"
				    "$N"
				    "The current command source is shown with individual Status bits$N"
				    "and also a bit field (Sts_bSrc) and an enumeration (Sts_eSrc).$N"
				    "$N"
				    "============================================================$N"
				    "INITIALIZATION$N"
				    "============================================================$N"
				    "If initialization has been completed, skip the following few rungs.";
				N: XIO(S:FS)XIC(Wrk_Init)JMP(SkipInit);
				RC: "Initialization:  This rung clears any $Qlurking$Q commands.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####";
				N: [OTU(PCmd_Prog) OTU(PCmd_Oper) OTU(PCmd_Lock) OTU(PCmd_Unlock) OTU(PCmd_Normal) ,OTU(MCmd_Acq) OTU(MCmd_Rel) OTU(MCmd_OoS) OTU(MCmd_IS) ,OTU(OCmd_Oper) OTU(OCmd_Prog) OTU(OCmd_Lock) OTU(OCmd_Unlock) OTU(OCmd_Normal) ,OTU(Wrk_Ext) OTU(Inp_ExtInh) OTU(XCmd_Acq) OTU(XCmd_Rel) ];
				RC: "Initialization:  This rung processes the Configuration (.Cfg_) bits to be$N"
				    "sure the configuration is valid.  It sets the initial states of the$N"
				    "Program / Operator (selection) latch and the Prog/Oper Lock latch.$N"
				    "$N"
				    "#####  V4.00.01  2018-08-23:  Selection of Normal when HasOper/HasProg both 0.  #####";
				N: [OTU(Wrk_Lock) OTU(Wrk_ProgOperLock) OTU(Wrk_Prog) OTU(Wrk_ProgOperSel) ,XIO(Cfg_HasOper) XIO(Cfg_HasProg) [XIC(Cfg_ProgPwrUp) OTL(Cfg_ProgNormal) OTL(Cfg_HasProg) ,XIO(Cfg_ProgPwrUp) OTU(Cfg_ProgNormal) OTL(Cfg_HasOper) ] ,XIO(Cfg_HasOper) XIO(Cfg_HasOperLocked) OTL(Cfg_ProgNormal) OTL(Cfg_ProgPwrUp) ,XIO(Cfg_HasProg) XIO(Cfg_HasProgLocked) OTU(Cfg_ProgNormal) OTU(Cfg_ProgPwrUp) ,[XIO(Cfg_ProgPwrUp) XIO(Cfg_HasOper) ,XIC(Cfg_ProgPwrUp) OTL(Wrk_ProgOperSel) OTL(Wrk_Prog) XIO(Cfg_HasProg) ] OTL(Wrk_ProgOperLock) OTL(Wrk_Lock) ];
				RC: "The Prog/Oper existence options are stored on initialization and enforced thereafter.$N"
				    "Changes must be made with controller in PROG mode to take effect.$N"
				    "-----  Initialization complete.  -----";
				N: [OTU(Wrk_HasOper) XIC(Cfg_HasOper) OTL(Wrk_HasOper) ,OTU(Wrk_HasOperLocked) XIC(Cfg_HasOperLocked) OTL(Wrk_HasOperLocked) ,OTU(Wrk_HasProg) XIC(Cfg_HasProg) OTL(Wrk_HasProg) ,OTU(Wrk_HasProgLocked) XIC(Cfg_HasProgLocked) OTL(Wrk_HasProgLocked) ,OTL(Wrk_Init) ];
				RC: "This rung restores the saved initial Program / Operator existence configurations,$N"
				    "overwriting any changes made while in controller RUN mode.";
				N: LBL(SkipInit)[XIC(Wrk_HasOper) OTL(Cfg_HasOper) ,XIO(Wrk_HasOper) OTU(Cfg_HasOper) ,XIC(Wrk_HasOperLocked) OTL(Cfg_HasOperLocked) ,XIO(Wrk_HasOperLocked) [OTU(Cfg_HasOperLocked) ,XIO(Wrk_HasOper) OTL(Cfg_ProgPwrUp) OTL(Cfg_ProgNormal) OTL(Cfg_PCmdPriority) ] ,XIC(Wrk_HasProg) OTL(Cfg_HasProg) ,[XIO(Wrk_HasProg) OTU(Cfg_HasProg) ,XIO(Wrk_HasOper) ] OTU(Cfg_PCmdProgAsLevel) ,XIC(Wrk_HasProgLocked) OTL(Cfg_HasProgLocked) ,XIO(Wrk_HasProgLocked) [[OTU(Cfg_HasProgLocked) ,OTU(Cfg_PCmdLockAsLevel) ] ,XIO(Wrk_HasProg) OTU(Cfg_ProgPwrUp) OTU(Cfg_ProgNormal) OTU(Cfg_PCmdPriority) ] ];
				RC: "Cfg_OvrdOverLock=0, Cfg_RemOverLock=1 is an illegal combination";
				N: XIO(Cfg_OvrdOverLock)XIC(Cfg_HasExt)XIC(Cfg_ExtOverLock)OTL(Cfg_OvrdOverLock);
				RC: "Release External if:$N"
				    "* XCmd_Rel is received and External is EDGE;$N"
				    "* XCmd_Acq is cleared and External is LEVEL; or$N"
				    "* External is inhibited by logic.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Added clear of internal Ext latch if Ext does not exist.  #####";
				N: [XIC(XCmd_Rel) OTU(XCmd_Rel) XIO(Cfg_ExtAcqAsLevel) ,XIC(Cfg_HasExt) XIC(Cfg_ExtAcqAsLevel) XIO(XCmd_Acq) ,XIC(Inp_ExtInh) ,XIO(Cfg_HasExt) ]OTU(Wrk_Ext);
				RC: "If an External Acquire command is received:$N"
				    "* If External is configured to exist and it is NOT inhibited, acquire External;$N"
				    "* If the External commands are configured as EDGE, clear the command.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####";
				N: XIC(XCmd_Acq)[XIC(Cfg_HasExt) XIO(Inp_ExtInh) OTL(Wrk_Ext) ,XIO(Cfg_ExtAcqAsLevel) OTU(XCmd_Acq) ];
				RC: "If a Maintenance Release command is received, or if Maintenance is configured$N"
				    "to not exist, release Maintenance.";
				N: [XIC(MCmd_Rel) ,XIO(Cfg_HasMaint) ]OTU(MCmd_Rel)OTU(Wrk_Maint);
				RC: "If a Maintenance Acquire command is received, set the $QMaintenance Acquire$N"
				    "Received$Q status bit.  If Maintenance is configured to exist, go to Maintenance.";
				N: XIC(MCmd_Acq)OTU(MCmd_Acq)OTE(Sts_MAcqRcvd)XIC(Cfg_HasMaint)OTL(Wrk_Maint);
				RC: "If a Maintenance In Service command is received, or if Maintenance Out of Service$N"
				    "is configured to not exist, place In Service (release MOoS).";
				N: [XIC(MCmd_IS) ,XIO(Cfg_HasMOoS) ]OTU(MCmd_IS)OTU(Wrk_MOoS);
				RC: "If a Maintenance Out of Service command is received, and if Maintenance Out of Service$N"
				    "is configured to exist, place Out of Service (acquire MOoS).";
				N: XIC(MCmd_OoS)OTU(MCmd_OoS)XIC(Cfg_HasMOoS)OTL(Wrk_MOoS);
				RC: "Change PCmd_Normal or OCmd_Normal to the appropriate Prog or Oper command.";
				N: [XIC(OCmd_Normal) OTU(OCmd_Normal) [XIO(Cfg_ProgNormal) XIC(Wrk_ProgOperSel) OTL(OCmd_Oper) ,XIC(Cfg_ProgNormal) XIO(Wrk_ProgOperSel) OTL(OCmd_Prog) ] ,XIC(PCmd_Normal) OTU(PCmd_Normal) [XIO(Cfg_ProgNormal) XIC(Wrk_ProgOperSel) OTL(PCmd_Oper) ,XIC(Cfg_ProgNormal) XIO(Wrk_ProgOperSel) [XIO(Cfg_PCmdProgAsLevel) OTL(PCmd_Prog) ,XIC(Cfg_PCmdProgAsLevel) XIO(Cfg_PCmdLockAsLevel) OTL(PCmd_Lock) ] ] ];
				N: XIO(OCmd_Oper)XIO(OCmd_Prog)XIO(OCmd_Lock)XIO(OCmd_Unlock)XIO(PCmd_Oper)XIO(PCmd_Unlock)[XIO(PCmd_Prog) ,XIC(Cfg_PCmdProgAsLevel) ][XIO(PCmd_Lock) ,XIC(Cfg_PCmdLockAsLevel) XIC(PCmd_Lock) XIC(Wrk_Lock) ]JMP(AfterOPCmnds);
				RC: "If a Program Unlock command is received, and if Program is selected,$N"
				    "unlock.  Then, if Program exists, keep in Program; if not, go to Operator.";
				N: XIC(PCmd_Unlock)OTU(PCmd_Unlock)XIC(Wrk_ProgOperSel)OTU(Wrk_Lock)[XIC(Cfg_HasProg) OTL(Wrk_Prog) ,XIO(Cfg_HasProg) OTU(Wrk_Prog) ];
				RC: "If an Operator Unlock command is received and if Operator is selected, unlock.$N"
				    "Then, if Oper Unlocked exists, keep in Operator; if not, go to Program.";
				N: XIC(OCmd_Unlock)OTU(OCmd_Unlock)XIO(Wrk_ProgOperSel)OTU(Wrk_Lock)[XIC(Cfg_HasOper) OTU(Wrk_Prog) ,[XIO(Cfg_HasOper) ,XIC(Cfg_PCmdProgAsLevel) XIC(PCmd_Prog) ,XIC(Cfg_PCmdLockAsLevel) XIC(PCmd_Lock) OTL(Wrk_Lock) ] OTL(Wrk_Prog) ];
				RC: "PCmd_Oper when Operator Commands have priority over Program Commands:$N"
				    "If Operator (unlocked) exists, go there.  If Operator (unlocked) does not$N"
				    "exist, but Operator Locked exists, then go there.$N"
				    "";
				N: XIC(PCmd_Oper)[XIO(OCmd_Prog) ,XIC(Cfg_PCmdPriority) ]XIC(Wrk_ProgOperSel)[XIO(Cfg_PCmdLockAsLevel) ,XIO(PCmd_Lock) ][XIC(Cfg_HasOper) [XIO(Cfg_PCmdProgAsLevel) ,XIO(PCmd_Prog) ] OTU(Wrk_Lock) ,XIO(Cfg_HasOper) XIC(Cfg_HasOperLocked) OTL(Wrk_Lock) ]OTU(Wrk_Prog);
				RC: "If an Operator Command to go to Program is received, if Program (unlocked) exits, go there.$N"
				    "If Program (unlocked) does NOT exist, but Program Locked exits, go there so long as$N"
				    "a PCmd_Lock as level is not low, so as to take us OUT of Program Locked.";
				N: XIC(OCmd_Prog)[XIO(PCmd_Oper) ,XIO(Cfg_PCmdPriority) ]XIO(Wrk_ProgOperSel)[XIC(Cfg_HasProg) [XIO(Cfg_PCmdProgAsLevel) ,XIC(PCmd_Prog) ] OTU(Wrk_Lock) ,XIC(Cfg_HasProgLocked) [XIO(Cfg_HasProg) XIO(Cfg_PCmdLockAsLevel) ,XIC(Cfg_PCmdLockAsLevel) XIC(PCmd_Lock) ,XIC(Cfg_PCmdProgAsLevel) XIO(PCmd_Prog) ] OTL(Wrk_Lock) ]OTL(Wrk_Prog);
				RC: "Clear both processed commands for next scan.";
				N: OTU(PCmd_Oper)OTU(OCmd_Prog);
				RC: "If a Program Command to go to Program is received, if NOT locked or if in Program Locked,$N"
				    "then if Program (unlocked) exits, go there; if Program (unlocked) does NOT exist, but$N"
				    "Program Locked exits, go there so long as a PCmd_Lock as level is not low,$N"
				    "so as to take us OUT of Program Locked.";
				N: XIC(PCmd_Prog)[XIC(Cfg_PCmdPriority) ,XIO(OCmd_Oper) ][XIO(Wrk_ProgOperLock) ,XIC(Wrk_ProgOperSel) XIO(Cfg_PCmdProgAsLevel) ][XIC(Cfg_HasProg) OTU(Wrk_Lock) ,XIO(Cfg_HasProg) XIC(Cfg_HasProgLocked) OTL(Wrk_Lock) ]OTL(Wrk_Prog);
				RC: "OCmd_Oper when Program Commands have priority over Operator Commands:$N"
				    "If NOT locked, or if Operator and Locked, then if Operator (unlocked) exists, go there.$N"
				    "if Operator (unlocked) does NOT exist, but Operator Locked exists, then go there.$N"
				    "";
				N: XIC(OCmd_Oper)[XIO(Cfg_PCmdPriority) ,XIO(PCmd_Prog) ][XIO(Wrk_ProgOperLock) ,XIO(Wrk_ProgOperSel) ][XIO(Cfg_PCmdLockAsLevel) ,XIO(PCmd_Lock) ][XIC(Cfg_HasOper) OTU(Wrk_Lock) ,XIC(Cfg_HasOperLocked) [XIO(Cfg_HasOper) ,XIC(Cfg_PCmdProgAsLevel) XIC(PCmd_Prog) ] OTL(Wrk_Lock) ]OTU(Wrk_Prog);
				RC: "Clear both processed commands for next scan. Do not clear PCmd_Prog if Cfg_PCmdProgAsLevel is set.";
				N: OTU(OCmd_Oper)XIO(Cfg_PCmdProgAsLevel)OTU(PCmd_Prog);
				RC: "OCmd_Lock when Program Commands have priority over Operator Commands:$N"
				    "If in Operator or not Locked, go to Operator Locked, but next rung wins.$N"
				    "";
				N: XIC(OCmd_Lock)[XIO(Cfg_PCmdPriority) ,XIO(PCmd_Lock) ]XIC(Cfg_HasOperLocked)[XIO(Wrk_ProgOperSel) ,XIO(Wrk_ProgOperLock) ]OTU(Wrk_Prog)OTL(Wrk_Lock);
				RC: "If a Program Lock Command is received, if Program Locked exists and in Program$N"
				    "or NOT Locked, go to Program Locked.";
				N: XIC(PCmd_Lock)[XIC(Cfg_PCmdPriority) ,XIO(OCmd_Lock) ]XIC(Cfg_HasProgLocked)[XIC(Wrk_ProgOperSel) ,XIO(Wrk_ProgOperLock) ]OTL(Wrk_Prog)OTL(Wrk_Lock);
				RC: "Clear both processed commands for next scan. Do not clear PCmd_Lock is Cfg_PCmdLockAsLevel is set.";
				N: OTU(OCmd_Lock)XIO(Cfg_PCmdLockAsLevel)OTU(PCmd_Lock);
				RC: "Level signal state correction. Verifying signal low final states.";
				N: LBL(AfterOPCmnds)XIC(Wrk_Prog)[XIC(Cfg_PCmdProgAsLevel) XIO(Wrk_Lock) XIO(PCmd_Prog) ,XIC(Cfg_PCmdLockAsLevel) XIO(PCmd_Lock) XIC(Wrk_Lock) OTU(Wrk_Lock) [XIC(Cfg_PCmdProgAsLevel) XIO(PCmd_Prog) ,XIO(Cfg_HasProg) ] ]OTU(Wrk_Prog);
				RC: "Level signal state correction. Verifying signal high final states.";
				N: XIC(Cfg_PCmdProgAsLevel)XIC(PCmd_Prog)XIO(Wrk_Prog)XIO(Wrk_Lock)OTL(Wrk_Prog);
				RC: "============================================================$N"
				    "MAINTENANCE AND OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "This rung generates the $QORdy_$Q and $QMRdy_$Q bits that signify to the$N"
				    "HMI that the corresponding command should $Qdo$Q something$N"
				    "and the command button should be enabled on the display.$N"
				    "$N"
				    "NOTE ON MAINTENANCE ACQUIRE: Ready for MCmd_Acq if Maintenance$N"
				    "is allowed and the internal Maintenance latch is NOT set.  However,$N"
				    "we need to display Ready even if latch IS set so that Sts_MAcqRcvd$N"
				    "can blink to reset an external Maintenance expiration timer!!!$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XRdy_Acq, XRdy_Rel so External Acq/Rel can be used on HMI .  #####";
				N: [XIC(Cfg_HasMaint) [OTE(MRdy_Acq) ,XIC(Wrk_Maint) OTE(MRdy_Rel) ] ,XIC(Cfg_HasMOoS) [XIC(Wrk_MOoS) OTE(MRdy_IS) ,XIO(Wrk_MOoS) OTE(MRdy_OoS) ] ,XIC(Cfg_HasExt) XIO(Cfg_ExtAcqAsLevel) [XIC(Wrk_Ext) OTE(XRdy_Rel) ,XIO(Wrk_Ext) XIO(Inp_ExtInh) OTE(XRdy_Acq) ] ,XIO(Wrk_Lock) XIC(Cfg_HasOperLocked) OTE(ORdy_Lock) ,[XIO(Wrk_Lock) XIC(Wrk_Prog) [XIC(Cfg_HasOper) XIO(Cfg_PCmdProgAsLevel) ,XIC(Cfg_HasOperLocked) [XIO(Cfg_PCmdProgAsLevel) ,XIC(PCmd_Prog) XIO(Cfg_PCmdPriority) ] ] ,XIC(Wrk_Lock) XIO(Wrk_Prog) XIC(Cfg_HasOper) [XIO(Cfg_PCmdLockAsLevel) ,XIO(PCmd_Lock) ] [XIO(Cfg_PCmdProgAsLevel) ,XIO(PCmd_Prog) ] ] OTE(ORdy_Oper) ,XIO(Wrk_Prog) [XIC(Wrk_Lock) OTE(ORdy_Unlock) ,[XIC(Cfg_HasProg) [XIO(Cfg_PCmdProgAsLevel) ,XIC(PCmd_Prog) ] ,XIC(Cfg_HasProgLocked) [XIO(Cfg_PCmdLockAsLevel) ,XIC(PCmd_Lock) ] ] OTE(ORdy_Prog) ] ,[XIO(Cfg_ProgNormal) XIC(ORdy_Oper) XIC(Wrk_Prog) ,XIC(Cfg_ProgNormal) XIC(ORdy_Prog) XIO(Wrk_Prog) ] OTE(ORdy_Normal) ];
				RC: "============================================================$N"
				    "STATUS AND ENUMERATED STATUS GENERATION$N"
				    "============================================================$N"
				    "This rung provides bitmapped status for use on the HMI $QTotem Pole$Q object:$N"
				    ".0 = Hand$N"
				    ".1 = Programmed Out of Service (always cleared here)$N"
				    ".2 = Maintenance Out of Service$N"
				    ".3 = Maintenance$N"
				    ".4= Override$N"
				    ".5 = External$N"
				    ".6 = Program Locked$N"
				    ".7 = Program$N"
				    ".8 = Operator Locked$N"
				    ".9 = Operator$N"
				    "In addition, the final selections of the Program / Operator selection latch$N"
				    "and the Prog/Oper lock latch are captured for use next scan.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added XCmd_Acq, XCmd_Rel, Cfg_ExtAcqAsLevel, removed Inp_Ext.  #####";
				N: [XIC(Inp_Hand) OTE(Sts_bSrc.0) ,OTU(Sts_bSrc.1) ,XIC(Wrk_MOoS) OTE(Sts_bSrc.2) ,XIC(Wrk_Maint) OTE(Sts_bSrc.3) ,XIC(Inp_Ovrd) [XIC(Cfg_OvrdOverLock) ,XIO(Cfg_OvrdOverLock) [XIO(Wrk_Lock) ,XIC(Sts_bSrc.4) ] ] OTE(Sts_bSrc.4) ,XIC(Wrk_Ext) XIC(Cfg_HasExt) XIO(Inp_ExtInh) OTE(Sts_bSrc.5) ,XIC(Wrk_Prog) OTL(Wrk_ProgOperSel) [XIC(Wrk_Lock) OTE(Sts_bSrc.6) ,XIO(Wrk_Lock) OTE(Sts_bSrc.7) ] ,XIO(Wrk_Prog) OTU(Wrk_ProgOperSel) [XIC(Wrk_Lock) OTE(Sts_bSrc.8) ,XIO(Wrk_Lock) OTE(Sts_bSrc.9) ] ,XIC(Wrk_Lock) OTL(Wrk_ProgOperLock) ,XIO(Wrk_Lock) OTU(Wrk_ProgOperLock) ];
				RC: "This rung and the next determine the final Command Source based on the$N"
				    "states of the inputs and internal working bits.  Individual Command Source$N"
				    "Status bits and an enumerated Status value are generated.$N"
				    "$N"
				    "Between the internal working bits used above and the rules implemented here,$N"
				    "outside objects cannot manipulate the state of this object by setting/clearing its Status bits.$N"
				    "$N"
				    "Public Status is generated for:$N"
				    "* Hand 4$N"
				    "* Out of Service 129$N"
				    "* Maintenance 8$N"
				    "* Override 16$N"
				    "* External 256$N"
				    "* Program 32$N"
				    "* Operator 64$N"
				    "* Program / Operator Lock status 33/65$N"
				    "* Command Source = Normal 34/66";
				N: XIC(Inp_Hand)OTE(Sts_Hand)OTE(Sts_eSrc.2);
				RC: "This rung determines the final Command Source based on requests and priorities.";
				N: XIO(Inp_Hand)[XIC(Wrk_MOoS) OTE(Sts_OoS) OTE(Sts_eSrc.7) ,XIO(Wrk_MOoS) [XIC(Wrk_Maint) OTE(Sts_Maint) OTE(Sts_eSrc.3) ,XIO(Wrk_Maint) [XIC(Inp_Ovrd) [XIO(Wrk_Lock) ,XIC(Cfg_OvrdOverLock) ,XIC(Sts_Ovrd) ] OTE(Sts_Ovrd) OTE(Sts_eSrc.4) ,XIO(Sts_Ovrd) [XIC(Sts_bSrc.5) [XIO(Wrk_Lock) ,XIC(Cfg_ExtOverLock) ] OTE(Sts_Ext) OTE(Sts_eSrc.8) ,XIO(Sts_Ext) [XIC(Wrk_Prog) OTE(Sts_Prog) OTE(Sts_eSrc.5) ,XIO(Wrk_Prog) OTE(Sts_Oper) OTE(Sts_eSrc.6) ] [XIC(Wrk_Lock) OTE(Sts_eSrc.0) [XIC(Wrk_Prog) OTE(Sts_ProgLocked) ,XIO(Wrk_Prog) OTE(Sts_OperLocked) ] ,[XIC(Wrk_Prog) XIC(Cfg_ProgNormal) ,XIO(Wrk_Prog) XIO(Cfg_ProgNormal) ] OTE(Sts_Normal) XIO(Wrk_Lock) OTE(Sts_eSrc.1) ] ] ] ] ];
				RC: "The final states of the internal Program / Operator selection latch and the$N"
				    "Prog/Oper Lock latch are made available as Status bits.";
				N: [XIC(Wrk_ProgOperSel) OTE(Sts_ProgOperSel) ,XIC(Wrk_ProgOperLock) OTE(Sts_ProgOperLock) ];
				RC: "Sts_ProgReqInh is set if it is not possible to go from the current selection$N"
				    "to Program (or Program Locked) by a request to go to Program (or Program Locked).";
				N: [XIO(Sts_Prog) [XIO(Sts_Oper) ,XIC(Sts_OperLocked) ] [XIO(Sts_Ext) ,XIO(Cfg_HasProgLocked) ,XIC(Cfg_ExtOverLock) ] ,XIO(Cfg_HasProg) XIO(Cfg_HasProgLocked) ]OTE(Sts_ProgReqInh);
				RC: "Sts_ExtReqInh is set if it is not possible to go from the current selection$N"
				    "to External by a request to go to External.";
				N: [XIO(Cfg_HasExt) ,XIC(Inp_ExtInh) ,XIO(Sts_Ext) [XIO(Sts_Oper) XIO(Sts_Prog) ,XIO(Cfg_ExtOverLock) [XIC(Sts_OperLocked) ,XIC(Sts_ProgLocked) ] ] ]OTE(Sts_ExtReqInh);
		END_ROUTINE

		ROUTINE Prescan (Description := "Sets internal state and enumerated / bit status to $Qnot initialized$Q.")
				RC: "============================================================$N"
				    "P_CmdSrc:  Prescan Handling$N"
				    "============================================================$N"
				    "On powerup / prescan::$N"
				    "* Set the enumerated selection Status to $QNot initialized$Q (zero);$N"
				    "* Set the bitmapped selection Status to $QNot initializer$Q (bit .0);$N"
				    "* Flag the instruction to execute the initialization rungs when run.";
				N: CLR(Sts_eSrc)CLR(Sts_bSrc)OTU(Wrk_Init);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_AOut (Description := "Analog Output",
	                                      Revision := "4.10",
	                                      RevisionExtension := ".01 Release",
	                                      RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                      Vendor := "Rockwell Automation",
	                                      ExecutePrescan := Yes,
	                                      ExecutePostscan := No,
	                                      ExecuteEnableInFalse := Yes,
	                                      CreatedDate := "2008-03-27T19:50:50.098Z",
	                                      CreatedBy := "Not Available",
	                                      EditedDate := "2019-10-17T17:21:48.741Z",
	                                      EditedBy := "PROCESS\Library",
	                                      SoftwareRevision := "v18.02",
	                                      AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction controls an Analog Output and provides:$N*  Program and Operator entry of target CV in Engineering Units$N*  Ramping of Output CV to target at specified Rate of Change (EU/sec)$N*  Clamping of Output CV at configured minimum and maximum limits$N*  Scaling of Output CV from Engineering Units to Raw (I/O card) Units$N*  Monitoring of Interlock conditions which cause output to shed$N*  Configurable shed to HOLD or to configured value$N*  Monitoring of I/O communication faults$N*  Alarms for Interlock Trip, I/O Fault$N*  $QAvailable$Q status for use by automation logic to know whether Output$N      can be controlled by other objects.$N$NCommand Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$NCommand Sources: Operator, Program, External, Override, Maintenance, Out of$NService, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* No changes, uprevved because P_CmdSrc 4.10.01 is used.$N$NPREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Changed Sts_Available to use input availability from interlocks.$N* Updated to P_CmdSrc V4.10.00.$N* Added Cfg_HasMoreObj$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-11)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for associated object(s).$N* Changed $QMode$Q to $QCommand Source$Q using P_CmdSrc 4.00.00.$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* Added unacked alarm count.$N* Added  configurable decimal places for display on HMI.$N* Corrected CV Rate of Change Limiting when one direction is unlimited.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_Tieback : REAL (Description := "Tieback CV (in raw, Out_CV units) used in Hand or Init",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0.00000000e+000);
			Inp_IntlkOK : BOOL (Description := "1=Interlocks OK, Analog Output can be set",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBIntlkOK : BOOL (Description := "1=Non-Bypassable Interlocks OK, Analog Output can be set",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkAvail : BOOL (Description := "1 = Interlock Availibility OK",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Inp_IOFault : BOOL (Description := "Input Communication Status 0=OK, 1=fail",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=I/O are being simulated, set output CV to 0, ignore I/O Fault",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Hand OF CmdSrc.Inp_Hand (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes);
			Inp_Ovrd OF CmdSrc.Inp_Ovrd (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes);
			Inp_OvrdCV : REAL (Description := "CV target in Override Mode",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 0.00000000e+000);
			Inp_ExtInh OF CmdSrc.Inp_ExtInh (Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_Reset : BOOL (Description := "1=Reset shed latches and cleared alarms",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_ShedHold : BOOL (Description := "1=Hold Output on Interlock, 0=Go to Cfg_IntlkCV",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_SkipRoCLim : BOOL (Description := "1=Skip RoC Limiting in Intlk, Maint, Ovrd",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_SetTrack : BOOL (Description := "1=PSets track OSets in Oper, OSets track PSets in Prog, 0=no tracking",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1);
			Cfg_SetTrackOvrdHand : BOOL (Description := "1=Prog/Oper Settings track Override/Hand CV",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 0);
			Cfg_HasIntlkObj : BOOL (Description := "1=Tells HMI a P_Intlk is connected to Inp_Intlk",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasCVNav : BOOL (Description := "1=Tells HMI to enable navigation to a connected CV object",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_OvrdIntlk : BOOL (Description := "1=Override ignores Bypassable Intlk; 0=always use Intlk",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_ShedOnIOFault : BOOL (Description := "1=Stop Motor and Alarm on I/O Fault; 0=Alarm only on I/O Fault",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_DecPlcs : DINT (Description := "Number of decimal places for CV display (0..6)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 2);
			Cfg_HasIntlkTripAlm OF IntlkTrip.Cfg_Exists (Description := "1=Interlock Trip Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=I/O Fault Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_IntlkTripResetReqd OF IntlkTrip.Cfg_ResetReqd (Description := "1=Reset required to clear Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Reset required to clear I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IntlkTripAckReqd OF IntlkTrip.Cfg_AckReqd (Description := "1=Acknowledge required for Interlock Trip Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Acknowledge required for I/O Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_IntlkTripSeverity OF IntlkTrip.Cfg_Severity (Description := "Interlock Trip Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "I/O Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_MinCV : REAL (Description := "Minimum CV (in EU, for limiting)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0.00000000e+000);
			Cfg_MaxCV : REAL (Description := "Maximum CV (in EU, for limiting)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 1.00000000e+002);
			Cfg_CVRoCLimInc : REAL (Description := "CV Rate of Change Limit, Increasing, (EU/sec, 0=unlimited)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0.00000000e+000);
			Cfg_CVRoCLimDec : REAL (Description := "CV Rate of Change Limit, Decreasing, (EU/sec, 0=unlimited)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0.00000000e+000);
			Cfg_IntlkCV : REAL (Description := "CV Target when interlocked (if not Cfg_ShedHold) (EU)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_CVEUMin : REAL (Description := "CV Minimum in Engineering Units (for scaling)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_CVEUMax : REAL (Description := "CV Maximum in Engineering Units (for scaling)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+002);
			Cfg_CVRawMin : REAL (Description := "CV Minimum in I/O (raw) Units (for scaling)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Cfg_CVRawMax : REAL (Description := "CV Maximum in I/O (raw) Units (for scaling)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+002);
			Cfg_MaxInactiveCV : REAL (Description := "When Val_CVOut is greater than this value (in CV EU) set Sts_Active (for HMI)",
			                             Usage := Input,
			                             RADIX := Float,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0.00000000e+000);
			PSet_CV : REAL (Description := "Program Setting of Controlled Variable (output) (in EU)",
			                   Usage := Input,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0.00000000e+000);
			PSet_Owner : DINT (Description := "Program Owner Request ID (non-zero) or Release (zero)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			XSet_CV : REAL (Description := "External Setting of Controlled Variable (output) (in EU)",
			                   Usage := Input,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0.00000000e+000);
			PCmd_Prog OF CmdSrc.PCmd_Prog (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Oper OF CmdSrc.PCmd_Oper (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Lock OF CmdSrc.PCmd_Lock (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Unlock OF CmdSrc.PCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Normal OF CmdSrc.PCmd_Normal (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Reset : BOOL (Description := "Program Command to reset shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_IntlkTripAck OF IntlkTrip.PCmd_Ack (Description := "Program Command to Acknowledge Interlock Trip Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_IntlkTripSuppress OF IntlkTrip.PCmd_Suppress (Description := "Program Command to Suppress Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IntlkTripUnsuppress OF IntlkTrip.PCmd_Unsuppress (Description := "Program Command to Unsuppress Interlock Trip Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripUnshelve OF IntlkTrip.PCmd_Unshelve (Description := "Program Command to Unshelve Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			MCmd_Rel OF CmdSrc.MCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			OCmd_Unlock OF CmdSrc.OCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			XCmd_Acq OF CmdSrc.XCmd_Acq (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Rel OF CmdSrc.XCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Reset : BOOL (Description := "External Command to reset shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Out_CV : REAL (Description := "CV Output in Raw (I/O Card) Units",
			                  Usage := Output,
			                  RADIX := Float,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0.00000000e+000);
			Val_CVSet : REAL (Description := "Value of selected CV Setting (before rate limiting, in EU)",
			                     Usage := Output,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0.00000000e+000);
			Val_CVOut : REAL (Description := "Value of CV Output (after rate limiting) (in EU)",
			                     Usage := Output,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0.00000000e+000);
			Val_CVEUMin : REAL (Description := "Minimum of scaled range = MIN (Cfg_CVEUMin, Cfg_CVEUMax)",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0.00000000e+000);
			Val_CVEUMax : REAL (Description := "Maximum of scaled range = MAX (Cfg_CVEUMin, Cfg_CVEUMax)",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 1.00000000e+002);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Sts : DINT (Description := "0=AtTgt 1=RampDn 2=RampUp 3=ClampMin 4=ClampMax",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=none, 32=I/OFault, 34=CfgErr",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + channel (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_Owner : DINT (Description := "Current Object Owner ID (0=not owned)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Ramping : BOOL (Description := "1=CV is ramping to target",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_Clamped : BOOL (Description := "1=CV Set is clamped at CVMin or CVMax",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_SkipRoCLim : BOOL (Description := "1=Rate of Change Limiting was skipped this scan (Maint, Ovrd, Intlk, Hand)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_Active : BOOL (Description := "1=CV is greater than Cfg_MaxInactiveCV, show graphic symbol as $Qactive$Q",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Available : BOOL (Description := "1=Analog Output available for control by automation (Prog)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Bypass : BOOL (Description := "1=Bypassable Interlocks are Bypassed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_BypActive : BOOL (Description := "1=Bypassing Active (Bypassed or Maintenance)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_NotRdy : BOOL (Description := "1=Device Not Ready, see detail bits for reason",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_CfgErr : BOOL (Description := "1=Device Not Ready: Configuration Error",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Nrdy_Intlk : BOOL (Description := "1=Device Not Ready: Interlock Not OK",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_IOFault : BOOL (Description := "1=Device Not Ready: I/O Fault (Shed Requires Reset)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_OoS : BOOL (Description := "1=Device Not Ready: Device is Out of Service",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=Device has a Maintenance Bypass function active",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=One or more Alarms Shelved, Disabled or Suppressed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Limit : BOOL (Description := "1=Error in Config: CV Limits swapped",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_EU : BOOL (Description := "1=Error in Config: Scaled CV EU Min = Max",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Err_Raw : BOOL (Description := "1=Error in Config: Raw Output Scaling Min = Max",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Hand OF CmdSrc.Sts_Hand (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OoS OF CmdSrc.Sts_OoS (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Maint OF CmdSrc.Sts_Maint (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only);
			Sts_Ovrd OF CmdSrc.Sts_Ovrd (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_Ext OF CmdSrc.Sts_Ext (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Prog OF CmdSrc.Sts_Prog (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_ProgLocked OF CmdSrc.Sts_ProgLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Oper OF CmdSrc.Sts_Oper (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OperLocked OF CmdSrc.Sts_OperLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Normal OF CmdSrc.Sts_Normal (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_ExtReqInh OF CmdSrc.Sts_ExtReqInh (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_ProgReqInh OF CmdSrc.Sts_ProgReqInh (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_MAcqRcvd OF CmdSrc.Sts_MAcqRcvd (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_IntlkTrip OF IntlkTrip.Inp (Description := "1=Status: CV held or forced by interlock NOT OK (1-shot)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_IntlkTrip OF IntlkTrip.Alm (Description := "1=Alarm: CV held or forced by interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_IntlkTrip OF IntlkTrip.Ack (Description := "1=Interlock Trip Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_IntlkTripDisabled OF IntlkTrip.Disabled (Description := "1=Interlock Trip Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTripShelved OF IntlkTrip.Shelved (Description := "1=Interlock Trip Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_IntlkTripSuppressed OF IntlkTrip.Suppressed (Description := "1=Interlock Trip Alarm has been Suppressed by Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "1=I/O Fault Status (0=OK, 1=Bad)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=I/O Fault Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			MRdy_Rel OF CmdSrc.MRdy_Rel (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			ORdy_Unlock OF CmdSrc.ORdy_Unlock (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only);
			P_AOut : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			CmdSrc : P_CmdSrc (Description := "Control / Command Source Selection",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[7649,0,0,1,0,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']]");
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			IntlkTrip : P_Alarm (Description := "Interlock Trip Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[17,'Interlock Tripped$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[6,'P_AOut$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[13,'Analog Output$00$00$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[13,'Analog Output$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Bypass : BOOL (Description := "Internal Bypassable Interlocks are Bypassed flag",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Cfg_EU : STRING_8 (Description := "Engineering Units for display on HMI",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[1,'%$00$00$00$00$00$00$00']");
			Wrk_CV : REAL (Description := "Working copy of Speed Reference (for limiting)",
			                 RADIX := Float,
			                 ExternalAccess := None,
			                 DefaultData := 0.00000000e+000);
			Wrk_CVSet : REAL (Description := "Final selected CV to feed to RoC Limiter",
			                    RADIX := Float,
			                    ExternalAccess := None,
			                    DefaultData := 0.00000000e+000);
			Wrk_CVOut : REAL (Description := "Wroking value of CV after Rate Limiting",
			                    RADIX := Float,
			                    ExternalAccess := None,
			                    DefaultData := 0.00000000e+000);
			Wrk_IntlkTripONS : BOOL (Description := "Interlock Tripped This Scan",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_ScanTime : REAL (Description := "Seconds since previous scan",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_StepInc : REAL (Description := "Amount to change CVOut this scan for increase rate limiting",
			                      RADIX := Float,
			                      ExternalAccess := None,
			                      DefaultData := 0.00000000e+000);
			Wrk_ScanT : TIMER (Description := "Scan Timer (milliseconds, always runs)",
			                    ExternalAccess := None,
			                    DefaultData := "[0,2147483647,0]");
			Wrk_SelCVDINT : DINT (Description := "Selected CV check for Infinite or Non A Number",
			                        RADIX := Hex,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Val_Notify : SINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wrk_Sts : DINT (Description := "Buffer for building Val_Sts",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			HMI_Type : STRING_16 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[6,'P_AOut$00$00$00$00$00$00$00$00$00$00']");
			Wrk_StepDec : REAL (Description := "Amount to change CVOut this scan for decrease rate limiting",
			                      RADIX := Float,
			                      ExternalAccess := None,
			                      DefaultData := 0.00000000e+000);
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Cfg_CVNavTag : STRING_NavTag (Description := "Tagname for destination of CV Navigation button",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_ShedIntlkCV : BOOL (Description := "Output CV being held at Interlock value",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_ShedHold : BOOL (Description := "Output CV being held at last good value",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			ORdy_CV : BOOL (Description := "1=Ready for OSet_CV (enables data entry field)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Check : BOOL (Description := "1=Ready for MCmd_Check (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Bypass : BOOL (Description := "1=Ready for MCmd_Bypass (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			OCmd_ResetAckAll : BOOL (Description := "Operator Command to Reset all Alarms and latched Shed conditions",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Check : BOOL (Description := "Maintenance Command to Check (not bypass) all Interlocks",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Bypass : BOOL (Description := "Maintenance Command to Bypass all Bypassable Interlocks",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			OSet_CV : REAL (Description := "Operator Setting of Controlled Variable (output) (in EU)",
			                  RADIX := Float,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0.00000000e+000);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Out of Service is asserted, Output OFF (zero), Alarms inhibited.")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "Handle $QProgrammed Out of Servie$Q Selection using the standard$N"
				    "P_CmdSrc AOI (EnableInFalse Routine, false scan required!).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed P_Mode to P_CmdSrc.  #####";
				N: XIC(EnableIn)P_CmdSrc(CmdSrc);
				RC: "First-Come First-Served Ownership Arbitration still needs to happen, even when device is disabled.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "This rung publishes the Values for the scaled range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the CV EU configuration of a PID, so the AOut and PID ranges are in lockstep.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added configurable decimal places for display on HMI.  #####";
				N: [GEQ(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMin) MOV(Cfg_CVEUMax,Val_CVEUMax) ,LES(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMax) MOV(Cfg_CVEUMax,Val_CVEUMin) ,LIM(7,Cfg_DecPlcs,-1) MOV(2,Cfg_DecPlcs) ];
				RC: "Restrict the configured Rate of Change Limits to be non-negative.$N"
				    "NOTE:  A $Qzero$Q value of a limit means $Qunlimited$Q (immediate).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [LES(Cfg_CVRoCLimInc,0.0) CLR(Cfg_CVRoCLimInc) ,LES(Cfg_CVRoCLimDec,0.0) CLR(Cfg_CVRoCLimDec) ];
				RC: "If this Analog Output is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then show the alarms as $QParent object out of service$Q.$N"
				    "Show the overall acknowledgement status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed P_Mode to P_CmdSrc, added Out of Service.  #####";
				N: [OTL(IntlkTrip.Inp_OoS) P_Alarm(IntlkTrip) ,OTL(IOFault.Inp_OoS) P_Alarm(IOFault) ,CLR(Val_Notify) CLR(Val_NotifyAll) ,[XIC(IntlkTrip.Val_Notify.0) ,XIC(IOFault.Val_Notify.0) ] OTL(Val_Notify.0) OTL(Val_NotifyAll.0) ,[XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ] OTE(Sts_AlmInh) ];
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Crossed CV Limits or Invalid Rate of Change Limit$N"
				    "Bad Engineering Units Scaling configs (Max = Min)$N"
				    "Bad Raw Scaling configs (Max = Min)$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [LES(Cfg_MaxCV,Cfg_MinCV) OTE(Err_Limit) ,EQU(Cfg_CVEUMax,Cfg_CVEUMin) OTE(Err_EU) ,EQU(Cfg_CVRawMax,Cfg_CVRawMin) OTE(Err_Raw) ,[XIC(IntlkTrip.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err)OTE(Nrdy_CfgErr);
				RC: "If this Analog Output is OFF-SCAN (rung is false or EnableIn is false in FBD), then:$N"
				    "$N"
				    "Set the Output to the configured ($Qsafe$Q) Interlock CV value.$N"
				    "(In simulation, Out_CV is set to zero.)$N"
				    "$N"
				    "Other data are left in Last State!$N"
				    "Fixed scaling CPT -- previously, raw and EU were swapped.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [OTU(Sts_Available) OTU(Sts_MaintByp) OTU(Sts_Active) ,OTL(Sts_NotRdy) OTL(Nrdy_OoS) OTU(Nrdy_Intlk) OTU(Nrdy_IOFault) ,MOV(Cfg_IntlkCV,Wrk_CVSet) MOV(Cfg_IntlkCV,Wrk_CVOut) ,XIO(Inp_Sim) XIO(Nrdy_CfgErr) CPT(Out_CV,(Wrk_CVOut-Cfg_CVEUMin)*(Cfg_CVRawMax-Cfg_CVRawMin)/(Cfg_CVEUMax-Cfg_CVEUMin)+Cfg_CVRawMin) ,[XIC(Inp_Sim) ,XIC(Nrdy_CfgErr) ] CLR(Out_CV) ];
				RC: "The rate limiter$'s scan timer must run and clear every scan, whether the Instruction$N"
				    "is true or not.  Doing so here avoids a bump in the Value on transition to EnableIn TRUE.";
				N: TON(Wrk_ScanT,?,?)CLR(Wrk_ScanT.ACC);
				RC: "$QLurking$Q Operator Commands are cleared, as well as a Program Reset.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  Added External Command Source and Commands/Settings.  #####";
				N: [OTU(MCmd_Bypass) OTU(MCmd_Check) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####$N"
				    "#####  Aligned ready bit naming with command bit names.  #####";
				N: [OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) OTU(Sts_RdyAck) OTU(ORdy_CV) ];
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = At Target$N"
				    "1 = Ramping Down$N"
				    "2 = Ramping Up$N"
				    "3 = Clamped at CVMin$N"
				    "4 = Clamped at CVMax$N"
				    "$N"
				    "And this rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "32 = I/O Fault$N"
				    "34 = Configuration Error$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [CLR(Val_Sts) ,XIO(Sts_Err) CLR(Val_Fault) ,XIC(Sts_Err) MOV(34,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [CLR(Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(20,SrcQ);
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan: control Analog Output")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_AOut :  PROCESS -- ANALOG OUTPUT$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-17: See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-06-25:  Changed $QMode$Q to $QCommand Source$Q. Changed Inf_items to HMI_,$N"
				    "and added Cfg_Area for security. Added unacked alarm count.$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "Added  configurable decimal places for display on HMI.$N"
				    "Corrected CV Rate of Change Limiting when one direction is unlimited.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyAck and Sts_ResetReqd for use by external objects.$N"
				    "V4.10.00  2019-03-08:  Changed availability to use input availability from interlocks.$N"
				    "Updated to P_CmdSrc V4.10.00. Added Cfg_HasMoreObj.$N"
				    "V4.10.01  2019-10-17:  No changes, uprevved because P_CmdSrc 4.10.01 is used.$N"
				    "============================================================$N"
				    "This Instruction controls an Analog Output and provides:$N"
				    "$N"
				    "*  Program and Operator entry of target CV in Engineering Units$N"
				    "*  Ramping of Output CV to target at specified Rate of Change (EU/sec)$N"
				    "*  Clamping of Output CV at configured minimum and maximum limits$N"
				    "*  Scaling of Output CV from Engineering Units to Raw (I/O card) Units$N"
				    "*  Monitoring of Interlock conditions which cause output to shed$N"
				    "*  Configurable shed to HOLD or to configured SAFE value$N"
				    "*  Monitoring of I/O communication faults$N"
				    "*  Alarms for Interlock Trip, I/O Fault$N"
				    "*  $QAvailable$Q status for use by automation logic to know whether Output$N"
				    "      can be controlled by other objects.$N"
				    "$N"
				    "Command Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$N"
				    "Command Sources: Operator, Program, External, Override, Maintenance, Out of$N"
				    "Service, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)CONCAT(Cfg_Desc,Cfg_Label,Cfg_Tag)CONCAT(Cfg_Area,Cfg_EU,Cfg_CVNavTag)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "COMMAND SOURCE PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Command Source selection Inputs and Commands:$N"
				    "$N"
				    "NOTE:  All Commands for Command Source and Alarm are aliased directly to the$N"
				    "corresponding Commands in the contained P_CmdSrc and P_Alarm AOIs.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed P_Mode to P_CmdSrc.  #####";
				N: LBL(SkipText)P_CmdSrc(CmdSrc);
				RC: "This rung handles simple First-Come First-Served Ownership Arbitration.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "These rungs get Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration data are used directly in-place.$N"
				    "$N"
				    "This rung publishes the Values for the scaled range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the CV EU configuration of a PID, so the AOut and PID ranges are in lockstep.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added configurable decimal places for display on HMI.  #####";
				N: [GEQ(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMin) MOV(Cfg_CVEUMax,Val_CVEUMax) ,LES(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMax) MOV(Cfg_CVEUMax,Val_CVEUMin) ,LIM(7,Cfg_DecPlcs,-1) MOV(2,Cfg_DecPlcs) ];
				RC: "Restrict the configured Rate of Change Limits to be non-negative.$N"
				    "NOTE:  A $Qzero$Q value of a limit means $Qunlimited$Q (immediate).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [LES(Cfg_CVRoCLimInc,0.0) CLR(Cfg_CVRoCLimInc) ,LES(Cfg_CVRoCLimDec,0.0) CLR(Cfg_CVRoCLimDec) ];
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Crossed CV Limits$N"
				    "Bad Engineering Units Scaling configs (Max = Min)$N"
				    "Bad Raw Scaling configs (Max = Min)$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.";
				N: [LES(Cfg_MaxCV,Cfg_MinCV) OTE(Err_Limit) ,EQU(Cfg_CVEUMax,Cfg_CVEUMin) OTE(Err_EU) ,EQU(Cfg_CVRawMax,Cfg_CVRawMin) OTE(Err_Raw) ]OTE(Nrdy_CfgErr);
				RC: "============================================================$N"
				    "SETTINGS PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Settings:$N"
				    "$N"
				    "Limit the Program and Operator CV Settings to the hard limits, regardless of Command Source$N"
				    "(in case tracking is off....).$N"
				    "When the Command Source is Program, use the Program Setting for the CV.$N"
				    "When the Command Source is External, use the External Setting for the CV.$N"
				    "When the Command Source is Operator or Maintenance, use the Operator Setting.$N"
				    "When the Command Source is Override, use the Override CV input for the CV.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added External Command Source and Commands/Settings.  #####";
				N: [[[GRT(PSet_CV,Cfg_MaxCV) MOV(Cfg_MaxCV,PSet_CV) ,LES(PSet_CV,Cfg_MinCV) MOV(Cfg_MinCV,PSet_CV) ] XIC(Sts_Prog) ,[GRT(XSet_CV,Cfg_MaxCV) MOV(Cfg_MaxCV,XSet_CV) ,LES(XSet_CV,Cfg_MinCV) MOV(Cfg_MinCV,XSet_CV) ] XIC(Sts_Ext) ,XIO(Sts_Maint) XIO(Sts_Hand) [GRT(OSet_CV,Cfg_MaxCV) MOV(Cfg_MaxCV,OSet_CV) ,LES(OSet_CV,Cfg_MinCV) MOV(Cfg_MinCV,OSet_CV) ] ] OTE(Sts_Clamped) ,[XIC(Sts_Oper) ,XIC(Sts_Maint) ] MOV(OSet_CV,Wrk_CV) ,XIC(Sts_Ext) MOV(XSet_CV,Wrk_CV) ,XIC(Sts_Prog) MOV(PSet_CV,Wrk_CV) ,XIC(Sts_Ovrd) MOV(Inp_OvrdCV,Wrk_CV) ];
				RC: "============================================================$N"
				    "INTERLOCK / PERMISSIVE BYPASS / CHECK COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Bypass Command bypasses the Bypassable Permissives and Interlocks.";
				N: XIC(MCmd_Bypass)OTU(MCmd_Bypass)OTL(Wrk_Bypass);
				RC: "The Check Command enables checking of ALL$N"
				    "Permissives and Interlocks (cancels the bypass).";
				N: XIC(MCmd_Check)OTU(MCmd_Check)OTU(Wrk_Bypass);
				RC: "If the internal Bypass flag is set, Bypassable Interlocks ARE BYPASSED.$N"
				    "Bypassing is ACTIVE if Bypass selected OR in Maintenance Command Source,$N"
				    "or in Override Command Source if Override Bypassing is configured.";
				N: [XIC(Wrk_Bypass) OTE(Sts_Bypass) ,XIC(Sts_Maint) ,XIC(Sts_Ovrd) XIC(Cfg_OvrdIntlk) ]OTE(Sts_BypActive);
				RC: "If a Maintenance Bypass function is active, display the Maintenance Bypass$N"
				    "Indicator (triangle symbol) on the graphic symbol.  Bypass functions are:$N"
				    "*  Interlock Bypass function is enabled.";
				N: XIC(Sts_Bypass)OTE(Sts_MaintByp);
				RC: "Ready for Interlock Bypass if not bypassed.$N"
				    "Ready to cancel Bypass (resume checking) if bypassed.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Aligned ready bit naming with command bit names.  #####";
				N: [XIO(Wrk_Bypass) OTE(MRdy_Bypass) ,XIC(Wrk_Bypass) OTE(MRdy_Check) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "This rung processes received Reset Commands from:$N"
				    "$N"
				    "1.  The Operator via HMI Operator Command, or$N"
				    "2.  Higher-level strategies via Program Command$N"
				    "3.  Pushbuttons or other block via Input$N"
				    "$N"
				    "and forwards the Reset to ALL Alarms and latched Shed conditions.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands/Settings.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(XCmd_Reset) OTU(XCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(IntlkTrip.PCmd_Ack) ,OTL(IOFault.PCmd_Ack) ] ][OTL(IntlkTrip.PCmd_Reset) OTL(IOFault.PCmd_Reset) ,[XIO(Inp_IOFault) ,XIC(Inp_Sim) ] OTU(Nrdy_IOFault) ];
				RC: "The Analog Output is NOT READY to be controlled (by the owner specified by Command Source):$N"
				    "if it is Out of Service,$N"
				    "if there is a Configuration Error,$N"
				    "if interlocks are not OK (accounting for bypassing), or$N"
				    "if I/O Communication is faulted and is configured as a Shed condition.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_CfgErr) ,XIC(Sts_OoS) OTE(Nrdy_OoS) ,[XIO(Inp_IntlkOK) XIO(Sts_BypActive) ,XIO(Inp_NBIntlkOK) ] [[ONS(Wrk_IntlkTripONS) XIC(Cfg_ShedHold) ,XIO(Cfg_ShedHold) NEQ(Wrk_CVSet,Cfg_IntlkCV) ] OTE(Sts_IntlkTrip) ,OTE(Nrdy_Intlk) ] ,XIC(Inp_IOFault) XIO(Inp_Sim) OTE(Sts_IOFault) XIC(Cfg_ShedOnIOFault) OTL(Nrdy_IOFault) ,XIC(Nrdy_IOFault) ]OTE(Sts_NotRdy);
				RC: "The device is AVAILABLE to be controlled by other objects$N"
				    "if it IS in Program Mode and it IS NOT $QNot Ready$Q.$N"
				    "#####  V4.10.00  2019-03-08:  Changed availability to use input availability from interlocks.  #####";
				N: XIC(Sts_Prog)XIO(Nrdy_CfgErr)XIO(Nrdy_OoS)XIO(Nrdy_IOFault)[[XIC(Inp_IntlkOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBIntlkOK) ,XIC(Inp_IntlkAvail) ]OTE(Sts_Available);
				RC: "Ready to receive a new OSet_CV if tracking is NOT enabled,$N"
				    "or we$'re in Operator or Maintenance Command Source, or,$N"
				    "if we$'re in Hand or Ovrd, tracking is NOT configured for Ovrd and Hand.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Aligned ready bit naming with command bit names.  #####";
				N: [XIO(Cfg_SetTrack) ,XIC(Sts_Oper) ,XIC(Sts_Maint) ,[XIC(Sts_Hand) ,XIC(Sts_Ovrd) ] XIO(Cfg_SetTrackOvrdHand) ]OTE(ORdy_CV);
				RC: "============================================================$N"
				    "ANALOG OUTPUT HANDLING$N"
				    "============================================================$N"
				    "Clear flags for capturing exception conditions.";
				N: OTU(Wrk_ShedHold)OTU(Wrk_ShedIntlkCV);
				RC: "If Interlocks are not OK (non-bypassable always checked, bypassable checked if not bypassed$N"
				    "(bypassables not checked in Maintenance Command Source, or in Override Command Source$N"
				    " if Override ignores bypassable interlocks...),$N"
				    "or if there is an I/O Fault, either HOLD the CV or SHED it to the configured Interlock CV,$N"
				    "depending on the state of the Shed/Hold configuration.$N"
				    "$N"
				    "We don$'t want the Interlock Trip alarm occuring if Hand or Disabled is going to win down below....$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_Intlk) ,XIC(Nrdy_IOFault) XIO(Sts_Maint) ]XIO(Sts_Hand)XIO(Sts_OoS)XIO(Nrdy_CfgErr)[XIO(Cfg_ShedHold) OTL(Wrk_ShedIntlkCV) MOV(Cfg_IntlkCV,Wrk_CV) ,XIC(Cfg_ShedHold) OTL(Wrk_ShedHold) MOV(Wrk_CVSet,Wrk_CV) ];
				RC: "In HAND, set the CV (in EU) to match the tieback (in Raw units)  from the downstream block.";
				N: XIC(Sts_Hand)CPT(Wrk_CV,(Inp_Tieback-Cfg_CVRawMin)*(Cfg_CVEUMax-Cfg_CVEUMin)/(Cfg_CVRawMax-Cfg_CVRawMin)+Cfg_CVEUMin);
				RC: "If the Analog Output is Out of Service, set the CV to the configured Interlock ($Qsafe$Q) CV.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_CfgErr) ,XIC(Sts_OoS) ]OTL(Wrk_ShedIntlkCV)MOV(Cfg_IntlkCV,Wrk_CV);
				RC: "After all that selecting, copy the final result to a holding register.  (We needed it above to do$N"
				    "the HOLD function on Interlock!)$N"
				    "$N"
				    "This is where the CV will be when ramping (if any) is done.";
				N: MOV(Wrk_CV,Wrk_CVSet);
				RC: "This rung determines whether the selected Analog Output CV is +/- Infinity or +/- NotANumber.$N"
				    "In either case, the value cannot be passed into the rate limiter calculation or to the final output.$N"
				    "Instead, perform the designated SHED action: hold last output or shed to the Interlock CV.";
				N: COP(Wrk_CVSet,Wrk_SelCVDINT,1)MEQ(Wrk_SelCVDINT,16#7F80_0000,16#7F80_0000)[XIO(Cfg_ShedHold) OTL(Wrk_ShedIntlkCV) MOV(Cfg_IntlkCV,Wrk_CVSet) ,XIC(Cfg_ShedHold) OTL(Wrk_ShedHold) MOV(Wrk_CVOut,Wrk_CVSet) ];
				RC: "In preparation for rate limiting the CV, this rung$N"
				    "determines the time since the previous scan, using a non-stop TON timer.$N"
				    "When we get here, we read the accumulator (in milliseconds, so$N"
				    "divide by 1000.0 to get seconds), then clear the accumulator.  Next scan the accumulator will have$N"
				    "incremented up to the number of milliseconds since last scan.  (Works for scan times up to 2 million seconds.....)";
				N: MOV(2147483647,Wrk_ScanT.PRE)TON(Wrk_ScanT,?,?)DIV(Wrk_ScanT.ACC,1000.0,Wrk_ScanTime)CLR(Wrk_ScanT.ACC);
				RC: "Under these conditions, SKIP the output ramping:$N"
				    "$N"
				    "* The AOut is disabled$N"
				    "* The AOut is in Hand$N"
				    "* Rate of Change Skip is configures TRUE and, either, the Command Source is Maintenance,$N"
				    "the Command Source is Override, or an Interlock holds us out.$N"
				    "* The entered CV Rate of Change Limits are ZERO.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####$N"
				    "#####  Corrected CV Rate of Change Limiting when one direction is unlimited.  #####";
				N: [XIC(Nrdy_CfgErr) ,XIC(Sts_OoS) ,XIC(Sts_Hand) ,XIC(Cfg_SkipRoCLim) [XIC(Sts_Maint) ,XIC(Sts_Ovrd) ,XIC(Nrdy_Intlk) ] ,GRT(Wrk_CVSet,Wrk_CVOut) EQU(Cfg_CVRoCLimInc,0.0) ,LES(Wrk_CVSet,Wrk_CVOut) EQU(Cfg_CVRoCLimDec,0.0) ]OTE(Sts_SkipRoCLim)MOV(Wrk_CVSet,Wrk_CVOut);
				RC: "If the conditions above are NOT TRUE, do the rate limiting:$N"
				    "$N"
				    "If the time since the previous scan is not ZERO:$N"
				    "$N"
				    "* Calculate the amount to step this scan toward the final CV$N"
				    "* If we$'re within a single setp (or the direction we need to go is unlimited), go to the final CV$N"
				    "* If we$'re not within a single step, step one step closer (up or down, whichever way we need to go)$N"
				    "and show the $QRamping$Q status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: XIO(Sts_SkipRoCLim)NEQ(Wrk_CVSet,Wrk_CVOut)NEQ(Wrk_ScanTime,0.0)[MUL(Cfg_CVRoCLimInc,Wrk_ScanTime,Wrk_StepInc) MUL(Cfg_CVRoCLimDec,Wrk_ScanTime,Wrk_StepDec) ,GRT(Wrk_CVSet,Wrk_CVOut) CMP(Wrk_CVOut>=(Wrk_CVSet-Wrk_StepInc)) MOV(Wrk_CVSet,Wrk_CVOut) ,LES(Wrk_CVSet,Wrk_CVOut) CMP(Wrk_CVOut<=(Wrk_CVSet+Wrk_StepDec)) MOV(Wrk_CVSet,Wrk_CVOut) ,[CMP(Wrk_CVOut>(Wrk_CVSet+Wrk_StepDec)) SUB(Wrk_CVOut,Wrk_StepDec,Wrk_CVOut) ,CMP(Wrk_CVOut<=(Wrk_CVSet-Wrk_StepInc)) ADD(Wrk_CVOut,Wrk_StepInc,Wrk_CVOut) ] OTE(Sts_Ramping) ];
				RC: "============================================================$N"
				    "OUTPUT GENERATION$N"
				    "============================================================$N"
				    "This rung generates the instruction Output$N"
				    "$N"
				    "If not in simulation, scale the generated Wrk_CVOut to Raw Units in Out_CV$N"
				    "If in Simulation, set Out_CV to zero.";
				N: [XIO(Inp_Sim) [XIO(Err_EU) XIO(Err_Raw) CPT(Out_CV,(Wrk_CVOut-Cfg_CVEUMin)*(Cfg_CVRawMax-Cfg_CVRawMin)/(Cfg_CVEUMax-Cfg_CVEUMin)+Cfg_CVRawMin) ,[XIC(Err_EU) ,XIC(Err_Raw) ] OTL(Wrk_ShedIntlkCV) MOV(Cfg_IntlkCV,Out_CV) ] ,XIC(Inp_Sim) CLR(Out_CV) ];
				RC: "============================================================$N"
				    "VALUES PROCESSING$N"
				    "============================================================$N"
				    "Val_CVSet (commanded output)$N"
				    "$N"
				    "Based on Command Source and Tracking settings, copy the working CV setting$N"
				    "back into the Operator and Program Settings.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added External Command Source and Commands/Settings.  #####";
				N: [MOV(Wrk_CVSet,Val_CVSet) MOV(Wrk_CVOut,Val_CVOut) ,XIC(Cfg_SetTrack) [XIO(Sts_Ovrd) XIO(Sts_Hand) ,XIC(Cfg_SetTrackOvrdHand) ] MOV(Val_CVSet,PSet_CV) MOV(Val_CVSet,XSet_CV) MOV(Val_CVSet,OSet_CV) ];
				RC: "If the Output CV (in CV Engineering Units, Val_CVOut) is above the$N"
				    "configured maximum $Qinactive$Q CV, show the analog output graphic symbol$N"
				    "on the HMI as $Qactive$Q (e.g., valve open).";
				N: GRT(Val_CVOut,Cfg_MaxInactiveCV)OTE(Sts_Active);
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: OTL(IntlkTrip.PCfg_AllowExist)OTL(IOFault.PCfg_AllowExist);
				RC: "Let the Alarm instance know if this object is taken Out of Service$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Now using P_CmdSrc, including Out of Service.  #####";
				N: XIC(CmdSrc.Sts_OoS)OTE(IntlkTrip.Inp_OoS)OTE(IOFault.Inp_OoS);
				RC: "Handle Interlock Trip Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IntlkTrip);
				RC: "Handle I/O Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).";
				N: [XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Crossed CV Limits$N"
				    "Bad Engineering Units Scaling configs (Max = Min)$N"
				    "Bad Raw Scaling configs (Max = Min)$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.";
				N: [XIC(Nrdy_CfgErr) ,[XIC(IntlkTrip.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = At Target$N"
				    "1 = Ramping Down$N"
				    "2 = Ramping Up$N"
				    "3 = Clamped at CVMin$N"
				    "4 = Clamped at CVMax$N"
				    "$N"
				    "32 = I/O Fault$N"
				    "34 = Configuration Error$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [CLR(Wrk_Sts) CLR(Wrk_Fault) ,XIC(Sts_Ramping) [GRT(Wrk_CVOut,Wrk_CVSet) MOV(1,Wrk_Sts) ,LES(Wrk_CVOut,Wrk_CVSet) MOV(2,Wrk_Sts) ] ,XIC(Sts_Clamped) [EQU(Wrk_CVOut,Cfg_MinCV) MOV(3,Wrk_Sts) ,EQU(Wrk_CVOut,Cfg_MaxCV) MOV(4,Wrk_Sts) ] ,[XIC(Sts_IOFault) ,XIC(Nrdy_IOFault) ] MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [CLR(Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(SrcQ_IO,Wrk_SrcQ) ,XIC(Wrk_ShedHold) MOV(19,Wrk_SrcQ) ,XIC(Wrk_ShedIntlkCV) MOV(20,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ) ];
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count.  #####$N"
				    "";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) ,GRT(IntlkTrip.Val_Notify,Wrk_Notify) MOV(IntlkTrip.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(IntlkTrip.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTE(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_Notify,Val_NotifyAll) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(IntlkTrip.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(IntlkTrip.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ,XIC(Nrdy_IOFault) XIO(Sts_IOFault) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownership. clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, set the Ownership to NO OWNER (0).";
				N: CLR(PSet_Owner)CLR(Val_Owner);
				RC: "$QLurking$Q Operator Commands are cleared, as well as a Program Reset.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  Added External Command Source and Commands/Settings.  #####";
				N: [OTU(MCmd_Bypass) OTU(MCmd_Check) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####$N"
				    "#####  Aligned ready bit naming with command bit names.  #####";
				N: [OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) OTU(ORdy_CV) ];
				RC: "Clear latched Shed (Not Ready) bits.";
				N: OTU(Nrdy_IOFault);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_D4SD (Description := "2-, 3- or 4-State Device",
	                                      Revision := "4.10",
	                                      RevisionExtension := ".01 Release",
	                                      RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                      Vendor := "Rockwell Automation",
	                                      ExecutePrescan := Yes,
	                                      ExecutePostscan := No,
	                                      ExecuteEnableInFalse := Yes,
	                                      CreatedDate := "2010-09-09T18:23:54.745Z",
	                                      CreatedBy := "Not Available",
	                                      EditedDate := "2019-10-17T17:27:51.319Z",
	                                      EditedBy := "PROCESS\Library",
	                                      SoftwareRevision := "v18.02",
	                                      AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction controls and monitors feedback from a Discrete 2-State,$N3-State or 4-State Device, and provides:$N  *  Operator and Program Commands to select one of the 2, 3 or 4 states$N  *  User-configurable text labels for the states$N  *  Per-State setting, clearing or holding of four user-configurable outputs$N  *  Per-State monitoring of four feedbacks (on, off or don$'t care) to confirm state$N  *  Detection of failure to reach the target state (when feedbacks are used)$N  *  Monitoring of Permissive conditions to allow commanding to each state$N  *  Monitoring of Interlock conditions to return device to State 0$N  *  Operation in Hand, Maintenance, Override, Program and Operator Modes$N  *  Simulation, providing feedback of a working device while disabling output$N       (keeping de-energized)$N  *  Monitoring of I/O communication status$N  *  Alarms for Fail to reach target state (if feedbacks are used), Device Failure$N      (reported by device using an input), Interlock Trip, I/O Fault$N  *  $QAvailable$Q status for use by automation logic to know whether the$N      device can be controlled by other objects.$N$NCommand Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$NCommand Sources: Operator, Program, External, Override, Maintenance, Out of$NService, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* No changes, uprevved because P_CmdSrc 4.10.01 is used.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Changed availability to use input availability from interlocks.$N* Added audible alert on commanded energize/state change.$N* Added Inp_HornInh to disable Horn operation.$N* Modified logic to correct confgurable shed action.$N* Updated to P_CmdSrc V4.10.00.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-11)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for Channel object.$N* Changed $QMode$Q to $QCommand Source$Q using P_CmdSrc 4.00.00.$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_AckReqd and Sts_ResetReqd for use by external objects.$N* Changed delay / time configuration items to REAL seconds.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_FdbkA : BOOL (Description := "Input Signal: Feedback A from device",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Inp_FdbkB : BOOL (Description := "Input Signal: Feedback B from device",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Inp_FdbkC : BOOL (Description := "Input Signal: Feedback C from device",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Inp_FdbkD : BOOL (Description := "Input Signal: Feedback D from device",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Inp_DeviceFault : BOOL (Description := "Input Signal: Device Fault from device",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Inp_PermOK0 : BOOL (Description := "1=Permissives OK, device can be commanded to State 0",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBPermOK0 : BOOL (Description := "1=Non-Bypassable Permissives OK, device can be commanded to State 0",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_PermOK1 : BOOL (Description := "1=Permissives OK, device can be commanded to State 1",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBPermOK1 : BOOL (Description := "1=Non-Bypassable Permissives OK, device can be commanded to State 1",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_PermOK2 : BOOL (Description := "1=Permissives OK, device can be commanded to State 2",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBPermOK2 : BOOL (Description := "1=Non-Bypassable Permissives OK, device can be commanded to State 2",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_PermOK3 : BOOL (Description := "1=Permissives OK, device can be commanded to State 3",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBPermOK3 : BOOL (Description := "1=Non-Bypassable Permissives OK, device can be commanded to State 3",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkOK : BOOL (Description := "1=Interlocks OK, 0=Not OK, go to State 0",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBIntlkOK : BOOL (Description := "1=Non-Bypassable Interlocks OK, 0=Not OK, go to State 0",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkAvail : BOOL (Description := "1 = Interlock Availibility OK",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Inp_IOFault : BOOL (Description := "Input Communication Status 0=OK, 1=fail",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=Simulate working device; 0=Control actual device",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Hand OF CmdSrc.Inp_Hand (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_Ovrd OF CmdSrc.Inp_Ovrd (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_OvrdCmd : DINT (Description := "Override Device Command: 0=None, 1=St.0, 2=St.1, 3=St.2, 4=St.3",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_ExtInh OF CmdSrc.Inp_ExtInh (Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_HornInh : BOOL (Description := "1 = Inhibit audible alert, 0 = Alllow audible alert",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Reset : BOOL (Description := "1=Reset all fault conditions and latched Alarms",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_St0onShed : BOOL (Description := "1=Go to State 0 on Shed, 0=Hold position on Shed",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_NumStates : DINT (Description := "Number of device states (2..4)",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 2);
			Cfg_OutSt0Write : SINT (Description := "Bit=1: write output in state 0, Bit=0: leave in last state",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 15);
			Cfg_OutSt0State : SINT (Description := "(if written) Bit=1: output set in State 0, Bit=0: output cleared",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 1);
			Cfg_OutSt1Write : SINT (Description := "Bit=1: write output in state 1, Bit=0: leave in last state",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 15);
			Cfg_OutSt1State : SINT (Description := "(if written) Bit=1: output set in State 1, Bit=0: output cleared",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 2);
			Cfg_OutSt2Write : SINT (Description := "Bit=1: write output in state 2, Bit=0: leave in last state",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 15);
			Cfg_OutSt2State : SINT (Description := "(if written) Bit=1: output set in State 2, Bit=0: output cleared",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 4);
			Cfg_OutSt3Write : SINT (Description := "Bit=1: write output in state 3, Bit=0: leave in last state",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 15);
			Cfg_OutSt3State : SINT (Description := "(if written) Bit=1: output set in State 3, Bit=0: output cleared",
			                           Usage := Input,
			                           RADIX := Binary,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 8);
			Cfg_FdbkSt0Check : SINT (Description := "Bit=1: Check Feedback in state 0, Bit=0: don$'t care",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_FdbkSt0State : SINT (Description := "(if checking) Bit=1: Feedback is 1 in State 0, Bit=0: Feedback is 0",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 1);
			Cfg_FdbkSt1Check : SINT (Description := "Bit=1: Check Feedback in state 1, Bit=0: don$'t care",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_FdbkSt1State : SINT (Description := "(if checking) Bit=1: Feedback is 1 in State 1, Bit=0: Feedback is 0",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 2);
			Cfg_FdbkSt2Check : SINT (Description := "Bit=1: Check Feedback in state 2, Bit=0: don$'t care",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_FdbkSt2State : SINT (Description := "(if checking) Bit=1: Feedback is 1 in State 2, Bit=0: Feedback is 0",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 4);
			Cfg_FdbkSt3Check : SINT (Description := "Bit=1: Check Feedback in state 3, Bit=0: don$'t care",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_FdbkSt3State : SINT (Description := "(if checking) Bit=1: Feedback is 1 in State 3, Bit=0: Feedback is 0",
			                            Usage := Input,
			                            RADIX := Binary,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 8);
			Cfg_HasPerm0Obj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_PermOK0",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasPerm1Obj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_PermOK1",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasPerm2Obj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_PermOK2",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasPerm3Obj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_PermOK3",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasIntlkObj : BOOL (Description := "1=Tells HMI a P_Intlk is connected to Inp_IntlkOK",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OperSt0Prio : BOOL (Description := "1=OCmd_St0 any time, 0=OCmd_St0 only when Oper selected",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_ExtSt0Prio : BOOL (Description := "1=XCmd_St0 any time, 0=XCmd_St0 only when Ext selected",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OCmdResets : BOOL (Description := "1=New device OCmd resets shed latches and cleared alarms, 0=OCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_XCmdResets : BOOL (Description := "1=New device XCmd resets shed latches and cleared alarms, 0=XCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OvrdPermIntlk : BOOL (Description := "1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_ShedOnFail : BOOL (Description := "1=Go to State 0 and Alarm on Fail to reach position; 0=Alarm only on Fail",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_ShedOnDeviceFault : BOOL (Description := "1=Go to State 0 and Alarm on Device Fault; 0=Alarm only on Device Fault",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 0);
			Cfg_ShedOnIOFault : BOOL (Description := "1=Go to State 0 and Alarm on I/O Fault; 0=Alarm only on I/O Fault",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_HasFailAlm OF Fail.Cfg_Exists (Description := "1=Fail to reach state Alarm exists and will be checked",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			Cfg_HasDeviceFaultAlm OF DeviceFault.Cfg_Exists (Description := "1=Device Fault Alarm exists and will be checked",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_HasIntlkTripAlm OF IntlkTrip.Cfg_Exists (Description := "1=Interlock Trip Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=I/O Fault Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_HornOnChange : BOOL (Description := "0 = Horn on energize only, 1 = Horn on any state change",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_FailResetReqd OF Fail.Cfg_ResetReqd (Description := "1=Reset required to clear Fail to reach state Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_DeviceFaultResetReqd OF DeviceFault.Cfg_ResetReqd (Description := "1=Reset required to clear Device Fault Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			Cfg_IntlkTripResetReqd OF IntlkTrip.Cfg_ResetReqd (Description := "1=Reset required to clear Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Reset required to clear I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_FailAckReqd OF Fail.Cfg_AckReqd (Description := "1=Acknowledge required for Fail to reach state Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			Cfg_DeviceFaultAckReqd OF DeviceFault.Cfg_AckReqd (Description := "1=Acknowledge required for Device Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IntlkTripAckReqd OF IntlkTrip.Cfg_AckReqd (Description := "1=Acknowledge required for Interlock Trip Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Acknowledge required for I/O Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_FailSeverity OF Fail.Cfg_Severity (Description := "Fail to reach state Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_DeviceFaultSeverity OF DeviceFault.Cfg_Severity (Description := "Device Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_IntlkTripSeverity OF IntlkTrip.Cfg_Severity (Description := "Interlock Trip Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "I/O Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_OutAPulseT : REAL (Description := "Time to pulse Output A (sec) (0=output held continuously)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_OutBPulseT : REAL (Description := "Time to pulse Output B (sec) (0=output held continuously)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_OutCPulseT : REAL (Description := "Time to pulse Output C (sec) (0=output held continuously)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_OutDPulseT : REAL (Description := "Time to pulse Output D (sec) (0=output held continuously)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_SimFdbkT : REAL (Description := "Delay to echo back reaching state when in Simulation (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 2.00000000e+000);
			Cfg_StartHornT : REAL (Description := "Time to sound audible on commanded start (sec) (0=disabled)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_FailT : REAL (Description := "Time after new state requested to reach that state before Fault (sec)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 1.00000000e+001);
			PSet_Owner : DINT (Description := "Program Owner Request ID (non-zero) or Release (zero)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_St0 : BOOL (Description := "Program Command to set device to State 0",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			PCmd_St1 : BOOL (Description := "Program Command to set device to State 1",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			PCmd_St2 : BOOL (Description := "Program Command to set device to State 2",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			PCmd_St3 : BOOL (Description := "Program Command to set device to State 3",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			PCmd_Prog OF CmdSrc.PCmd_Prog (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Oper OF CmdSrc.PCmd_Oper (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Lock OF CmdSrc.PCmd_Lock (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Unlock OF CmdSrc.PCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Normal OF CmdSrc.PCmd_Normal (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Reset : BOOL (Description := "Program Command to ResetShed Latches and Cleared Alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_FailAck OF Fail.PCmd_Ack (Description := "Program Command to Acknowledge Fail to Reach Target Position Alarm",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No);
			PCmd_FailSuppress OF Fail.PCmd_Suppress (Description := "Program Command to Suppress Fail to Reach Target Position Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_FailUnsuppress OF Fail.PCmd_Unsuppress (Description := "Program Command to Unsuppress Fail to Reach Target Position Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_FailUnshelve OF Fail.PCmd_Unshelve (Description := "Program Command to Unshelve Fail to Reach Target Position Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_DeviceFaultAck OF DeviceFault.PCmd_Ack (Description := "Program Command to Acknowledge Device Fault  Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_DeviceFaultSuppress OF DeviceFault.PCmd_Suppress (Description := "Program Command to Suppress Device Fault Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_DeviceFaultUnsuppress OF DeviceFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress Device Fault Alarm",
			                                      Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No);
			PCmd_DeviceFaultUnshelve OF DeviceFault.PCmd_Unshelve (Description := "Program Command to Unshelve Device Fault Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripAck OF IntlkTrip.PCmd_Ack (Description := "Program Command to Acknowledge Interlock Trip Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_IntlkTripSuppress OF IntlkTrip.PCmd_Suppress (Description := "Program Command to Suppress Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IntlkTripUnsuppress OF IntlkTrip.PCmd_Unsuppress (Description := "Program Command to Unsuppress Interlock Trip Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripUnshelve OF IntlkTrip.PCmd_Unshelve (Description := "Program Command to Unshelve Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			MCmd_Rel OF CmdSrc.MCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			OCmd_Unlock OF CmdSrc.OCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			XCmd_St0 : BOOL (Description := "External Command to set device to State 0",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_St1 : BOOL (Description := "External Command to set device to State 1",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_St2 : BOOL (Description := "External Command to set device to State 2",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_St3 : BOOL (Description := "External Command to set device to State 3",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_Acq OF CmdSrc.XCmd_Acq (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Rel OF CmdSrc.XCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Reset : BOOL (Description := "External Command to reset shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Out_A : BOOL (Description := "Output A to Device",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			Out_B : BOOL (Description := "Output B to Device",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			Out_C : BOOL (Description := "Output C to Device",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			Out_D : BOOL (Description := "Output D to Device",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := Yes,
			                 ExternalAccess := Read Only,
			                 DefaultData := 0);
			Out_Horn : BOOL (Description := "1=Sound audible prior to commanded energize/ state change",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Cmd : DINT (Description := "Device Command 0=None, 1=State 0, 2=State 1, 3=State 2, 4=State 3",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Sts : DINT (Description := "Device Confirmed Sts 0=Powerup/Reset, 1=State0, 2=State1, 3=State2, 4=State3, 9=Moving",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=None, 16=PositionFail, 17=DeviceFault, 32=I/OFault, 34=CfgErr",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + channel (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_Owner : DINT (Description := "Current Object Owner ID (0=not owned)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_St0 : BOOL (Description := "1=Device commanded to and confirmed in State 0",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_St1 : BOOL (Description := "1=Device commanded to and confirmed in State 1",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_St2 : BOOL (Description := "1=Device commanded to and confirmed in State 2",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_St3 : BOOL (Description := "1=Device commanded to and confirmed in State 3",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_Moving : BOOL (Description := "1=Device not yet confirmed in commended state",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Horn : BOOL (Description := "1=Sound audible prior to commanded energize/ state change",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_Available : BOOL (Description := "1=Device available for control by automation (Prog)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Bypass : BOOL (Description := "1=Bypassable Interlocks and Permissives are Bypassed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_BypActive : BOOL (Description := "1=Interlock / Permissive Bypassing Active (Bypassed or Maintenance)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_NotRdy : BOOL (Description := "1=Device Not Ready, see detail bits for reason",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_CfgErr : BOOL (Description := "1=Device Not Ready: Configuration Error",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Nrdy_EqpFault : BOOL (Description := "1=Device Not Ready: External Equipment Fault (Fault or Shed Requires Reset)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Nrdy_Fail : BOOL (Description := "1=Device Not Ready: Device Failure (Shed Requires Reset)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Nrdy_Intlk : BOOL (Description := "1=Device Not Ready: Interlock Not OK",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_IOFault : BOOL (Description := "1=Device Not Ready: I/O Fault (Shed Requires Reset)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_OoS : BOOL (Description := "1=Device Not Ready: Device is Out of Service",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Nrdy_PrioSt0 : BOOL (Description := "1=Device Not Ready: Oper/Ext Priority State 0 Command Requires Reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_Perm : BOOL (Description := "1=Device Not Ready: Permissive Not OK",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=Device has a Maintenance Bypass function active",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=One or more Alarms Shelved, Disabled or Suppressed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Feeback Check timer preset (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Sim : BOOL (Description := "1=Error in Config: Simulation timer preset (use 0 to 2147483)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Hand OF CmdSrc.Sts_Hand (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OoS OF CmdSrc.Sts_OoS (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Maint OF CmdSrc.Sts_Maint (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only);
			Sts_Ovrd OF CmdSrc.Sts_Ovrd (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_Ext OF CmdSrc.Sts_Ext (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only);
			Sts_Prog OF CmdSrc.Sts_Prog (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_ProgLocked OF CmdSrc.Sts_ProgLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only);
			Sts_Oper OF CmdSrc.Sts_Oper (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OperLocked OF CmdSrc.Sts_OperLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only);
			Sts_Normal OF CmdSrc.Sts_Normal (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_ExtReqInh OF CmdSrc.Sts_ExtReqInh (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_ProgReqInh OF CmdSrc.Sts_ProgReqInh (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_MAcqRcvd OF CmdSrc.Sts_MAcqRcvd (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Fail OF Fail.Inp (Description := "1=Device failed to reach commended state",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Alm_Fail OF Fail.Alm (Description := "1=Alarm: Device failed to reach commended state",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Ack_Fail OF Fail.Ack (Description := "1=Fail to reach commanded state Alarm has been acknowledged",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write);
			Sts_FailDisabled OF Fail.Disabled (Description := "1=Fail to reach commanded state Alarm has been Disabled by Maintenance",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_FailShelved OF Fail.Shelved (Description := "1=Fail to reach commanded state Alarm has been Shelved by Operator",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_FailSuppressed OF Fail.Suppressed (Description := "1=Fail to reach commanded state alarm has been Suppressed by Program",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_DeviceFault OF DeviceFault.Inp (Description := "1=Device Fault (from Inp_DeviceFault)",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Alm_DeviceFault OF DeviceFault.Alm (Description := "1=Device Fault Alarm",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Ack_DeviceFault OF DeviceFault.Ack (Description := "1=Device Fault Alarm has been acknowledged",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_DeviceFaultDisabled OF DeviceFault.Disabled (Description := "1=Device Fault Alarm has been Disabled by Maintenance",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_DeviceFaultShelved OF DeviceFault.Shelved (Description := "1=Device Fault Alarm has been Shelved by Operator",
			                                  Usage := Output,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No,
			                                  ExternalAccess := Read/Write);
			Sts_DeviceFaultSuppressed OF DeviceFault.Suppressed (Description := "1=Device Fault Alarm has been Suppressed by Program",
			                                     Usage := Output,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No,
			                                     ExternalAccess := Read/Write);
			Sts_IntlkTrip OF IntlkTrip.Inp (Description := "1=Device commanded to State 0 by an Interlock NOT OK (one-shot)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_IntlkTrip OF IntlkTrip.Alm (Description := "1=Alarm: Device set to State 0 by an Interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_IntlkTrip OF IntlkTrip.Ack (Description := "1=Interlock Trip Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_IntlkTripDisabled OF IntlkTrip.Disabled (Description := "1=Interlock Trip Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTripShelved OF IntlkTrip.Shelved (Description := "1=Interlock Trip Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_IntlkTripSuppressed OF IntlkTrip.Suppressed (Description := "1=Interlock Trip Alarm has been Suppressed by Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "I/O Comm Fault Status (0=OK, 1=Bad)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=I/O Fault Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			MRdy_Rel OF CmdSrc.MRdy_Rel (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			ORdy_Unlock OF CmdSrc.ORdy_Unlock (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only);
			P_D4SD : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_OutDPulseT : TIMER (Description := "Output D Pulse Timer",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_OutCPulseT : TIMER (Description := "Output C Pulse Timer",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_OutBPulseT : TIMER (Description := "Output B Pulse Timer",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_OutAPulseT : TIMER (Description := "Output A Pulse Timer",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Bypass : BOOL (Description := "Internal Bypassable Permissives and Interlocks are Bypassed flag",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_ActState : DINT (Description := "Actual State (enum)",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Fail : P_Alarm (Description := "Device Fail to reach commanded position",
			               ExternalAccess := Read/Write,
			               DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20,'Dev Position Failure'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			DeviceFault : P_Alarm (Description := "Device Fault from device via input",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Dev-Reported Fault$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			CmdSrc : P_CmdSrc (Description := "Control / Command Source Selection",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[7649,2048,0,1,0,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']]");
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			IntlkTrip : P_Alarm (Description := "Interlock Trip Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_ONS : SINT (Description := "One-Shot Store Bits",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Out : SINT (Description := "Outputs (buffered) as a SINT for byte-wise operations",
			                  RADIX := Binary,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_FdbkState : DINT (Description := "State(s) of device as shown by feedbacks",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[6,'P_D4SD$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[15,'Discrete Device$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[20,'Discrete 2, 3 or 4 S$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_St3Text : STRING_8 (Description := "Text to display in State 3",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[0,'$00$00$00$00$00$00$00$00']");
			Cfg_St2Text : STRING_8 (Description := "Text to display in State 2",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[0,'$00$00$00$00$00$00$00$00']");
			Cfg_St1Text : STRING_8 (Description := "Text to display in State 1",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[2,'On$00$00$00$00$00$00']");
			Cfg_St0Text : STRING_8 (Description := "Text to display in State 0",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[3,'Off$00$00$00$00$00']");
			Wrk_PermOK3 : BOOL (Description := "1=Permissives are OK to go to state 3",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_PermOK2 : BOOL (Description := "1=Permissives are OK to go to state 2",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_PermOK1 : BOOL (Description := "1=Permissives are OK to go to state 1",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_PermOK0 : BOOL (Description := "1=Permissives are OK to go to state 0",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_TgtState : DINT (Description := "Target device state as a number (0, 1, 2 or 3)",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_SimT : TIMER (Description := "Time $Qmoving$Q before going to target pos. in simulation",
			                   ExternalAccess := None,
			                   DefaultData := "[0,0,0]");
			Wrk_FailT : TIMER (Description := "Failure Check timer (time to reach target position)",
			                    ExternalAccess := Read Only,
			                    DefaultData := "[0,0,0]");
			Wrk_NewCmd : BOOL (Description := "1=A state command has been received (even for same state)",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_PrevTgt : DINT (Description := "Previous Target State (last scan)",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			HMI_Type : STRING_16 (Description := "Type identifier for HMI navigation",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[6,'P_D4SD$00$00$00$00$00$00$00$00$00$00']");
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Wrk_Sts : DINT (Description := "Buffer for building Val_Sts",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Val_Notify : DINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wrk_NotRdy : BOOL (Description := "Device Not Ready conditions excluding shed latches",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_NotRdy1 : BOOL (Description := "Device Not Ready excluding only Permissives",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_NoLongerSim : BOOL (Description := "Switched from Simulated to Real Device this scan",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=At least one Alarm or latched Shed requires Reset or Ack",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=At least one Alarm or latched Shed requires Reset",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_St3 : BOOL (Description := "1=Ready for OCmd_St3, enable HMI button",
			                   RADIX := Decimal,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			ORdy_St2 : BOOL (Description := "1=Ready for OCmd_St2, enable HMI button",
			                   RADIX := Decimal,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			ORdy_St1 : BOOL (Description := "1=Ready for OCmd_St1, enable HMI button",
			                   RADIX := Decimal,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			ORdy_St0 : BOOL (Description := "1=Ready for OCmd_St0, enable HMI button",
			                   RADIX := Decimal,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			MRdy_Check : BOOL (Description := "1=Ready for MCmd_Check, enable HMI button",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Bypass : BOOL (Description := "1=Ready for MCmd_Bypass, enable HMI button",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			OCmd_ResetAckAll : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms, plus  Acknowledge alarms",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			OCmd_St3 : BOOL (Description := "Operator Command to set device to State 3",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
			OCmd_St2 : BOOL (Description := "Operator Command to set device to State 2",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
			OCmd_St1 : BOOL (Description := "Operator Command to set device to State 1",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
			OCmd_St0 : BOOL (Description := "Operator Command to set device to State 0",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
			MCmd_Check : BOOL (Description := "Maintenance Command to Check Interlocks and Permissives",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Bypass : BOOL (Description := "Maintenance Command to Bypass Interlocks and Permissives",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			Wrk_StartHornT : TIMER (Description := "Timer for audible alert or start",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_StartHorn : BOOL (Description := "1=Sound audible prior to commanded energize/ state change",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_TgtStateTmp : DINT (Description := "Target device state as a number (0, 1, 2 or 3) stored, before audible alert",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_AfterHornONS : BOOL (RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_AfterHornONS2 : BOOL (RADIX := Decimal,
			                            ExternalAccess := None,
			                            DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Out of Service is asserted; Outputs OFF; Device Status shown based on feedbacks if possible, but Alarms inhibited")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "Handle $QProgrammed Out of Servie$Q Selection using the standard$N"
				    "P_CmdSrc AOI (EnableInFalse Routine, false scan required!).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc.  #####";
				N: XIC(EnableIn)P_CmdSrc(CmdSrc);
				RC: "First-Come First-Served Ownership Arbitration still needs to happen, even when device is disabled.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "$QLurking$Q Commands are cleared, as well as Program Reset.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(PCmd_St0) OTU(PCmd_St1) OTU(PCmd_St2) OTU(PCmd_St3) ,OTU(OCmd_St0) OTU(OCmd_St1) OTU(OCmd_St2) OTU(OCmd_St3) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(PCmd_Reset) ];
				RC: "The Override Command is set to NONE.";
				N: CLR(Inp_OvrdCmd);
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_St0) OTU(ORdy_St1) OTU(ORdy_St2) OTU(ORdy_St3) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) ];
				RC: "Clear the latched Shed faults, and reset the output pulse, fault, and simulation timers.";
				N: [RES(Wrk_OutAPulseT) RES(Wrk_OutBPulseT) RES(Wrk_OutCPulseT) RES(Wrk_OutDPulseT) ,RES(Wrk_FailT) RES(Wrk_SimT) ];
				RC: "Outputs are cleared when Disabled.$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: CLR(Wrk_Out)OTU(Out_A)OTU(Out_B)OTU(Out_C)OTU(Out_D)OTU(Out_Horn)OTU(Wrk_StartHorn);
				RC: "Show the device as Out of Service and Not Ready, not Available, and with no$N"
				    "Maintenance Bypass breadcrumb.$N"
				    "Clear remaining Status bits.$N"
				    "Show the enumerated device command as NONE.$N"
				    "Show the enumerated device status as UNKNOWN.$N"
				    "Show the enumerated device fault status as NONE.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable and NoMode replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [OTU(Sts_St0) OTU(Sts_St1) OTU(Sts_St2) OTU(Sts_St3) ,OTU(Sts_Moving) OTU(Sts_Available) OTU(Sts_MaintByp) OTL(Sts_NotRdy) ,OTU(Nrdy_CfgErr) OTU(Nrdy_EqpFault) OTU(Nrdy_Fail) OTU(Nrdy_Intlk) ,OTU(Nrdy_IOFault) OTL(Nrdy_OoS) OTU(Nrdy_PrioSt0) OTU(Nrdy_Perm) ,CLR(Val_Cmd) CLR(Val_Sts) CLR(Val_Fault) ];
				RC: "If the device is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then show the alarms as $QParent object out of service$Q.$N"
				    "Show the overall acknowledgement status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc, added Out of Service.  #####";
				N: [OTL(Fail.Inp_OoS) P_Alarm(Fail) ,OTL(DeviceFault.Inp_OoS) P_Alarm(DeviceFault) ,OTL(IntlkTrip.Inp_OoS) P_Alarm(IntlkTrip) ,OTL(IOFault.Inp_OoS) P_Alarm(IOFault) ,CLR(Val_Notify) CLR(Val_NotifyAll) ,[XIC(Fail.Val_Notify.0) ,XIC(DeviceFault.Val_Notify.0) ,XIC(IntlkTrip.Val_Notify.0) ,XIC(IOFault.Val_Notify.0) ] OTL(Val_Notify.0) OTL(Val_NotifyAll.0) ,[XIC(Fail.Sts_AlmInh) ,XIC(DeviceFault.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ] OTE(Sts_AlmInh) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(20,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(20,SrcQ);
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan: control / monitor 2-, 3- or 4-State device")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_D4SD:  PROCESS -- DISCRETE 4-STATE DEVICE$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-17:  See V4.10.xx Release Notes for details.$N"
				    "V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-07-16:  Changed $QMode$Q to $QCommand Source$Q. Changed Inf_ items$N"
				    "to HMI_, and added Cfg_Area for security. Added unacked alarm count.$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_AckReqd and Sts_ResetReqd for use by external objects.$N"
				    "Changed delay / time configuration items to REAL seconds.$N"
				    "V4.10.00  2019-03-08:  Changed availability to use input availability from interlocks.$N"
				    "Added audible alert on commanded energize/state change.$N"
				    "Added Inp_HornInh to disable Horn operation.$N"
				    "Modified logic to correct confgigurable shed action.$N"
				    "Updated to P_CmdSrc V4.10.00. Added Cfg_HasMoreObj.$N"
				    "V4.10.01  2019-10-17:  No changes, uprevved because P_CmdSrc 4.10.01 is used.$N"
				    "============================================================$N"
				    "This Instruction controls and monitors feedback from$N"
				    "a Discrete 2-State, 3-State or 4-State Device, and provides:$N"
				    "$N"
				    "*  Operator and Program Commands to select one of the 2, 3 or 4 states$N"
				    "*  User-configurable text labels for the states$N"
				    "*  Per-State setting, clearing or holding of four user-configurable outputs$N"
				    "*  Per-State monitoring of four feedbacks (on, off or don$'t care) to confirm state$N"
				    "*  Detection of failure to reach the target state (when feedbacks are used)$N"
				    "*  Monitoring of Permissive conditions to allow commanding to each state$N"
				    "*  Monitoring of Interlock conditions to return device to State 0$N"
				    "*  Simulation, providing feedback of a working device while$N"
				    "      disabling output (keeping de-energized)$N"
				    "*  Monitoring of I/O communication status$N"
				    "*  Alarms for Fail to reach target state (if feedbacks are used), Device Failure$N"
				    "(reported by device using an input), Interlock Trip, I/O Fault$N"
				    "*  $QAvailable$Q status for use by automation logic to know whether$N"
				    "     the device can be controlled by other objects.$N"
				    "$N"
				    "Command Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$N"
				    "Command Sources: Operator, Program, External, Override, Maintenance, Out of$N"
				    "Service, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)LOWER(Cfg_Desc,Cfg_Label)LOWER(Cfg_Tag,Cfg_Area)LOWER(Cfg_St0Text,Cfg_St1Text)LOWER(Cfg_St2Text,Cfg_St3Text)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "COMMAND SOURCE PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Command Source selection Inputs and Commands:$N"
				    "$N"
				    "NOTE:  All Commands for Command Source and Alarm are aliased directly to the$N"
				    "corresponding Commands in the contained P_CmdSrc and P_Alarm AOIs.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc.  #####";
				N: LBL(SkipText)P_CmdSrc(CmdSrc);
				RC: "This rung handles simple First-Come First-Served Ownership Arbitration.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "============================================================$N"
				    "CONFIGURATION PROCESSING$N"
				    "============================================================$N"
				    "These rungs check Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration data are used directly in-place.$N"
				    "$N"
				    "Clamp the number of device states to be 2, 3 or 4.";
				N: [GRT(Cfg_NumStates,4) MOV(4,Cfg_NumStates) ,LES(Cfg_NumStates,2) MOV(2,Cfg_NumStates) ];
				RC: "Enter the time (in seconds) for the device to successfully turn ON before declaring a fault.$N"
				    "Enter the time (in seconds) for the device to successfully turn OFF before declaring a fault.$N"
				    "$N"
				    "If the timer preset calcuated wraps negative (more than 2.14... million seconds), then use a default$N"
				    "limit value and report Bad Configuration.  Note that a negative timer preset will fault the controller!!!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed delay / time configuration items to REAL seconds.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  Added Inp_HornInh to disable Horn operation.  #####";
				N: [[MUL(Cfg_FailT,1000.0,Wrk_FailT.PRE) XIC(Wrk_FailT.PRE.31) MOV(2147483647,Wrk_FailT.PRE) ,MUL(Cfg_OutAPulseT,1000.0,Wrk_OutAPulseT.PRE) XIC(Wrk_OutAPulseT.PRE.31) CLR(Wrk_OutAPulseT.PRE) ,MUL(Cfg_OutBPulseT,1000.0,Wrk_OutBPulseT.PRE) XIC(Wrk_OutBPulseT.PRE.31) CLR(Wrk_OutBPulseT.PRE) ,MUL(Cfg_OutCPulseT,1000.0,Wrk_OutCPulseT.PRE) XIC(Wrk_OutCPulseT.PRE.31) CLR(Wrk_OutCPulseT.PRE) ,MUL(Cfg_OutDPulseT,1000.0,Wrk_OutDPulseT.PRE) XIC(Wrk_OutDPulseT.PRE.31) CLR(Wrk_OutDPulseT.PRE) ,MUL(Cfg_StartHornT,1000.0,Wrk_StartHornT.PRE) XIC(Wrk_StartHornT.PRE.31) CLR(Wrk_StartHornT.PRE) ] OTE(Err_Timer) ,[XIC(Inp_HornInh) ,GRT(Cfg_StartHornT,1000.0) CLR(Cfg_StartHornT) ] CLR(Wrk_StartHornT.PRE) ];
				RC: "Enter the time (in seconds) to echo back the desired state when running in simulation$N"
				    "$N"
				    "Handle timer preset invalid values as above.";
				N: MUL(Cfg_SimFdbkT,1000.0,Wrk_SimT.PRE)XIC(Wrk_SimT.PRE.31)MOV(0,Wrk_SimT.PRE)OTE(Err_Sim);
				RC: "This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N"
				    "(in the Configuration handling section).";
				N: [XIC(Err_Timer) ,XIC(Err_Sim) ]OTE(Nrdy_CfgErr);
				RC: "============================================================$N"
				    "DEVICE FEEDBACK HANDLING$N"
				    "============================================================$N"
				    "If the feedbacks are in the positions required by State 0 (ignoring any$N"
				    "Don$'t Care Feedbacks), then the device COULD be in STATE 0.$N"
				    "(It IS in State 0 if it$'s being commanded there, but multiple$N"
				    "states COULD have the same feedback configuration!)";
				N: [XIO(Inp_Sim) [XIC(Cfg_FdbkSt0Check.0) [XIC(Inp_FdbkA) XIC(Cfg_FdbkSt0State.0) ,XIO(Inp_FdbkA) XIO(Cfg_FdbkSt0State.0) ] ,XIO(Cfg_FdbkSt0Check.0) ] [XIC(Cfg_FdbkSt0Check.1) [XIC(Inp_FdbkB) XIC(Cfg_FdbkSt0State.1) ,XIO(Inp_FdbkB) XIO(Cfg_FdbkSt0State.1) ] ,XIO(Cfg_FdbkSt0Check.1) ] [XIC(Cfg_FdbkSt0Check.2) [XIC(Inp_FdbkC) XIC(Cfg_FdbkSt0State.2) ,XIO(Inp_FdbkC) XIO(Cfg_FdbkSt0State.2) ] ,XIO(Cfg_FdbkSt0Check.2) ] [XIC(Cfg_FdbkSt0Check.3) [XIC(Inp_FdbkD) XIC(Cfg_FdbkSt0State.3) ,XIO(Inp_FdbkD) XIO(Cfg_FdbkSt0State.3) ] ,XIO(Cfg_FdbkSt0Check.3) ] ,XIC(Inp_Sim) [XIC(Wrk_SimT.DN) ,EQU(Wrk_ActState,0) ] EQU(Wrk_TgtState,0) ]OTE(Wrk_FdbkState.0);
				RC: "If the feedbacks are in the positions required by State 1 (ignoring any$N"
				    "Don$'t Care Feedbacks), then the device COULD be in STATE 1.$N"
				    "(It IS in State 1 if it$'s being commanded there, but multiple$N"
				    "states COULD have the same feedback configuration!)";
				N: [XIO(Inp_Sim) [XIC(Cfg_FdbkSt1Check.0) [XIC(Inp_FdbkA) XIC(Cfg_FdbkSt1State.0) ,XIO(Inp_FdbkA) XIO(Cfg_FdbkSt1State.0) ] ,XIO(Cfg_FdbkSt1Check.0) ] [XIC(Cfg_FdbkSt1Check.1) [XIC(Inp_FdbkB) XIC(Cfg_FdbkSt1State.1) ,XIO(Inp_FdbkB) XIO(Cfg_FdbkSt1State.1) ] ,XIO(Cfg_FdbkSt1Check.1) ] [XIC(Cfg_FdbkSt1Check.2) [XIC(Inp_FdbkC) XIC(Cfg_FdbkSt1State.2) ,XIO(Inp_FdbkC) XIO(Cfg_FdbkSt1State.2) ] ,XIO(Cfg_FdbkSt1Check.2) ] [XIC(Cfg_FdbkSt1Check.3) [XIC(Inp_FdbkD) XIC(Cfg_FdbkSt1State.3) ,XIO(Inp_FdbkD) XIO(Cfg_FdbkSt1State.3) ] ,XIO(Cfg_FdbkSt1Check.3) ] ,XIC(Inp_Sim) [XIC(Wrk_SimT.DN) ,EQU(Wrk_ActState,1) ] EQU(Wrk_TgtState,1) ]OTE(Wrk_FdbkState.1);
				RC: "If the feedbacks are in the positions required by State 2 (ignoring any$N"
				    "Don$'t Care Feedbacks), then the device COULD be in STATE 2.$N"
				    "(It IS in State 2 if it$'s being commanded there, but multiple$N"
				    "states COULD have the same feedback configuration!)";
				N: GEQ(Cfg_NumStates,3)[XIO(Inp_Sim) [XIC(Cfg_FdbkSt2Check.0) [XIC(Inp_FdbkA) XIC(Cfg_FdbkSt2State.0) ,XIO(Inp_FdbkA) XIO(Cfg_FdbkSt2State.0) ] ,XIO(Cfg_FdbkSt2Check.0) ] [XIC(Cfg_FdbkSt2Check.1) [XIC(Inp_FdbkB) XIC(Cfg_FdbkSt2State.1) ,XIO(Inp_FdbkB) XIO(Cfg_FdbkSt2State.1) ] ,XIO(Cfg_FdbkSt2Check.1) ] [XIC(Cfg_FdbkSt2Check.2) [XIC(Inp_FdbkC) XIC(Cfg_FdbkSt2State.2) ,XIO(Inp_FdbkC) XIO(Cfg_FdbkSt2State.2) ] ,XIO(Cfg_FdbkSt2Check.2) ] [XIC(Cfg_FdbkSt2Check.3) [XIC(Inp_FdbkD) XIC(Cfg_FdbkSt2State.3) ,XIO(Inp_FdbkD) XIO(Cfg_FdbkSt2State.3) ] ,XIO(Cfg_FdbkSt2Check.3) ] ,XIC(Inp_Sim) [XIC(Wrk_SimT.DN) ,EQU(Wrk_ActState,2) ] EQU(Wrk_TgtState,2) ]OTE(Wrk_FdbkState.2);
				RC: "If the feedbacks are in the positions required by State 3 (ignoring any$N"
				    "Don$'t Care Feedbacks), then the device COULD be in STATE 3.$N"
				    "(It IS in State 3 if it$'s being commanded there, but multiple$N"
				    "states COULD have the same feedback configuration!)";
				N: GEQ(Cfg_NumStates,4)[XIO(Inp_Sim) [XIC(Cfg_FdbkSt3Check.0) [XIC(Inp_FdbkA) XIC(Cfg_FdbkSt3State.0) ,XIO(Inp_FdbkA) XIO(Cfg_FdbkSt3State.0) ] ,XIO(Cfg_FdbkSt3Check.0) ] [XIC(Cfg_FdbkSt3Check.1) [XIC(Inp_FdbkB) XIC(Cfg_FdbkSt3State.1) ,XIO(Inp_FdbkB) XIO(Cfg_FdbkSt3State.1) ] ,XIO(Cfg_FdbkSt3Check.1) ] [XIC(Cfg_FdbkSt3Check.2) [XIC(Inp_FdbkC) XIC(Cfg_FdbkSt3State.2) ,XIO(Inp_FdbkC) XIO(Cfg_FdbkSt3State.2) ] ,XIO(Cfg_FdbkSt3Check.2) ] [XIC(Cfg_FdbkSt3Check.3) [XIC(Inp_FdbkD) XIC(Cfg_FdbkSt3State.3) ,XIO(Inp_FdbkD) XIO(Cfg_FdbkSt3State.3) ] ,XIO(Cfg_FdbkSt3Check.3) ] ,XIC(Inp_Sim) [XIC(Wrk_SimT.DN) ,EQU(Wrk_ActState,3) ] EQU(Wrk_TgtState,3) ]OTE(Wrk_FdbkState.3);
				N: [MOV(-1,Wrk_ActState) ,XIC(Wrk_FdbkState.0) EQU(Wrk_TgtState,0) MOV(0,Wrk_ActState) ,XIC(Wrk_FdbkState.1) EQU(Wrk_TgtState,1) MOV(1,Wrk_ActState) ,XIC(Wrk_FdbkState.2) EQU(Wrk_TgtState,2) MOV(2,Wrk_ActState) ,XIC(Wrk_FdbkState.3) EQU(Wrk_TgtState,3) MOV(3,Wrk_ActState) ];
				RC: "============================================================$N"
				    "INTERLOCK / PERMISSIVE BYPASS / CHECK COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Bypass Command bypasses the Bypassable Permissives and Interlocks.";
				N: XIC(MCmd_Bypass)OTU(MCmd_Bypass)OTL(Wrk_Bypass);
				RC: "The Check Command enables checking of ALL$N"
				    "Permissives and Interlocks (cancels the bypass).";
				N: XIC(MCmd_Check)OTU(MCmd_Check)OTU(Wrk_Bypass);
				RC: "If the internal Bypass flag is set, Bypassable Interlocks and Permissives ARE BYPASSED.$N"
				    "Bypassing is ACTIVE if Bypass selected OR in Maintenance,$N"
				    "or in Override if Override Bypassing is configured.";
				N: [XIC(Wrk_Bypass) OTE(Sts_Bypass) ,XIC(Sts_Maint) ,XIC(Sts_Ovrd) XIC(Cfg_OvrdPermIntlk) ]OTE(Sts_BypActive);
				RC: "If a Maintenance Bypass function is active, display the Maintenance Bypass$N"
				    "Indicator (triangle symbol) on the graphic symbol.  Bypass functions are:$N"
				    "*  Interlock / Permissive Bypass function is enabled";
				N: XIC(Sts_Bypass)OTE(Sts_MaintByp);
				RC: "Ready for Interlock / Permissive Bypass if not bypassed.$N"
				    "Ready to cancel Bypass (resume checking) if bypassed.";
				N: [XIO(Wrk_Bypass) OTE(MRdy_Bypass) ,XIC(Wrk_Bypass) OTE(MRdy_Check) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "This rung processes received Reset Commands from:$N"
				    "$N"
				    "1.  The Operator via HMI Operator Command, or$N"
				    "2.  Higher-level strategies via Program Command$N"
				    "3.  Pushbuttons or other block via Input$N"
				    "4.  Resets initiated by other device Operator Commands (if configured to do so)$N"
				    "$N"
				    "and forwards the Reset to ALL Alarms and latched Shed conditions.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(XCmd_Reset) OTU(XCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ,[XIC(OCmd_St0) XIC(Wrk_PermOK0) ,XIC(OCmd_St1) XIC(Wrk_PermOK1) ,GEQ(Cfg_NumStates,3) XIC(OCmd_St2) XIC(Wrk_PermOK2) ,GEQ(Cfg_NumStates,4) XIC(OCmd_St3) XIC(Wrk_PermOK3) ] XIC(Cfg_OCmdResets) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,[XIC(XCmd_St0) XIC(Wrk_PermOK0) ,XIC(XCmd_St1) XIC(Wrk_PermOK1) ,GEQ(Cfg_NumStates,3) XIC(XCmd_St2) XIC(Wrk_PermOK2) ,GEQ(Cfg_NumStates,4) XIC(XCmd_St3) XIC(Wrk_PermOK3) ] XIC(Cfg_XCmdResets) XIC(Sts_Ext) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(PCmd_FailAck) ,OTL(PCmd_DeviceFaultAck) ,OTL(PCmd_IntlkTripAck) ,OTL(PCmd_IOFaultAck) ] ][OTL(Fail.PCmd_Reset) OTL(DeviceFault.PCmd_Reset) ,OTL(IntlkTrip.PCmd_Reset) OTL(IOFault.PCmd_Reset) ,XIC(Sts_Fail) RES(Wrk_FailT) ,OTU(Nrdy_PrioSt0) OTU(Nrdy_Fail) ,[XIO(Inp_IOFault) ,XIC(Inp_Sim) ] OTU(Nrdy_IOFault) ,[XIO(Inp_DeviceFault) ,XIC(Inp_Sim) ] OTU(Nrdy_EqpFault) ];
				RC: "============================================================$N"
				    "DEVICE COMMAND HANDLING$N"
				    "============================================================$N"
				    "The rungs in this section handle commands for this Device, received$N"
				    "in Operator, Program, Override and Maintenance.$N"
				    "(Hand command source is handled separately, below.$N"
				    "$N"
				    "For a command to any state, permissives for that state must be OK.";
				N: [[XIC(Inp_PermOK0) ,XIC(Sts_BypActive) ] XIC(Inp_NBPermOK0) OTE(Wrk_PermOK0) ,[XIC(Inp_PermOK1) ,XIC(Sts_BypActive) ] XIC(Inp_NBPermOK1) OTE(Wrk_PermOK1) ,[XIC(Inp_PermOK2) ,XIC(Sts_BypActive) ] XIC(Inp_NBPermOK2) OTE(Wrk_PermOK2) ,[XIC(Inp_PermOK3) ,XIC(Sts_BypActive) ] XIC(Inp_NBPermOK3) OTE(Wrk_PermOK3) ];
				RC: "The Device is READY to change state unless:$N"
				    "the device is disabled,$N"
				    "there is an error in device configuration,$N"
				    "interlocks are not OK,$N"
				    "permissives are not OK (for any move),$N"
				    "or there is any latched shed fault.$N"
				    "Shed faults include:$N"
				    "failure to reach target position, and,$N"
				    "if not in simulation, a device-reported fault or I/O fault.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Sts_OoS) OTE(Nrdy_OoS) ,XIC(Nrdy_CfgErr) ,[XIO(Inp_IntlkOK) XIO(Sts_BypActive) ,XIO(Inp_NBIntlkOK) ] [NEQ(Wrk_TgtState,0) OTE(Sts_IntlkTrip) ,OTE(Nrdy_Intlk) ] ,XIO(Inp_Sim) [XIC(Inp_DeviceFault) OTE(Sts_DeviceFault) XIC(Cfg_ShedOnDeviceFault) OTL(Nrdy_EqpFault) ,XIC(Inp_IOFault) OTE(Sts_IOFault) XIC(Cfg_ShedOnIOFault) OTL(Nrdy_IOFault) ] ]OTE(Wrk_NotRdy);
				RC: "The Device is READY to change state unless:$N"
				    "the device is disabled,$N"
				    "there is an error in device configuration,$N"
				    "interlocks are not OK,$N"
				    "permissives are not OK (for any move),$N"
				    "or there is any latched shed fault.$N"
				    "Shed faults include:$N"
				    "failure to reach target position, and,$N"
				    "if not in simulation, a device-reported fault or I/O fault.";
				N: [XIC(Wrk_NotRdy) ,XIC(Nrdy_PrioSt0) ,XIC(Nrdy_Fail) ,XIC(Nrdy_EqpFault) ,XIC(Nrdy_IOFault) ]OTE(Wrk_NotRdy1);
				N: [XIC(Wrk_NotRdy1) ,[EQU(Wrk_TgtState,0) XIO(Wrk_PermOK1) [XIO(Wrk_PermOK2) ,LES(Cfg_NumStates,3) ] [XIO(Wrk_PermOK3) ,LES(Cfg_NumStates,4) ] ,EQU(Wrk_TgtState,1) XIO(Wrk_PermOK0) [XIO(Wrk_PermOK2) ,LES(Cfg_NumStates,3) ] [XIO(Wrk_PermOK3) ,LES(Cfg_NumStates,4) ] ,EQU(Wrk_TgtState,2) XIO(Wrk_PermOK0) XIO(Wrk_PermOK1) [XIO(Wrk_PermOK3) ,LES(Cfg_NumStates,4) ] ,EQU(Wrk_TgtState,3) XIO(Wrk_PermOK0) XIO(Wrk_PermOK1) [XIO(Wrk_PermOK2) ,LES(Cfg_NumStates,3) ] ] OTE(Nrdy_Perm) ]OTE(Sts_NotRdy);
				RC: "If the device isn$'t $Qnot ready$Q (it IS ready) and it$'s in Program,$N"
				    "then it is AVAILABLE to be controlled by automation (Program logic).$N"
				    "#####  V4.10.00  2019-03-08:  Changed availability to use input availability from interlocks.  #####";
				N: XIC(Sts_Prog)XIO(Nrdy_OoS)XIO(Nrdy_CfgErr)XIO(Nrdy_PrioSt0)XIO(Nrdy_Fail)XIO(Nrdy_EqpFault)XIO(Nrdy_IOFault)XIO(Nrdy_Perm)[[XIC(Inp_IntlkOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBIntlkOK) ,XIC(Inp_IntlkAvail) ]OTE(Sts_Available);
				RC: "If a Device STATE 0 command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is STATE 0$N"
				    "mark the Device Target State as STATE 0.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_St0) OTU(OCmd_St0) [XIC(Sts_Oper) ,XIC(Sts_Maint) ,XIC(Cfg_OperSt0Prio) XIO(Sts_Oper) XIO(Sts_Maint) OTL(Nrdy_PrioSt0) ] ,XIC(XCmd_St0) OTU(XCmd_St0) [XIC(Sts_Ext) ,XIC(Cfg_ExtSt0Prio) XIO(Sts_Ext) OTL(Nrdy_PrioSt0) ] ,XIC(PCmd_St0) OTU(PCmd_St0) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,1) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]NEQ(Wrk_ActState,0)XIC(Wrk_PermOK0)XIO(Sts_NotRdy)[ONS(Wrk_ONS.0) OTL(Wrk_NewCmd) ,CLR(Wrk_TgtStateTmp) ];
				RC: "If a Device STATE 1 command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is STATE 1$N"
				    "mark the Device Target State as STATE 1.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_St1) OTU(OCmd_St1) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_St1) OTU(XCmd_St1) XIC(Sts_Ext) ,XIC(PCmd_St1) OTU(PCmd_St1) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,2) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]NEQ(Wrk_ActState,1)XIC(Wrk_PermOK1)XIO(Sts_NotRdy)[ONS(Wrk_ONS.1) OTL(Wrk_NewCmd) ,MOV(1,Wrk_TgtStateTmp) ];
				RC: "If a Device STATE 2 command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is STATE 2$N"
				    "mark the Device Target State as STATE 2.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_St2) OTU(OCmd_St2) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_St2) OTU(XCmd_St2) XIC(Sts_Ext) ,XIC(PCmd_St2) OTU(PCmd_St2) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,3) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]GEQ(Cfg_NumStates,3)NEQ(Wrk_ActState,2)XIC(Wrk_PermOK2)XIO(Sts_NotRdy)[ONS(Wrk_ONS.2) OTL(Wrk_NewCmd) ,MOV(2,Wrk_TgtStateTmp) ];
				RC: "If a Device STATE 3 command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is STATE 3$N"
				    "mark the Device Target State as STATE 3.$N"
				    "$N"
				    "######  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_St3) OTU(OCmd_St3) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_St3) OTU(XCmd_St3) XIC(Sts_Ext) ,XIC(PCmd_St3) OTU(PCmd_St3) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,4) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]GEQ(Cfg_NumStates,4)NEQ(Wrk_ActState,3)XIC(Wrk_PermOK3)XIO(Sts_NotRdy)[ONS(Wrk_ONS.3) OTL(Wrk_NewCmd) ,MOV(3,Wrk_TgtStateTmp) ];
				RC: "Set Start Horn on Commanded Change$N"
				    "Remove Siren Request When not Ready (even if permissives fall away)$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIC(Wrk_NewCmd) [XIC(Cfg_HornOnChange) ,EQU(Wrk_ActState,0) ] OTL(Wrk_StartHorn) ,XIC(Sts_NotRdy) OTU(Wrk_StartHorn) ];
				RC: "Only after autible alert do we allow commanded stated to become the target state$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIO(Wrk_StartHorn) ONS(Wrk_AfterHornONS) ,XIC(Wrk_NewCmd) XIO(Cfg_HornOnChange) NEQ(Wrk_ActState,0) ONS(Wrk_AfterHornONS2) ]MOV(Wrk_TgtStateTmp,Wrk_TgtState);
				RC: "Highest Priority: HAND always wins:$N"
				    "If in Hand, have the device follow the feedback as closely as possible.$N"
				    "$QAs closely as possible$Q means:$N"
				    "$N"
				    "* If the feedbacks match a unique state, set the device target to that state$N"
				    "(first four branches).$N"
				    "$N"
				    "* If the feedbacks are NOT unique, then:$N"
				    "-  if the feedback for the current state is made or no feedbacks are made, stay in the current state$N"
				    "(no action, so no branch for this condition)$N"
				    "$N"
				    "-  if multiple feedbacks are made but not the one for the current state, go to the lowest-numbered$N"
				    "state of the feedbacks that are made (bottom branch and its nested branches).$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIC(Sts_Hand) ,XIO(Inp_Sim) ONS(Wrk_NoLongerSim) ,XIC(S:FS) ]OTU(Wrk_StartHorn)[EQU(Wrk_FdbkState,8) MOV(3,Wrk_TgtState) ,EQU(Wrk_FdbkState,4) MOV(2,Wrk_TgtState) ,EQU(Wrk_FdbkState,2) MOV(1,Wrk_TgtState) ,EQU(Wrk_FdbkState,1) MOV(0,Wrk_TgtState) ,NEQ(Wrk_FdbkState,1) NEQ(Wrk_FdbkState,2) NEQ(Wrk_FdbkState,4) NEQ(Wrk_FdbkState,8) [XIO(Wrk_FdbkState.0) ,NEQ(Wrk_TgtState,0) ] [XIO(Wrk_FdbkState.1) ,NEQ(Wrk_TgtState,1) ] [XIO(Wrk_FdbkState.2) ,NEQ(Wrk_TgtState,2) ,GEQ(Cfg_NumStates,3) ] [XIO(Wrk_FdbkState.3) ,NEQ(Wrk_TgtState,3) ,GEQ(Cfg_NumStates,4) ] [GEQ(Cfg_NumStates,3) XIC(Wrk_FdbkState.2) MOV(2,Wrk_TgtState) ,XIC(Wrk_FdbkState.1) MOV(1,Wrk_TgtState) ,XIC(Wrk_FdbkState.0) MOV(0,Wrk_TgtState) ] ]MOV(Wrk_TgtState,Wrk_PrevTgt);
				RC: "============================================================$N"
				    "SIMULATION AND FAIL TIMERS$N"
				    "============================================================$N"
				    "These rungs have the timers that are based on the determined output state.$N"
				    "$N"
				    "This rung has the OFF state timers.$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: NEQ(Wrk_ActState,Wrk_TgtState)XIO(Wrk_StartHorn)[TON(Wrk_FailT,?,?) ,TON(Wrk_SimT,?,?) ];
				RC: "============================================================$N"
				    "DEVICE FAIL TO REACH COMMANDED STATE DETECTION$N"
				    "============================================================$N"
				    "Run a Failure timer if the device is not in the commanded state.$N"
				    "If the timer times out, show the device as Failed to Reach Target State and raise an Alarm.";
				N: XIC(Wrk_FailT.DN)XIO(Sts_Maint)OTE(Sts_Fail);
				RC: "============================================================$N"
				    "SHED ON FAULT LOGIC$N"
				    "============================================================$N"
				    "This rung handles latching in of conditions which are configured to cause$N"
				    "device to shed (to State 0 or to de-energized -- see Cfg_St0onShed).";
				N: XIC(Sts_Fail)XIC(Cfg_ShedOnFail)OTL(Nrdy_Fail);
				RC: "If a shed condition is latched in above, set the device to State 0.$N"
				    "#####  V4.10.00  2019-03-08:  Modified logic to correct confgigurable shed action.  #####";
				N: [XIC(Nrdy_Fail) ,XIC(Nrdy_EqpFault) ,XIC(Nrdy_IOFault) ,XIC(Nrdy_Intlk) ,XIC(Nrdy_CfgErr) ,XIC(Nrdy_OoS) ]XIC(Cfg_St0onShed)CLR(Wrk_TgtState);
				RC: "Sound the horn when energising$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIC(Wrk_StartHorn) TON(Wrk_StartHornT,?,?) TON(Wrk_StartHornT,?,?) ,XIC(Wrk_StartHornT.DN) OTU(Wrk_StartHorn) ];
				RC: "============================================================$N"
				    "DEVICE COMMAND ENUMERATED VALUE$N"
				    "============================================================$N"
				    "Val_Cmd is the command currently being processed:$N"
				    "0 = None$N"
				    "1 = State 0$N"
				    "2 = State 1$N"
				    "3 = State 2$N"
				    "4 = State 3";
				N: [EQU(Wrk_ActState,Wrk_TgtState) CLR(Val_Cmd) ,NEQ(Wrk_ActState,Wrk_TgtState) [EQU(Wrk_TgtState,0) [[XIC(Nrdy_Fail) ,XIC(Nrdy_EqpFault) ,XIC(Nrdy_IOFault) ] XIC(Cfg_St0onShed) ,XIO(Wrk_StartHorn) ] MOV(1,Val_Cmd) ,EQU(Wrk_TgtState,1) XIO(Wrk_StartHorn) MOV(2,Val_Cmd) ,EQU(Wrk_TgtState,2) XIO(Wrk_StartHorn) MOV(3,Val_Cmd) ,EQU(Wrk_TgtState,3) XIO(Wrk_StartHorn) MOV(4,Val_Cmd) ] ];
				RC: "============================================================$N"
				    "OUTPUT GENERATION$N"
				    "============================================================$N"
				    "These rungs set, clear, or don$'t touch the outputs for the current commanded state.$N"
				    "$N"
				    "Outputs for State 0$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: XIO(Inp_Sim)EQU(Wrk_TgtState,0)[XIC(Wrk_NewCmd) ,NEQ(Wrk_TgtState,Wrk_PrevTgt) ]XIO(Wrk_StartHorn)MVM(Cfg_OutSt0State,Cfg_OutSt0Write,Wrk_Out);
				RC: "Outputs for State 1$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: XIO(Inp_Sim)EQU(Wrk_TgtState,1)[XIC(Wrk_NewCmd) ,NEQ(Wrk_TgtState,Wrk_PrevTgt) ]XIO(Wrk_StartHorn)MVM(Cfg_OutSt1State,Cfg_OutSt1Write,Wrk_Out);
				RC: "Outputs for State 2$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: XIO(Inp_Sim)EQU(Wrk_TgtState,2)[XIC(Wrk_NewCmd) ,NEQ(Wrk_TgtState,Wrk_PrevTgt) ]XIO(Wrk_StartHorn)MVM(Cfg_OutSt2State,Cfg_OutSt2Write,Wrk_Out);
				RC: "Outputs for State 3$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: XIO(Inp_Sim)EQU(Wrk_TgtState,3)[XIC(Wrk_NewCmd) ,NEQ(Wrk_TgtState,Wrk_PrevTgt) ]XIO(Wrk_StartHorn)MVM(Cfg_OutSt3State,Cfg_OutSt3Write,Wrk_Out);
				RC: "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: XIO(Wrk_StartHorn)OTU(Wrk_NewCmd)MOV(Wrk_TgtState,Wrk_PrevTgt);
				RC: "For each Output that has a non-zero Pulse Time configuration,$N"
				    "turn off the output after it$'s been on for the Pulse Time.";
				N: [XIC(Wrk_Out.0) NEQ(Wrk_OutAPulseT.PRE,0) TON(Wrk_OutAPulseT,?,?) ,XIC(Wrk_OutAPulseT.DN) OTU(Wrk_Out.0) ,XIC(Wrk_Out.1) NEQ(Wrk_OutBPulseT.PRE,0) TON(Wrk_OutBPulseT,?,?) ,XIC(Wrk_OutBPulseT.DN) OTU(Wrk_Out.1) ,XIC(Wrk_Out.2) NEQ(Wrk_OutCPulseT.PRE,0) TON(Wrk_OutCPulseT,?,?) ,XIC(Wrk_OutCPulseT.DN) OTU(Wrk_Out.2) ,XIC(Wrk_Out.3) NEQ(Wrk_OutDPulseT.PRE,0) TON(Wrk_OutDPulseT,?,?) ,XIC(Wrk_OutDPulseT.DN) OTU(Wrk_Out.3) ];
				RC: "If the device is in Simulation, or if a fault causes the device$N"
				    "to shed and Shed to State 0 is NOT configured, turn off the outputs.";
				N: XIC(Inp_Sim)CLR(Wrk_Out);
				RC: "This rung copies the output bits from the internal SINT (used for$N"
				    "doing byte-wise updates above) to the four individual BOOL (bit) Outputs.$N"
				    "$N"
				    "(NOTE:  These are copeid rather than aliased because the Wrk_Out bits are$N"
				    "only written as needed.  Buffering keeps writes to Out_A, etc., from$N"
				    "affecting the internal state of the instruction instance.)$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIC(Wrk_Out.0) OTE(Out_A) ,XIC(Wrk_Out.1) OTE(Out_B) ,XIC(Wrk_Out.2) OTE(Out_C) ,XIC(Wrk_Out.3) OTE(Out_D) ,XIC(Wrk_StartHorn) OTE(Out_Horn) ];
				RC: "============================================================$N"
				    "DEVICE STATUS GENERATION$N"
				    "============================================================$N"
				    "This rung generates the Device positon status bits.$N"
				    "#####  V4.10.00  2019-03-08:  Added Horn Status.  #####";
				N: [EQU(Wrk_ActState,-1) OTE(Sts_Moving) ,EQU(Wrk_ActState,0) OTE(Sts_St0) ,EQU(Wrk_ActState,1) OTE(Sts_St1) ,EQU(Wrk_ActState,2) OTE(Sts_St2) ,EQU(Wrk_ActState,3) OTE(Sts_St3) ,XIC(Wrk_StartHorn) OTE(Sts_Horn) ];
				RC: "============================================================$N"
				    "OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "If the device is in Operator or Maintenance, and if it is NOT $Qnot ready$Q,$N"
				    "then it is ready to go to any state it$'s not already going to, IF the$N"
				    "Permissives for that state are OK (accounting for bypassing).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####";
				N: XIO(Wrk_NotRdy)XIO(Nrdy_Perm)[XIO(Sts_NotRdy) ,XIC(Cfg_OCmdResets) ][[XIC(Sts_Oper) ,XIC(Sts_Maint) ,XIC(Cfg_OperSt0Prio) ] XIO(Sts_St0) XIC(Wrk_PermOK0) OTE(ORdy_St0) ,[XIC(Sts_Oper) ,XIC(Sts_Maint) ] [XIO(Sts_St1) XIC(Wrk_PermOK1) OTE(ORdy_St1) ,GEQ(Cfg_NumStates,3) XIO(Sts_St2) XIC(Wrk_PermOK2) OTE(ORdy_St2) ,GEQ(Cfg_NumStates,4) XIO(Sts_St3) XIC(Wrk_PermOK3) OTE(ORdy_St3) ] ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1), EXCEPT:$N"
				    "* If every implemented state DOES NOT CHECK ANY FEEDBACKS, the Fail$N"
				    "alarm will never occur and should not exist.  (If any state checks feedbacks,$N"
				    "the Fail alarm must be allowed to exist.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [OTL(DeviceFault.PCfg_AllowExist) OTL(IntlkTrip.PCfg_AllowExist) OTL(IOFault.PCfg_AllowExist) ,[NEQ(Cfg_FdbkSt0Check,0) ,NEQ(Cfg_FdbkSt0Check,0) ,GEQ(Cfg_NumStates,3) NEQ(Cfg_FdbkSt2Check,0) ,EQU(Cfg_NumStates,4) NEQ(Cfg_FdbkSt3Check,0) ] OTE(Fail.PCfg_AllowExist) ];
				RC: "Let the Alarm instance know if this object is taken Out of Service$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Now using P_CmdSrc, including Out of Service.  #####";
				N: XIC(CmdSrc.Sts_OoS)OTE(Fail.Inp_OoS)OTE(DeviceFault.Inp_OoS)OTE(IntlkTrip.Inp_OoS)OTE(IOFault.Inp_OoS);
				RC: "Handle Device Failed to Reach Position Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(Fail);
				RC: "Handle Device-Reported Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(DeviceFault);
				RC: "Handle Interlock Trip Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IntlkTrip);
				RC: "Handle I/O Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).";
				N: [XIC(Fail.Sts_AlmInh) ,XIC(DeviceFault.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N"
				    "(in the Configuration handling section).";
				N: [XIC(Nrdy_CfgErr) ,[XIC(Fail.Sts_Err) ,XIC(DeviceFault.Sts_Err) ,XIC(IntlkTrip.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = Powerup / Unknown$N"
				    "1=Confirmed in State 0$N"
				    "2 = Confirmed in State 1$N"
				    "3 = Confirmed in State 2$N"
				    "4 = Confirmed in State 3$N"
				    "5 = Moving to new target State$N"
				    "10 = Horn$N"
				    "$N"
				    "And this rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "16 = Failed to reach commanded position$N"
				    "17 = Device Fail (from input)$N"
				    "32 = I/O Fault$N"
				    "34 = Config Error$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added Horn Status.  #####";
				N: [CLR(Wrk_Sts) CLR(Wrk_Fault) ,XIC(Sts_St0) MOV(1,Wrk_Sts) ,XIC(Sts_St1) MOV(2,Wrk_Sts) ,XIC(Sts_St2) MOV(3,Wrk_Sts) ,XIC(Sts_St3) MOV(4,Wrk_Sts) ,XIC(Sts_Moving) MOV(9,Wrk_Sts) ,XIC(Sts_Horn) MOV(10,Wrk_Sts) ,XIC(Nrdy_Fail) MOV(16,Wrk_Fault) ,XIC(Nrdy_EqpFault) MOV(17,Wrk_Fault) ,[XIC(Sts_IOFault) ,XIC(Nrdy_IOFault) ] MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration.";
				N: [CLR(Wrk_SrcQ) ,EQU(Cfg_FdbkSt0Check,0) EQU(Cfg_FdbkSt1Check,0) [EQU(Cfg_FdbkSt1Check,0) ,LES(Cfg_NumStates,3) ] [EQU(Cfg_FdbkSt2Check,0) ,LES(Cfg_NumStates,4) ] MOV(2,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(SrcQ_IO,SrcQ);
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count.  #####";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) ,GRT(Fail.Val_Notify,Wrk_Notify) MOV(Fail.Val_Notify,Wrk_Notify) ,GRT(DeviceFault.Val_Notify,Wrk_Notify) MOV(DeviceFault.Val_Notify,Wrk_Notify) ,GRT(IntlkTrip.Val_Notify,Wrk_Notify) MOV(IntlkTrip.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(Fail.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(DeviceFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IntlkTrip.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTE(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_Notify,Val_NotifyAll) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_AckReqd and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(Fail.Sts_RdyAck) ,XIC(DeviceFault.Sts_RdyAck) ,XIC(IntlkTrip.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(Fail.Sts_RdyReset) ,XIC(DeviceFault.Sts_RdyReset) ,XIC(IntlkTrip.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ,XIC(Nrdy_PrioSt0) ,XIC(Nrdy_Fail) ,XIC(Nrdy_EqpFault) XIO(Sts_DeviceFault) ,XIC(Nrdy_IOFault) XIO(Sts_IOFault) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownership, clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, set the Ownership to NO OWNER (0).";
				N: CLR(PSet_Owner)CLR(Val_Owner);
				RC: "$QLurking$Q Commands not handled elsewhere are cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [OTU(OCmd_St0) OTU(OCmd_St1) OTU(OCmd_St2) OTU(OCmd_St3) ,OTU(XCmd_St0) OTU(XCmd_St1) OTU(XCmd_St2) OTU(XCmd_St3) ,OTU(PCmd_St0) OTU(PCmd_St1) OTU(PCmd_St2) OTU(PCmd_St3) ,CLR(Inp_OvrdCmd) ,OTU(Wrk_NewCmd) OTU(MCmd_Bypass) OTU(MCmd_Check) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_St0) OTU(ORdy_St1) OTU(ORdy_St2) OTU(ORdy_St3) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) ];
				RC: "Clear the latched Shed faults.";
				N: OTU(Nrdy_PrioSt0)OTU(Nrdy_Fail)OTU(Nrdy_EqpFault)OTU(Nrdy_IOFault);
				RC: "Outputs are cleared on Prescan.$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: CLR(Wrk_Out)OTU(Out_A)OTU(Out_B)OTU(Out_C)OTU(Out_D)OTU(Out_Horn)OTU(Wrk_StartHorn);
				RC: "Show the enumerated device command as NONE.$N"
				    "Show the enumerated device status as POWERUP / UNKNOWN.";
				N: CLR(Val_Cmd)CLR(Val_Sts);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_DIn (Description := "Discrete Input",
	                                     Revision := "4.10",
	                                     RevisionExtension := ".00 Release",
	                                     RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                     Vendor := "Rockwell Automation",
	                                     ExecutePrescan := Yes,
	                                     ExecutePostscan := No,
	                                     ExecuteEnableInFalse := Yes,
	                                     CreatedDate := "2004-09-26T01:40:40.210Z",
	                                     CreatedBy := "Not Available",
	                                     EditedDate := "2019-03-08T17:11:20.775Z",
	                                     EditedBy := "PROCESS\Library",
	                                     SoftwareRevision := "v18.02",
	                                     AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis instruction monitors a discrete (1 / 0) input and checks for alarm conditions.$N$NThe Inp_Gate input must be set (=1, its default value) and the alarm enabled for$Nthe Target Disagree alarm to occur.  This alarm will not occur until the Inp_Gate$Ninput has been set for the Gate Delay (Cfg_GateDly) time.  The Gate is used to$Nenable the alarm when some other condition is true; for example, a high vibration$Nswitch should only generate a Target Disagree alarm when the associated motor$Nhas been running long enough to stabilize.$N$NThe Target Disagree alarm is generated when the Inp_PV (process variable)$Ninput is different from the Inp_Target (target) input.  The Target indicates the$N$Qnormal$Q condition.  For example, a flow switch should indicate flow when a$Npump is running and should not indicate flow when a pump is stopped.  The$Npump run status is used as the Target input, and when the switch does not$Nmatch the target (within the allotted time), the Target Disagree Alarm (e.g.,$NFlow Switch Failure) is generated.$N$NNOTE: the Inp_PV is inverted when the rung condition is false -- this allows the$Ninput to be a condition on the rung with P_DIn rather than mapped into Inp_PV.$NSee P_DIn reference manual for details.$N$NThis instruction includes a substitute PV capability for a manually-entered state.$NThis may be useful when a sensor is out for repair or for simulation and testing.$N$NAlarms are provided by P_Alarm AOI instances.$NTarget Disagree Status gating provided by a P_Gate AOI instance.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-01)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for Channel object.$N* Added I/O Fault alarm.$N* Deleted Cfg_PCmdClear.  All Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N* Changed delay time configuration items to REAL seconds.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_PV : BOOL (Description := "Input Signal (process variable) from Sensor",
			                  Usage := Input,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  DefaultData := 1);
			Inp_IOFault : BOOL (Description := "Input Comm Status or Quality 1=Bad, 0=OK",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Inp_PVNotify : DINT (Description := "Related PV object alarm prio and ack status (enum)",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Inp_Target : BOOL (Description := "Target State of Input (Disagree Status if not in Target State)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 1);
			Inp_Gate OF TgtDisagreeGate.Inp_Gate (Description := "Gate Condition (=1 to enable Disagree Status)",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes);
			Inp_Sim : BOOL (Description := "1=Use simulated PV (Set_SimPV); 0=Use Input (Inp_PV)",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Reset : BOOL (Description := "1=Reset Alarm requiring reset",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_NoSubstPV : BOOL (Description := "1=Disallow selection of Substitute PV",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_NormTextVis : BOOL (Description := "1=Display state text in $Qnormal$Q state (= target), 0=hide (some HMI objects)",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 1);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasTgtDisagreeAlm OF TgtDisagree.Cfg_Exists (Description := "1=Target Disagree Alarm exists and will be checked",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_TgtDisagreeResetReqd OF TgtDisagree.Cfg_ResetReqd (Description := "1=Target Disagree Alarm is latched in, requires Reset Command to clear",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			Cfg_TgtDisagreeAckReqd OF TgtDisagree.Cfg_AckReqd (Description := "1=Target Disagree Alarm must be acknowledged",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=Target Disagree Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Target Disagree Alarm is latched in, requires Reset Command to clear",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Target Disagree Alarm must be acknowledged",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_TgtDisagreeSeverity OF TgtDisagree.Cfg_Severity (Description := "Target Disagree Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "Target Disagree Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_Debounce : REAL (Description := "Minimum time Input Sts must maintain state (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Cfg_GateDly OF TgtDisagreeGate.Cfg_GateDly (Description := "Time Inp_Gate must be true before Disagree Status is checked (sec)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No);
			Cfg_TgtDisagreeOnDly OF TgtDisagreeGate.Cfg_OnDly (Description := "Minimum time for Input to disagree with Target to raise Status (sec)",
			                                Usage := Input,
			                                RADIX := Float,
			                                Required := No,
			                                Visible := No);
			Cfg_TgtDisagreeOffDly OF TgtDisagreeGate.Cfg_OffDly (Description := "Minimum time for Input to agree with Target to clear Status (sec)",
			                                 Usage := Input,
			                                 RADIX := Float,
			                                 Required := No,
			                                 Visible := No);
			Set_SimPV : BOOL (Description := "PV used in Simulation (Inp_Sim=1)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			PCmd_Reset : BOOL (Description := "Program Command to Reset all latched Alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_TgtDisagreeAck OF TgtDisagree.PCmd_Ack (Description := "Program Command to Acknowledge the Target Disagree Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_TgtDisagreeSuppress OF TgtDisagree.PCmd_Suppress (Description := "Program Command to Suppress the Target Disagree Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_TgtDisagreeUnsuppress OF TgtDisagree.PCmd_Unsuppress (Description := "Program Command to Unsuppress the Target Disagree Alarm",
			                                      Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No);
			PCmd_TgtDisagreeUnshelve OF TgtDisagree.PCmd_Unshelve (Description := "Program Command to Unshelve the Target Disagree Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge the I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress the I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress the I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve the I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Sts : DINT (Description := "Device Confirmed Sts 0=PV Good, 6=PV Bad, 7=Substitute PV",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=none, 16=Tgt Disagree, 32=I/O comms., 34=CfgErr",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts : BOOL (Description := "Discrete Input Status (incl. Debounce, Manual Override, if used)",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0);
			Sts_PV : BOOL (Description := "Discrete Input Status (actual, not subject to Override)",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Sts_SubstPV : BOOL (Description := "1=Using Substitute PV (Input being overridden)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_InpPV : BOOL (Description := "1=Using Input PV (normal)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_PVBad : BOOL (Description := "Input Comm Status/ Quality (0=OK, 1=Bad)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=Device has a Maintenance Bypass function active",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=One or more Alarms Shelved, Disabled or Suppressed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Invalid Timer Preset (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_TgtDisagreeCmp OF TgtDisagreeGate.Inp (Description := "Input vs. Target comparicon result 1=Disagree",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_TgtDisagreeGate OF TgtDisagreeGate.Sts_Gate (Description := "Target Disagree Gate Delay Status, 1=done",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read Only);
			Sts_TgtDisagree OF TgtDisagree.Inp (Description := "1=Input is not in Target state",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Alm_TgtDisagree OF TgtDisagree.Alm (Description := "1=Alarm: Input is not in Target state",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Ack_TgtDisagree OF TgtDisagree.Ack (Description := "1=Target Disagree Alarm has been acknowledged",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_TgtDisagreeDisabled OF TgtDisagree.Disabled (Description := "1=Target Disagree Alarm has been Disabled by Maintenance",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_TgtDisagreeShelved OF TgtDisagree.Shelved (Description := "1=Target Disagree Alarm has been Shelved by Operator",
			                                  Usage := Output,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No,
			                                  ExternalAccess := Read/Write);
			Sts_TgtDisagreeSuppressed OF TgtDisagree.Suppressed (Description := "1=Target Disagree Alarm has been Suppressed by Program",
			                                     Usage := Output,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No,
			                                     ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "1=Input communication fault (Inp_IOFault = 1)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=Alarm: Input communication fault",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			P_DIn : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[5,'P_DIn$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[14,'Discrete Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[14,'Discrete Input$00$00$00$00$00$00']");
			Wrk_Status : BOOL (Description := "Internal Status (after Manual Override selection)",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			TgtDisagree : P_Alarm (Description := "Target Disagree Alarm",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[961,750,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Target Disagree$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Wrk_FallT : TIMER (Description := "Timer to ensure Status LOW time on falling edge",
			                    ExternalAccess := None,
			                    DefaultData := "[0,0,0]");
			Wrk_RiseT : TIMER (Description := "Timer to ensure Status HIGH time on rising edge",
			                    ExternalAccess := None,
			                    DefaultData := "[0,0,0]");
			Wrk_SubstPV : BOOL (Description := "Internal flag: Using Substitute PV",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Cfg_1StText : STRING_8 (Description := "Text to display in PV=1 State",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[2,'On$00$00$00$00$00$00']");
			Cfg_0StText : STRING_8 (Description := "Text to display in PV=0 State",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[3,'Off$00$00$00$00$00']");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_Sts : DINT (Description := "Buffer for building Val_Sts",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			HMI_Type : STRING_16 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[5,'P_DIn$00$00$00$00$00$00$00$00$00$00$00']");
			TgtDisagreeGate : P_Gate (Description := "Target Disagree Condition Gate/Delay",
			                          ExternalAccess := Read/Write,
			                          DefaultData := "[9,0.00000000e+000,0.00000000e+000,0.00000000e+000,[0,0,0],[0,0,0],[0,0,0],[15,'Target Disagree$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0]");
			Val_Notify : DINT (Description := "Highest Alarm prio and ack status this object only (enum)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,480,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Alarm Condition$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			OCmd_ResetAckAll : BOOL (Description := "Operator Command to Reset and Acknowledge all Alarms",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Operator Command to Reset all latched Alarms",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_InpPV : BOOL (Description := "Maintenance Command to use Input PV (normal)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_SubstPV : BOOL (Description := "Maintenance Command to use Substitute PV (override input)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read/Write,
			                       DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_InpPV : BOOL (Description := "1=Ready for MCmd_InpPV (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_SubstPV : BOOL (Description := "1=Ready for MCmd_SubstPV (enables HMI button)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			MSet_SubstPV : BOOL (Description := "Maintenance-Entered Substitute PV",
			                       RADIX := Decimal,
			                       ExternalAccess := Read/Write,
			                       DefaultData := 0);
			Wrk_ErrDebounce : BOOL (Description := "Error in Debounce Timer configuration",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Same as main Logic routine, except Inp is inverted (for use in LD logic)")
				RC: "============================================================$N"
				    "ENABLE_IN_FALSE ROUTINE$N"
				    "============================================================$N"
				    "This logic is identical to the main LOGIC Routine, except that the$N"
				    "Inp_PV signal is inverted (Rung 6).  This is to support Ladder Diagram$N"
				    "instances of the form:    XIC (discrete input)   P_DIn (P_DIn Tag)$N"
				    "============================================================$N"
				    "POWERUP / INVALID STATE HANDLING$N"
				    "============================================================$N"
				    "All internal Work (state) bits maintain states through a power cycle and are$N"
				    "independent.  No Powerup / Invalid State Handling logic is required.$N"
				    "============================================================$N"
				    "COMMAND PROCESSING$N"
				    "============================================================$N"
				    "These rungs handle received Commands:$N"
				    "$N"
				    "NOTE:  Operator Commands for P_Alarm are sent directly to the contained AOI.$N"
				    "$N"
				    "MCmd_SubstPV: Maintenance Command to select Maintenance-entered substitute PV$N"
				    "$N"
				    "Do not allow this Command if Cfg_NoSubstPV is set.";
				N: XIC(MCmd_SubstPV)OTU(MCmd_SubstPV)XIO(Cfg_NoSubstPV)OTL(Wrk_SubstPV);
				RC: "MCmd_InpPV: Maintenance Command to cancel Substitute PV and return to Live Input PV.";
				N: [XIC(MCmd_InpPV) OTU(MCmd_InpPV) ,XIC(Cfg_NoSubstPV) ]OTU(Wrk_SubstPV);
				RC: "Show the Substitute / Input PV Status, and if Substitute PV$N"
				    "is selected, show the Maintenance Bypass breadcrumb.";
				N: [XIC(Wrk_SubstPV) OTE(Sts_SubstPV) ,XIO(Wrk_SubstPV) OTE(Sts_InpPV) ,XIC(Sts_SubstPV) OTE(Sts_MaintByp) ];
				RC: "Commands for Substitue PV and Input PV are available$N"
				    "based on the current state of the internal toggle bit.";
				N: XIO(Cfg_NoSubstPV)[XIO(Wrk_SubstPV) OTE(MRdy_SubstPV) ,XIC(Wrk_SubstPV) OTE(MRdy_InpPV) ];
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "$N"
				    "These rungs get Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration data are used directly in-place.$N"
				    "$N"
				    "Enter the time (in seconds) the Status must remain in each state (debounce time).$N"
				    "This time is used in a rising-edge debounce timer and a falling-edge debounce timer.$N"
				    "$N"
				    "Enter the time (in seconds) the alarm Gate must be true before alarm detection is activated.$N"
				    "$N"
				    "Enter the On-Delay and Off-Delay times (in seconds) for the Target Disagree Status$N"
				    "(which feeds the Target Disagree Alarm).$N"
				    "$N"
				    "If the timer preset calcuated wraps negative (more than 2.14... million seconds), then establish$N"
				    "a valid limit value for the Preset.  Note that a negative timer preset will fault the controller!!!$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed delay time configuration items to REAL seconds.  #####";
				N: [MUL(Cfg_Debounce,1000.0,Wrk_RiseT.PRE) XIC(Wrk_RiseT.PRE.31) CLR(Wrk_RiseT.PRE) OTE(Wrk_ErrDebounce) ,MOV(Wrk_RiseT.PRE,Wrk_FallT.PRE) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(TgtDisagree.PCmd_Ack) ,OTL(IOFault.PCmd_Ack) ] ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ][OTL(TgtDisagree.PCmd_Reset) ,OTL(IOFault.PCmd_Reset) ];
				RC: "============================================================$N"
				    "DISCRETE INPUT PROCESSING$N"
				    "============================================================$N"
				    "$N"
				    "Sts_PVBad:  If the I/O communication / data quality is OK,$N"
				    "or in Simulation or substituted, show NO Bad PV Status.$N"
				    "$N"
				    "If the I/O communication is faulted or data quality is BAD and we$'re NOT$N"
				    "in Simulation or using substitute PV, show the Bad PV Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: XIC(Inp_IOFault)XIO(Inp_Sim)OTE(Sts_IOFault)OTE(Sts_PVBad);
				RC: "The Process Variable Status (Sts_PV) bit shows the state of the selected input,$N"
				    "regardless of the settings of Mode.$N"
				    "$N"
				    "@@@@@  NOTE:  Inp_PV is INVERTED when this instruction is scanned false!!!  @@@@@";
				N: [XIO(Inp_Sim) XIO(Inp_PV) ,XIC(Inp_Sim) XIC(Set_SimPV) ]OTE(Sts_PV);
				RC: "The Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.$N"
				    "$N"
				    "NOTE:  Tracking must be done with latch/unlatch instructions to keep the $N"
				    "Set_SimPV setting retentive through a power cycle.$N"
				    "In order to avoid overwriting asynchronous inputs, the Set_SimPV bit is only written$N"
				    "when Simulation is NOT selected (live PV is used).";
				N: XIO(Inp_Sim)[XIC(Sts_PV) OTL(Set_SimPV) ,XIO(Sts_PV) OTU(Set_SimPV) ];
				RC: "The Status (Sts) bit shows the state of the selected input (after debounce, below).$N"
				    "This rung selects which PV is used: the input/simulation PV or the substitute PV.$N"
				    "In normal operation, it$'s the state of the Input (Sts_PV).$N"
				    "In Substitute PV, it$'s the state of the entered Substitute PV (Oper or Prog).";
				N: [XIO(Wrk_SubstPV) XIC(Sts_PV) ,XIC(Wrk_SubstPV) XIC(MSet_SubstPV) ]OTE(Wrk_Status);
				RC: "These two rungs debounce the selected PV, ensuring the Status stays in$N"
				    "each state a minimum time, while not delaying the Status on transition after an$N"
				    "extended period of time in the prior state.$N"
				    "$N"
				    "@@@@@  NOTE: Doubled TON/TOF is used to ensure that  @@@@@$N"
				    "@@@@@  .DN bit transitions on same scan if Preset = 0 !  @@@@@";
				N: [XIC(Wrk_Status) XIO(Wrk_FallT.TT) ,XIC(Wrk_RiseT.TT) ]TON(Wrk_RiseT,?,?)TON(Wrk_RiseT,?,?);
				RC: "@@@@@  NOTE: Doubled TON/TOF is used to ensure that  @@@@@$N"
				    "@@@@@  .DN bit transitions on same scan if Preset = 0 !  @@@@@";
				N: [XIO(Wrk_Status) XIO(Wrk_RiseT.TT) ,XIC(Wrk_FallT.TT) ]TON(Wrk_FallT,?,?)TON(Wrk_FallT,?,?);
				RC: "The Rising Edge triggered timer ENABLE bit (sealed in using the Timing bit)$N"
				    "is our debounced input.  Pass it along as the Status.";
				N: XIC(Wrk_RiseT.EN)OTE(Sts);
				RC: "Finally, if we are NOT using the Substitute PV, have it track the$N"
				    "debounced Status for bumpless transfer to Substitute.";
				N: XIO(Wrk_SubstPV)[XIO(Sts) OTU(MSet_SubstPV) ,XIC(Sts) OTL(MSet_SubstPV) ];
				RC: "============================================================$N"
				    "TARGET DISAGREE STATUS GENERATION$N"
				    "============================================================$N"
				    "If the Input is not in the target state, generate a Target$N"
				    "Disagree comparison status.  This status is then gated$N"
				    "(with a gate delay) and has an on-delay and off-delay$N"
				    "before feeding the final Target Disagree status bit.";
				N: [[XIO(Sts) XIC(Inp_Target) ,XIC(Sts) XIO(Inp_Target) ] OTE(Sts_TgtDisagreeCmp) ,P_Gate(TgtDisagreeGate) ,XIC(TgtDisagreeGate.Out) OTE(TgtDisagree.Inp) ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "Both alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: OTL(TgtDisagree.PCfg_AllowExist)OTL(IOFault.PCfg_AllowExist);
				RC: "Handle Alarm Processing using the standard P_Alarm AOI";
				N: P_Alarm(TgtDisagree);
				RC: "Handle Alarm Processing using the standard P_Alarm AOI$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [XIC(TgtDisagree.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Bad timer presets are determined in the Configuration logic above.$N"
				    "Bad Alarm configuration is determined by the P_Alarm instruction.$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [[XIC(Wrk_ErrDebounce) ,XIC(TgtDisagreeGate.Sts_Err) ] OTE(Err_Timer) ,[XIC(TgtDisagree.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "============================================================$N"
				    "ENUMERATED STATUS VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [MOV(1,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(10,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(SrcQ_IO,Wrk_SrcQ) ,XIC(Sts_SubstPV) MOV(18,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ) ];
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = Normal (PV Good)$N"
				    "6 = PV Bad$N"
				    "7 = Substitute PV$N"
				    "$N"
				    "And this rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "16 = Target Disagree$N"
				    "32 = I/O Comms Fault$N"
				    "34 = Config Error$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [CLR(Wrk_Sts) CLR(Wrk_Fault) ,XIC(Sts_PVBad) MOV(6,Wrk_Sts) ,XIC(Sts_SubstPV) MOV(7,Wrk_Sts) ,XIC(Sts_TgtDisagree) MOV(16,Wrk_Fault) ,XIC(Sts_IOFault) MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count.  #####$N"
				    "#####  Added I/O Fault alarm.  #####";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) OTU(Wrk_Notify.0) ,GRT(TgtDisagree.Val_Notify,Wrk_Notify) MOV(TgtDisagree.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(TgtDisagree.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTL(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_UnackAlmC,Val_UnackAlmC) MOV(Wrk_Notify,Val_NotifyAll) ];
				RC: "Roll up the notification from the input Channel object.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count including attached PV object.  #####";
				N: [GRT(Inp_PVNotify,Wrk_Notify) MVM(Inp_PVNotify,2#1111_1110,Wrk_Notify) ,XIC(Inp_PVNotify.0) OTL(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_NotifyAll) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added separate rung for Rdy_ bits, for new I/O Fault alarm.  #####$N"
				    "#####  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(TgtDisagree.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(TgtDisagree.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan - status is updated and alarms are generated")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_DIn:  PROCESS -- DISCRETE INPUT$N"
				    "============================================================$N"
				    "Revision 4.10.00 Release  2019-03-08:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, and V3.x Revision History archived.$N"
				    "V4.00.00  2018-06-25:  Added I/O Fault alarm.$N"
				    "Changed Inf_ items to HMI_, and added Cfg_Area for security.$N"
				    "Added notify and unack count rollup for Channel object.$N"
				    "Deleted Cfg_PCmdClear.  All Program Commands are now self-clearing.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyAck and Sts_ResetReqd for use by external objects.$N"
				    "Changed delay time configuration items to REAL seconds.$N"
				    "V4.10.00  2019-03-08:  Added Cfg_HasMoreObj.$N"
				    "============================================================$N"
				    "This Instruction monitors a Discrete Input from a flow switch, motor vibration$N"
				    "switch, or any other discrete signal, and provides:$N"
				    "$N"
				    "*  PV Status, with configurable names for the 0- and 1-states$N"
				    "* Input debounce for both the rising and falling transitions of the PV input$N"
				    "* An I/O Fault input.  An I/O Fault Alarm is raised when this input is true$N"
				    "*  A $QTarget$Q input -- the Target Disagree Alarm is raised when the PV input is not in$N"
				    "the same state as the Target for a configurable period of time$N"
				    "*  A Target Disagree $QGate$Q signal (with delay), used to enable the Alarm under$N"
				    "appropriate process conditions$N"
				    "* Commands to inhibit or enable alarms$N"
				    "* Setting of a simulated input signal for process simulation$N"
				    "* Selection of Substitute PV (by Maintenance personnel) or normal PV$N"
				    "$N"
				    "Alarms are provided by P_Alarm AOI instances.$N"
				    "Target Disagree Status gating is provided by a P_Gate AOI instance.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)CONCAT(Cfg_Desc,Cfg_Label,Cfg_Tag)CONCAT(Cfg_0StText,Cfg_1StText,Cfg_Area)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "COMMAND PROCESSING$N"
				    "============================================================$N"
				    "These rungs handle received Commands:$N"
				    "$N"
				    "NOTE:  Operator Commands for P_Alarm are sent directly to the contained AOI.$N"
				    "$N"
				    "MCmd_SubstPV: Maintenance Command to select Maintenance-entered substitute PV$N"
				    "$N"
				    "Do not allow this Command if Cfg_NoSubstPV is set.";
				N: LBL(SkipText)XIC(MCmd_SubstPV)OTU(MCmd_SubstPV)XIO(Cfg_NoSubstPV)OTL(Wrk_SubstPV);
				RC: "MCmd_InpPV: Maintenance Command to cancel Substitute PV and return to Live Input PV.";
				N: [XIC(MCmd_InpPV) OTU(MCmd_InpPV) ,XIC(Cfg_NoSubstPV) ]OTU(Wrk_SubstPV);
				RC: "Show the Substitute / Input PV Status, and if Substitute PV$N"
				    "is selected, show the Maintenance Bypass breadcrumb.";
				N: [XIC(Wrk_SubstPV) OTE(Sts_SubstPV) ,XIO(Wrk_SubstPV) OTE(Sts_InpPV) ,XIC(Sts_SubstPV) OTE(Sts_MaintByp) ];
				RC: "Commands for Substitue PV and Input PV are available$N"
				    "based on the current state of the internal toggle bit.";
				N: XIO(Cfg_NoSubstPV)[XIO(Wrk_SubstPV) OTE(MRdy_SubstPV) ,XIC(Wrk_SubstPV) OTE(MRdy_InpPV) ];
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "$N"
				    "These rungs get Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration data are used directly in-place.$N"
				    "$N"
				    "Enter the time (in seconds) the Status must remain in each state (debounce time).$N"
				    "This time is used in a rising-edge debounce timer and a falling-edge debounce timer.$N"
				    "$N"
				    "Enter the time (in seconds) the alarm Gate must be true before alarm detection is activated.$N"
				    "$N"
				    "Enter the On-Delay and Off-Delay times (in seconds) for the Target Disagree Status$N"
				    "(which feeds the Target Disagree Alarm).$N"
				    "$N"
				    "If the timer preset calcuated wraps negative (more than 2.14... million seconds), then establish$N"
				    "a valid limit value for the Preset.  Note that a negative timer preset will fault the controller!!!$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Changed delay time configuration items to REAL seconds.  #####";
				N: [MUL(Cfg_Debounce,1000.0,Wrk_RiseT.PRE) XIC(Wrk_RiseT.PRE.31) CLR(Wrk_RiseT.PRE) OTE(Wrk_ErrDebounce) ,MOV(Wrk_RiseT.PRE,Wrk_FallT.PRE) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(TgtDisagree.PCmd_Ack) ,OTL(IOFault.PCmd_Ack) ] ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ][OTL(TgtDisagree.PCmd_Reset) ,OTL(IOFault.PCmd_Reset) ];
				RC: "============================================================$N"
				    "DISCRETE INPUT PROCESSING$N"
				    "============================================================$N"
				    "$N"
				    "Sts_PVBad:  If the I/O communication / data quality is OK,$N"
				    "or in Simulation or substituted, show NO Bad PV Status.$N"
				    "$N"
				    "If the I/O communication is faulted or data quality is BAD and we$'re NOT$N"
				    "in Simulation or using substitute PV, show the Bad PV Status.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: XIC(Inp_IOFault)XIO(Inp_Sim)OTE(Sts_IOFault)OTE(Sts_PVBad);
				RC: "The Process Variable Status (Sts_PV) bit shows the state of the selected input,$N"
				    "regardless of the settings of Mode.";
				N: [XIO(Inp_Sim) XIC(Inp_PV) ,XIC(Inp_Sim) XIC(Set_SimPV) ]OTE(Sts_PV);
				RC: "The Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.$N"
				    "$N"
				    "NOTE:  Tracking must be done with latch/unlatch instructions to keep the $N"
				    "Set_SimPV setting retentive through a power cycle.$N"
				    "In order to avoid overwriting asynchronous inputs, the Set_SimPV bit is only written$N"
				    "when Simulation is NOT selected (live PV is used).";
				N: XIO(Inp_Sim)[XIC(Sts_PV) OTL(Set_SimPV) ,XIO(Sts_PV) OTU(Set_SimPV) ];
				RC: "The Status (Sts) bit shows the state of the selected input (after debounce, below).$N"
				    "This rung selects which PV is used: the input/simulation PV or the substitute PV.$N"
				    "In normal operation, it$'s the state of the Input (Sts_PV).$N"
				    "In Substitute PV, it$'s the state of the entered Substitute PV (Oper or Prog).";
				N: [XIO(Wrk_SubstPV) XIC(Sts_PV) ,XIC(Wrk_SubstPV) XIC(MSet_SubstPV) ]OTE(Wrk_Status);
				RC: "These two rungs debounce the selected PV, ensuring the Status stays in$N"
				    "each state a minimum time, while not delaying the Status on transition after an$N"
				    "extended period of time in the prior state.$N"
				    "$N"
				    "@@@@@  NOTE: Doubled TON/TOF is used to ensure that  @@@@@$N"
				    "@@@@@  .DN bit transitions on same scan if Preset = 0 !  @@@@@";
				N: [XIC(Wrk_Status) XIO(Wrk_FallT.TT) ,XIC(Wrk_RiseT.TT) ]TON(Wrk_RiseT,?,?)TON(Wrk_RiseT,?,?);
				RC: "@@@@@  NOTE: Doubled TON/TOF is used to ensure that  @@@@@$N"
				    "@@@@@  .DN bit transitions on same scan if Preset = 0 !  @@@@@";
				N: [XIO(Wrk_Status) XIO(Wrk_RiseT.TT) ,XIC(Wrk_FallT.TT) ]TON(Wrk_FallT,?,?)TON(Wrk_FallT,?,?);
				RC: "The Rising Edge triggered timer ENABLE bit (sealed in using the Timing bit)$N"
				    "is our debounced input.  Pass it along as the Status.";
				N: XIC(Wrk_RiseT.EN)OTE(Sts);
				RC: "Finally, if we are NOT using the Substitute PV, have it track the$N"
				    "debounced Status for bumpless transfer to Substitute.";
				N: XIO(Wrk_SubstPV)[XIO(Sts) OTU(MSet_SubstPV) ,XIC(Sts) OTL(MSet_SubstPV) ];
				RC: "============================================================$N"
				    "TARGET DISAGREE STATUS GENERATION$N"
				    "============================================================$N"
				    "If the Input is not in the target state, generate a Target$N"
				    "Disagree comparison status.  This status is then gated$N"
				    "(with a gate delay) and has an on-delay and off-delay$N"
				    "before feeding the final Target Disagree status bit.";
				N: [[XIO(Sts) XIC(Inp_Target) ,XIC(Sts) XIO(Inp_Target) ] OTE(Sts_TgtDisagreeCmp) ,P_Gate(TgtDisagreeGate) ,XIC(TgtDisagreeGate.Out) OTE(TgtDisagree.Inp) ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The alarm is ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####$N"
				    "#####  V4.00.00  2018-06-25:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: OTL(TgtDisagree.PCfg_AllowExist)OTL(IOFault.PCfg_AllowExist);
				RC: "Handle Alarm Processing using the standard P_Alarm AOI";
				N: P_Alarm(TgtDisagree);
				RC: "Handle Alarm Processing using the standard P_Alarm AOI$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [XIC(TgtDisagree.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Bad timer presets are determined in the Configuration logic above.$N"
				    "Bad Alarm configuration is determined by the P_Alarm instruction.$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [[XIC(Wrk_ErrDebounce) ,XIC(TgtDisagreeGate.Sts_Err) ] OTE(Err_Timer) ,[XIC(TgtDisagree.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "============================================================$N"
				    "ENUMERATED STATUS VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [MOV(1,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(10,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(SrcQ_IO,Wrk_SrcQ) ,XIC(Sts_SubstPV) MOV(18,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ) ];
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = Normal (PV Good)$N"
				    "6 = PV Bad$N"
				    "7 = Substitute PV$N"
				    "$N"
				    "And this rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "16 = Target Disagree$N"
				    "32 = I/O Comms Fault$N"
				    "34 = Config Error$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added I/O Fault alarm.  #####";
				N: [CLR(Wrk_Sts) CLR(Wrk_Fault) ,XIC(Sts_PVBad) MOV(6,Wrk_Sts) ,XIC(Sts_SubstPV) MOV(7,Wrk_Sts) ,XIC(Sts_TgtDisagree) MOV(16,Wrk_Fault) ,XIC(Sts_IOFault) MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count.  #####$N"
				    "#####  Added I/O Fault alarm.  #####";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) OTU(Wrk_Notify.0) ,GRT(TgtDisagree.Val_Notify,Wrk_Notify) MOV(TgtDisagree.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(TgtDisagree.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTL(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_UnackAlmC,Val_UnackAlmC) MOV(Wrk_Notify,Val_NotifyAll) ];
				RC: "Roll up the notification from the input Channel object.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count including attached PV object.  #####";
				N: [GRT(Inp_PVNotify,Wrk_Notify) MVM(Inp_PVNotify,2#1111_1110,Wrk_Notify) ,XIC(Inp_PVNotify.0) OTL(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_NotifyAll) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-06-25:  Added separate rung for Rdy_ bits, for new I/O Fault alarm.  #####$N"
				    "#####  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(TgtDisagree.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(TgtDisagree.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, clear any $Qlurking$Q Commands.";
				N: OTU(OCmd_Reset)OTU(OCmd_ResetAckAll)OTU(MCmd_InpPV)OTU(MCmd_SubstPV);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_DOut (Description := "Discrete Output",
	                                      Revision := "4.10",
	                                      RevisionExtension := ".01 Release",
	                                      RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                      Vendor := "Rockwell Automation",
	                                      ExecutePrescan := Yes,
	                                      ExecutePostscan := No,
	                                      ExecuteEnableInFalse := Yes,
	                                      CreatedDate := "2010-03-17T13:04:32.875Z",
	                                      CreatedBy := "Not Available",
	                                      EditedDate := "2019-10-16T20:43:23.177Z",
	                                      EditedBy := "PROCESS\Library",
	                                      SoftwareRevision := "v18.02",
	                                      AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction controls (and optionally monitors feedback for)$Na single Discrete Output and provides:$N$N*  Operator and Program Commands to:$N    -  turn the output ON$N    -  turn the output OFF$N    -  if the output is OFF, pulse it ON for a configured time$N    -  if the output is ON, pulse it OFF for a configured time, and$N    -  pulse the output continuously at the configured ON$N        and OFF times (e.g., for blinking a lamp)$N*  User-configurable ON delay and OFF delay before first output change$N*  User-configurable text labels for the ON and OFF states$N*  Optional monitoring of ON and OFF state confirmation feedbacks$N*  Detection of Failure to turn ON or OFF (when feedbacks are used)$N*  Monitoring of Permissive conditions to allow energizing output$N*  Monitoring of Interlock conditions to de-energize output$N*  Simulation, providing feedback of a working device while$N      disabling output (keeping de-energized)$N*  Monitoring of I/O communication faults$N*  Alarms for Fail to Turn ON, Fail to turn OFF (if feedbacks are$N      used), Interlock Trip, I/O Fault$N*  $QNotReady$Q status for display on Graphic Symbol and $QAvailable$Q$N     status for use by automation logic to know whether output can be$N     controlled by other objects.$N$NCommand Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$NCommand Sources: Operator, Program, External, Override, Maintenance, Out of$NService, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$N* Corrected operation of state machine with alert horn.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.02)$NSee 4.10 Release Notes for details.$N* Added audible alert on commanded energize/state change. $N* Added Horn Status, Horn Inhibit.$N* Changed availability to use input availability from interlocks.$N* Updated to P_CmdSrc V4.10.00.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.00 Release Notes for details.$N* Fixed feedback determination for simulation or no feedback.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-11)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for associated object(s).$N* Changed $QMode$Q to $QCommand Source$Q using P_CmdSrc 4.00.00.$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* Added option Cfg_HasPulse to enable or disable pulsing functions.$N* Aligned ready bit naming with command bit names.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N* Changed delay / time configuration items to REAL seconds.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_OnFdbk : BOOL (Description := "Input Signal: ON feedback from device",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 0);
			Inp_OffFdbk : BOOL (Description := "Input Signal: OFF feedback from device",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Inp_PermOK : BOOL (Description := "1=ON Permissives OK, device can turn ON",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 1);
			Inp_NBPermOK : BOOL (Description := "1=Non-Bypassable ON Permissives OK, device can turn ON",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := 1);
			Inp_IntlkOK : BOOL (Description := "1=Interlocks OK, device can turn ON and stay ON",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBIntlkOK : BOOL (Description := "1=Non-Bypassable Interlocks OK, device can turn ON and stay ON",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkAvail : BOOL (Description := "1 = Interlock Availibility OK",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Inp_IOFault : BOOL (Description := "Input Communication Status 0=OK, 1=fail",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=Simulate working device; 0=Turn ON/OFF actual device",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Hand OF CmdSrc.Inp_Hand (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_Ovrd OF CmdSrc.Inp_Ovrd (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_OvrdCmd : DINT (Description := "Ovrd Device Command 0=None, 1=Off, 2=On, 3=Pulse Off, 4=Pulse On, 5=Pulse Cont",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_ExtInh OF CmdSrc.Inp_ExtInh (Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_HornInh : BOOL (Description := "1 = Inhibit audible alert, 0 = Alllow audible alert",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Reset : BOOL (Description := "1=Reset Shed Latches and Cleared Alarms",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_HasPulse : BOOL (Description := "1=Enable pulsing functions, 0=On/Off only",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_CompletePulse : BOOL (Description := "1=Finish Pulse when commanded ON or OFF; 0=switch immediately",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_HasOnFdbk : BOOL (Description := "1=Device provides an ON feedback signal",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_HasOffFdbk : BOOL (Description := "1=Device provides an OFF feedback signal",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_UseOnFdbk : BOOL (Description := "1=Device ON feedback should be used for failure checking",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_UseOffFdbk : BOOL (Description := "1=Device OFF feedback should be used for failure checking",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_FdbkFail : BOOL (Description := "1=Both feedbacks ON is invalid; 0=Both feedbacks OFF is invalid",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_HasPermObj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_Perm",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasIntlkObj : BOOL (Description := "1=Tells HMI a P_Intlk is connected to Inp_Intlk",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HornOnChange : BOOL (Description := "0 = Horn on energize only, 1 = Horn on any state change",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_OperOffPrio : BOOL (Description := "1=OCmd_Off any time, 0=OCmd_Off only when Oper selected",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_ExtOffPrio : BOOL (Description := "1=XCmd_Off any time, 0=XCmd_Off only when Oper selected",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OCmdResets : BOOL (Description := "1=New device OCmd resets shed latches and cleared alarms, 0=OCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_XCmdResets : BOOL (Description := "1=New device XCmd resets shed latches and cleared alarms, 0=XCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OvrdPermIntlk : BOOL (Description := "1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_ShedOnFail : BOOL (Description := "1=Go to State 0 and Alarm on Fail to reach position; 0=Alarm only on Fail",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 1);
			Cfg_ShedOnIOFault : BOOL (Description := "1=Go to State 0 and Alarm on I/O Fault; 0=Alarm only on I/O Fault",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_HasOnFailAlm OF OnFail.Cfg_Exists (Description := "1=Fail to Turn ON Alarm exists and will be checked",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No);
			Cfg_HasOffFailAlm OF OffFail.Cfg_Exists (Description := "1=Fail to Turn OFF Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_HasIntlkTripAlm OF IntlkTrip.Cfg_Exists (Description := "1=Interlock Trip Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=I/O Fault Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_OnFailResetReqd OF OnFail.Cfg_ResetReqd (Description := "1=Reset required to clear Fail to Turn ON Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_OffFailResetReqd OF OffFail.Cfg_ResetReqd (Description := "1=Reset required to clear Fail to Turn OFF Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IntlkTripResetReqd OF IntlkTrip.Cfg_ResetReqd (Description := "1=Reset required to clear Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Reset required to clear I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_OnFailAckReqd OF OnFail.Cfg_AckReqd (Description := "1=Acknowledge required for Fail to Turn ON Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_OffFailAckReqd OF OffFail.Cfg_AckReqd (Description := "1=Acknowledge required for Fail to Turn OFF Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_IntlkTripAckReqd OF IntlkTrip.Cfg_AckReqd (Description := "1=Acknowledge required for Interlock Trip Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Acknowledge required for I/O Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_OnFailSeverity OF OnFail.Cfg_Severity (Description := "Fail To Turn OFF Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_OffFailSeverity OF OffFail.Cfg_Severity (Description := "Fail To Turn ON Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_IntlkTripSeverity OF IntlkTrip.Cfg_Severity (Description := "Interlock Trip Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "I/O Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_StartHornT : REAL (Description := "Time to sound audible on commanded start (sec) (0=disabled)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_SimFdbkT : REAL (Description := "Delay to echo back  of ON/OFF status when in Simulation (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 2.00000000e+000);
			Cfg_OnDelayT : REAL (Description := "Delay before initially turning output ON (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Cfg_OffDelayT : REAL (Description := "Delay before initially turning output OFF (sec)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			Cfg_OnPulseT : REAL (Description := "Output ON time for Pulse ON or Pulse Continuous",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 5.00000000e-001);
			Cfg_OffPulseT : REAL (Description := "Output OFF time for Pulse OFF or Pulse Continuous",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 5.00000000e-001);
			Cfg_OnFailT : REAL (Description := "Time after Output ON to get ON Feedback before Fault (sec)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+001);
			Cfg_OffFailT : REAL (Description := "Time after Output OFF to get OFF Feedback before Fault (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+001);
			PSet_Owner : DINT (Description := "Program Owner Request ID (non-zero) or Release (zero)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_On : BOOL (Description := "Program Command to turn device ON",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			PCmd_Off : BOOL (Description := "Program Command to turn device OFF",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			PCmd_OnPulse : BOOL (Description := "Program Command to pulse device (which is OFF) ON once",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			PCmd_OffPulse : BOOL (Description := "Program Command to pulse device (which is ON) OFF once",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			PCmd_ContPulse : BOOL (Description := "Program Command to pulse device continuously (blink)",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			PCmd_Prog OF CmdSrc.PCmd_Prog (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Oper OF CmdSrc.PCmd_Oper (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Lock OF CmdSrc.PCmd_Lock (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Unlock OF CmdSrc.PCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Normal OF CmdSrc.PCmd_Normal (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Reset : BOOL (Description := "Program Command to ResetShed Latches and Cleared Alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_OnFailAck OF OnFail.PCmd_Ack (Description := "Program Command to Acknowledge Fail to Turn ON Alarm",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No);
			PCmd_OnFailSuppress OF OnFail.PCmd_Suppress (Description := "Program Command to Suppress Fail to Turn ON Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_OnFailUnsuppress OF OnFail.PCmd_Unsuppress (Description := "Program Command to UnsuppressFail to Turn ON Alarm",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			PCmd_OnFailUnshelve OF OnFail.PCmd_Unshelve (Description := "Program Command to Unshelve Fail to Turn ON Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_OffFailAck OF OffFail.PCmd_Ack (Description := "Program Command to Acknowledge Fail to Turn OFF Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_OffFailSuppress OF OffFail.PCmd_Suppress (Description := "Program Command to Suppress Fail to Turn OFF Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_OffFailUnsuppress OF OffFail.PCmd_Unsuppress (Description := "Program Command to Unsuppress Fail to Turn OFF Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_OffFailUnshelve OF OffFail.PCmd_Unshelve (Description := "Program Command to Unshelve Failt to Turn OFF Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IntlkTripAck OF IntlkTrip.PCmd_Ack (Description := "Program Command to Acknowledge Interlock Trip Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_IntlkTripSuppress OF IntlkTrip.PCmd_Suppress (Description := "Program Command to Suppress Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IntlkTripUnsuppress OF IntlkTrip.PCmd_Unsuppress (Description := "Program Command to Unsuppress Interlock Trip Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripUnshelve OF IntlkTrip.PCmd_Unshelve (Description := "Program Command to Unshelve Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			MCmd_Rel OF CmdSrc.MCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			OCmd_Unlock OF CmdSrc.OCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			XCmd_On : BOOL (Description := "External Command to turn device ON",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			XCmd_Off : BOOL (Description := "External Command to turn device OFF",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			XCmd_OnPulse : BOOL (Description := "External Command to pulse device (which is OFF) ON once",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			XCmd_OffPulse : BOOL (Description := "External Command to pulse device (which is ON) OFF once",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			XCmd_ContPulse : BOOL (Description := "External Command to pulse device continuously (blink)",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			XCmd_Acq OF CmdSrc.XCmd_Acq (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Rel OF CmdSrc.XCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Reset : BOOL (Description := "Ext Cmd to clear shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Out : BOOL (Description := "Primary Output 1=ON, 0=OFF",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0);
			Out_Horn : BOOL (Description := "1=Sound audible prior to commanded energize/ state change",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Cmd : DINT (Description := "Device Command: 0=None, 1=Off, 2=On, 3=Pulse Off, 4=Pulse On, 5=Pulse Cont",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fdbk : DINT (Description := "Device Feedback: 0=Transition, 1=Off, 2=On, 3=Invalid",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Val_Sts : DINT (Description := "Device Status 0=off 1=on 2=pulse off 3=pulse on 4=pulse cont. 5=turning off 6=turning on",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=none, 16=Feedback Fault, 32=I/O Fault, 34=Config Error",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_State : DINT (Description := "Internal Logic State (for animating STD on faceplate), see manual",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + attached (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_Owner : DINT (Description := "Current Object Owner ID (0=not owned)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Out : BOOL (Description := "1=Output is ON (energized), 0=Output is OFF (de-energized)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Sts_Pulsing : BOOL (Description := "1=Output is in a pusling sequence",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_Horn : BOOL (Description := "1=Horn Active",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_FdbkOff : BOOL (Description := "1=Device Feedback shows device in OFF state",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_FdbkOn : BOOL (Description := "1=Device Feedback shows device in ON state",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_FdbkFail : BOOL (Description := "1=Feedbacks are in an INVALID state (not ON, OFF or TRANSIT)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_Available : BOOL (Description := "1=Device available for control by automation (Prog)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Bypass : BOOL (Description := "1=Bypassable Interlocks and Permissives are Bypassed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_BypActive : BOOL (Description := "1=Interlock / Permissive Bypassing Active (Bypassed or Maintenance)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_NotRdy : BOOL (Description := "1=Device Not Ready, see detail bits for reason",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_CfgErr : BOOL (Description := "1=Device Not Ready: Configuration Error",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Nrdy_Fail : BOOL (Description := "1=Device Not Ready: Device Failure (Shed Requires Reset)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Nrdy_Intlk : BOOL (Description := "1=Device Not Ready: Interlock Not OK",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_IOFault : BOOL (Description := "1=Device Not Ready: I/O Fault (Shed Requires Reset)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_OoS : BOOL (Description := "1=Device Not Ready: Device is Out of Service",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Nrdy_PrioOff : BOOL (Description := "1=Device Not Ready: Oper/Ext Priority Off Comand Requires Reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_Perm : BOOL (Description := "1=Device Not Ready: Permissive Not OK",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=Device has a Maintenance Bypass function active",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=One or more Alarms Shelved, Disabled or Suppressed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Feeback Check timer preset (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Sim : BOOL (Description := "1=Error in Config: Simulation timer preset (use 0 to 2147483)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Hand OF CmdSrc.Sts_Hand (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OoS OF CmdSrc.Sts_OoS (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Maint OF CmdSrc.Sts_Maint (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only);
			Sts_Ovrd OF CmdSrc.Sts_Ovrd (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_Ext OF CmdSrc.Sts_Ext (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Prog OF CmdSrc.Sts_Prog (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_ProgLocked OF CmdSrc.Sts_ProgLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Oper OF CmdSrc.Sts_Oper (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OperLocked OF CmdSrc.Sts_OperLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Normal OF CmdSrc.Sts_Normal (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_ExtReqInh OF CmdSrc.Sts_ExtReqInh (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_ProgReqInh OF CmdSrc.Sts_ProgReqInh (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_MAcqRcvd OF CmdSrc.Sts_MAcqRcvd (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_OnFail OF OnFail.Inp (Description := "1=Device Failed to Turn ON",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read/Write);
			Alm_OnFail OF OnFail.Alm (Description := "1=Device Fail to Turn ON Alarm",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read/Write);
			Ack_OnFail OF OnFail.Ack (Description := "1=Fail to Turn ON Alarm has been acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read/Write);
			Sts_OnFailDisabled OF OnFail.Disabled (Description := "1=Fail to Turn ON Alarm has been Disabled by Maintenance",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_OnFailShelved OF OnFail.Shelved (Description := "1=Fail to Turn ON Alarm has been Shelved by Operator",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Sts_OnFailSuppressed OF OnFail.Suppressed (Description := "1=Fail to Turn ON Alarm has been Suppressed by Program",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_OffFail OF OffFail.Inp (Description := "1=Device Failed to Turn OFF",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_OffFail OF OffFail.Alm (Description := "1=Device Fail to Turn OFF Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_OffFail OF OffFail.Ack (Description := "1=Fail to Turn OFF Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_OffFailDisabled OF OffFail.Disabled (Description := "1=Fail to Turn OFF Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_OffFailShelved OF OffFail.Shelved (Description := "1=Fail to Turn OFF Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_OffFailSuppressed OF OffFail.Suppressed (Description := "1=Fail to Turn OFF Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTrip OF IntlkTrip.Inp (Description := "1=Device turned OFF by an Interlock NOT OK (one-shot)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_IntlkTrip OF IntlkTrip.Alm (Description := "1=Alarm: Device turned OFF by an Interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_IntlkTrip OF IntlkTrip.Ack (Description := "1=Interlock Trip Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_IntlkTripDisabled OF IntlkTrip.Disabled (Description := "1=Interlock Trip Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTripShelved OF IntlkTrip.Shelved (Description := "1=Interlock Trip Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_IntlkTripSuppressed OF IntlkTrip.Suppressed (Description := "1=Interlock Trip Alarm has been Suppressed by Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "I/O Comm Fault Status (0=OK, 1=Bad)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=I/O Fault Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			MRdy_Rel OF CmdSrc.MRdy_Rel (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			ORdy_Unlock OF CmdSrc.ORdy_Unlock (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only);
			P_DOut : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_OffT : TIMER (Description := "Off Feedback Check Timer",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[0,0,0]");
			Wrk_OnT : TIMER (Description := "On Feedback Check Timer",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[0,0,0]");
			Wrk_SimOffT : TIMER (Description := "Simulation Delay until OFF",
			                      ExternalAccess := None,
			                      DefaultData := "[0,0,0]");
			Wrk_SimOnT : TIMER (Description := "Simulation Delay until ON",
			                     ExternalAccess := None,
			                     DefaultData := "[0,0,0]");
			Wrk_OnFdbk : BOOL (Description := "ON Feedback based on Command Source, simulation, etc. 1=confirmed ON",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Bypass : BOOL (Description := "Internal Bypassable Permissives and Interlocks are Bypassed flag",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			CmdSrc : P_CmdSrc (Description := "Control / Command Source Selection",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[7649,2048,0,0,0,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']]");
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			IntlkTrip : P_Alarm (Description := "Interlock Trip Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			OffFail : P_Alarm (Description := "Device Failed to Turn OFF Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Failed to Turn Off$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			OnFail : P_Alarm (Description := "Device Failed to Turn ON Alarm",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[17,'Failed to Turn On$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[6,'P_DOut$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[15,'Discrete Device$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[22,'Discrete On/Off Device$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_OffFdbk : BOOL (Description := "OFF Feedback based on Command Source, simulation, etc. 1=confirmed OFF",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_OnPulseT : TIMER (Description := "Output ON Pulse Timer",
			                       ExternalAccess := Read Only,
			                       DefaultData := "[0,0,0]");
			Wrk_OffPulseT : TIMER (Description := "Output OFF Pulse Timer",
			                        ExternalAccess := Read Only,
			                        DefaultData := "[0,0,0]");
			Wrk_OffDelayT : TIMER (Description := "Dealy before turning output OFF (Timer)",
			                        ExternalAccess := Read Only,
			                        DefaultData := "[0,0,0]");
			Wrk_OnDelayT : TIMER (Description := "Delay before turning output ON (Timer)",
			                       ExternalAccess := Read Only,
			                       DefaultData := "[0,0,0]");
			Wrk_PermOK : BOOL (Description := "1=Permissives are all OK to energize",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_Cmd : DINT (Description := "Device Command: 0= None, bit .0=Off, bit .1=On,$Nbit .2=Pulse Off,$Nbit .3=Pulse On,$Nbit .4=Pulse Cont.",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Cfg_1StText : STRING_8 (Description := "Text to display in PV=1 State",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[2,'On$00$00$00$00$00$00']");
			Cfg_0StText : STRING_8 (Description := "Text to display in PV=0 State",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[3,'Off$00$00$00$00$00']");
			HMI_Type : STRING_16 (Description := "Type identifier for HMI navigation",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[6,'P_DOut$00$00$00$00$00$00$00$00$00$00']");
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Wrk_NotRdy : BOOL (Description := "Device Not Ready conditions excluding shed latches",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_NoLongerSim : BOOL (Description := "Switched from Simulated to Real Device this scan",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Val_Notify : DINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			OCmd_ResetAckAll : BOOL (Description := "Operator Command to Reset all Alarms and latched Shed conditions",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Operator Command to Reset all Alarms requiring Reset",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			OCmd_ContPulse : BOOL (Description := "Operator Command to pulse device continuously (blink)",
			                         RADIX := Decimal,
			                         ExternalAccess := Read/Write,
			                         DefaultData := 0);
			OCmd_OffPulse : BOOL (Description := "Operator Command to pulse device (which is ON) OFF once",
			                        RADIX := Decimal,
			                        ExternalAccess := Read/Write,
			                        DefaultData := 0);
			OCmd_OnPulse : BOOL (Description := "Operator Command to pulse device (which is OFF) ON once",
			                       RADIX := Decimal,
			                       ExternalAccess := Read/Write,
			                       DefaultData := 0);
			OCmd_Off : BOOL (Description := "Operator Command to turn device OFF",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
			OCmd_On : BOOL (Description := "Operator Command to turn device ON",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			MCmd_Check : BOOL (Description := "Maintenance Command to Check (not bypass) all Interlocks and Permissives",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Bypass : BOOL (Description := "Maintenance Command to Bypass all Bypassable Interlocks and Permissives",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_ContPulse : BOOL (Description := "1=Ready for OCmd_ContPulse (enables HMI button)",
			                         RADIX := Decimal,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			ORdy_OffPulse : BOOL (Description := "1=Ready for OCmd_OffPulse (enables HMI button)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			ORdy_OnPulse : BOOL (Description := "1=Ready for OCmd_OnPulse (enables HMI button)",
			                       RADIX := Decimal,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			ORdy_Off : BOOL (Description := "1=Ready for OCmd_Off (enables HMI button)",
			                   RADIX := Decimal,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			ORdy_On : BOOL (Description := "1=Ready for OCmd_On (enables HMI button)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			MRdy_Check : BOOL (Description := "1=Ready for MCmd_Check (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Bypass : BOOL (Description := "1=Ready for MCmd_Bypass (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Wrk_State : DINT (Description := "Internal value of state machine current state",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_StartHornT : TIMER (Description := "Timer for audible alert or start",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_StartHorn : BOOL (Description := "1=Sound audible prior to commanded energize/ state change",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Out of Service; output is OFF; feedback Status shown if available; Alarms inhibited.")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "Handle $QProgrammed Out of Servie$Q Selection using the standard$N"
				    "P_CmdSrc AOI (EnableInFalse Routine, false scan required!).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Changed P_Mode to P_CmdSrc.  #####";
				N: XIC(EnableIn)P_CmdSrc(CmdSrc);
				RC: "First-Come First-Served Ownership Arbitration still needs to happen, even when device is disabled.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "$QLurking$Q Commands not handled elsewhere are cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [OTU(OCmd_On) OTU(OCmd_Off) OTU(OCmd_OnPulse) OTU(OCmd_OffPulse) OTU(OCmd_ContPulse) ,OTU(XCmd_On) OTU(XCmd_Off) OTU(XCmd_OnPulse) OTU(XCmd_OffPulse) OTU(XCmd_ContPulse) ,OTU(PCmd_On) OTU(PCmd_Off) OTU(PCmd_OnPulse) OTU(PCmd_OffPulse) OTU(PCmd_ContPulse) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,CLR(Inp_OvrdCmd) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_On) OTU(ORdy_Off) OTU(ORdy_OnPulse) OTU(ORdy_OffPulse) OTU(ORdy_ContPulse) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) ];
				RC: "============================================================$N"
				    "FEEDBACK DETERMINATION$N"
				    "============================================================$N"
				    "If the Device is being simulated or has no feedbacks, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to turn ON and OFF the device.$N"
				    "$N"
				    "If the Device is NOT being simulated and it HAS and IS USING feedback,$N"
				    "interpret the state of the configured feedbacks to determint the Device state..";
				N: XIO(Inp_Sim)[XIC(Cfg_UseOnFdbk) XIC(Inp_OnFdbk) ,XIO(Cfg_UseOnFdbk) XIC(Cfg_UseOffFdbk) XIO(Inp_OffFdbk) ]OTE(Wrk_OnFdbk);
				RC: "If the Device is being simulated or has no feedbacks, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to turn ON and OFF the device.$N"
				    "$N"
				    "If the Device is NOT being simulated and it HAS and IS USING feedback,$N"
				    "interpret the state of the configured feedbacks to determint the Device state..";
				N: [[XIC(Inp_Sim) ,XIO(Cfg_UseOffFdbk) XIO(Cfg_UseOnFdbk) ] ,XIO(Inp_Sim) [XIC(Cfg_UseOffFdbk) XIC(Inp_OffFdbk) ,XIO(Cfg_UseOffFdbk) XIC(Cfg_UseOnFdbk) XIO(Inp_OnFdbk) ] ]OTE(Wrk_OffFdbk);
				N: [XIO(Wrk_OnFdbk) XIC(Wrk_OffFdbk) MOV(1,Val_Fdbk) OTE(Sts_FdbkOff) ,XIC(Wrk_OnFdbk) XIO(Wrk_OffFdbk) MOV(2,Val_Fdbk) OTE(Sts_FdbkOn) ];
				RC: "The Device can be configured to have Feedbakc Failure shown for both$N"
				    "feedback inputs ON or for both inputs OFF.";
				N: [XIC(Cfg_FdbkFail) XIC(Wrk_OnFdbk) XIC(Wrk_OffFdbk) ,XIO(Cfg_FdbkFail) XIO(Wrk_OnFdbk) XIO(Wrk_OffFdbk) ]OTE(Sts_FdbkFail)MOV(3,Val_Fdbk);
				RC: "The OTHER (non-failure) state with both feedback inputs ON or both inputs OFF is$N"
				    "DEVICE IN TRANSIT.";
				N: [XIC(Cfg_FdbkFail) XIO(Wrk_OnFdbk) XIO(Wrk_OffFdbk) ,XIO(Cfg_FdbkFail) XIC(Wrk_OnFdbk) XIC(Wrk_OffFdbk) ]CLR(Val_Fdbk);
				RC: "Reset the output pulse, fault, and simulation timers.";
				N: [RES(Wrk_OnT) RES(Wrk_OffT) RES(Wrk_OnDelayT) RES(Wrk_OffDelayT) ,RES(Wrk_OnPulseT) RES(Wrk_OffPulseT) RES(Wrk_SimOnT) RES(Wrk_SimOffT) ];
				RC: "The Discrete Output is DE-ENERGIZED";
				N: [OTU(Sts_Out) OTU(Out) ,OTU(Wrk_StartHorn) OTU(Out_Horn) OTU(Sts_Horn) ];
				RC: "Show the device as Disabled and Not Ready, not Available, and with no$N"
				    "Maintenance Bypass breadcrumb.$N"
				    "Show the status of the output bit as DE-ENERGIZED.$N"
				    "Show the enumerated device command as NONE.$N"
				    "Show the enumerated device status as OFF.$N"
				    "Show the enumerated internal state as DE-ENERGIZED.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Disable/Enable and NoMode replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [OTU(Sts_Available) OTU(Sts_MaintByp) OTL(Sts_NotRdy) ,OTU(Nrdy_CfgErr) OTU(Nrdy_Fail) OTU(Nrdy_Intlk) OTU(Nrdy_IOFault) ,OTL(Nrdy_OoS) OTU(Nrdy_PrioOff) OTU(Nrdy_Perm) ,CLR(Wrk_Cmd) CLR(Val_Cmd) CLR(Wrk_State) CLR(Val_State) ,CLR(Val_Sts) CLR(Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(20,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(20,SrcQ);
				RC: "If the device is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then show the alarms as $QParent object out of service$Q.$N"
				    "Show the overall acknowledgement status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Changed P_Mode to P_CmdSrc, added Out of Service.  #####";
				N: [OTL(OnFail.Inp_OoS) P_Alarm(OnFail) ,OTL(OffFail.Inp_OoS) P_Alarm(OffFail) ,OTL(IntlkTrip.Inp_OoS) P_Alarm(IntlkTrip) ,OTL(IOFault.Inp_OoS) P_Alarm(IOFault) ,CLR(Val_Notify) CLR(Val_NotifyAll) ,[XIC(OnFail.Val_Notify.0) ,XIC(OffFail.Val_Notify.0) ,XIC(IntlkTrip.Val_Notify.0) ,XIC(IOFault.Val_Notify.0) ] OTL(Val_Notify.0) OTL(Val_NotifyAll.0) ,[XIC(OnFail.Sts_AlmInh) ,XIC(OffFail.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ] OTE(Sts_AlmInh) ];
		END_ROUTINE

		ROUTINE Logic (Description := "Control Discrete Output, monitoring Feedbacks")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_DOut:  PROCESS -- DISCRETE OUTPUT (on/off device)$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-16:  See V4.10.xx Release Notes for details.$N"
				    "V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-07-02:  Changed $QMode$Q to $QCommand Source$Q. Changed Inf_$N"
				    "items to HMI_, and added Cfg_Area for security. Added unacked alarm count.$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "Added option: Cfg_HasPulse. Aligned ready bit naming with command bit names.$N"
				    "Changed delay / time configuration items to REAL seconds.$N"
				    "V4.00.02  2018-10-30:  Fixed feedback determination for simulation or no feedback.$N"
				    "V4.10.00  2019-10-16:  Added audible alert on commanded energize/state change. $N"
				    "Added Horn Status, Horn Inhibit. Changed availability to use input availability$N"
				    "from interlocks. Updated to P_CmdSrc V4.10.00. Added Cfg_HasMoreObj.$N"
				    "V4.10.01  2019-10-11:  Corrected operation of state machine with alert horn.$N"
				    "============================================================$N"
				    "This Instruction controls (and optionally monitors feedback for)$N"
				    "a single Discrete Output and provides:$N"
				    "$N"
				    "*  Operator and Program Commands to:$N"
				    "    -  turn the output ON$N"
				    "    -  turn the output OFF$N"
				    "    -  if the output is OFF, pulse it ON for a configured time$N"
				    "    -  if the output is ON, pulse it OFF for a configured time, or$N"
				    "    -  pulse the output continuously at the configured ON$N"
				    "        and OFF times (e.g., for blinking a lamp)$N"
				    "*  User-configurable ON delay and OFF delay before first output change$N"
				    "*  User-configurable text labels for the ON and OFF states$N"
				    "*  Optional monitoring of ON and OFF state confirmation feedbacks$N"
				    "*  Detection of Failure to turn ON or OFF (when feedbacks are used)$N"
				    "*  Monitoring of Permissive conditions to allow energizing output$N"
				    "*  Monitoring of Interlock conditions to de-energize output$N"
				    "*  Optional return to previous state upon return from Hand,$N"
				    "      Override, or Interlock$N"
				    "*  Simulation, providing feedback of a working device while$N"
				    "      disabling output (keeping de-energized)$N"
				    "*  Monitoring of I/O communication faults$N"
				    "*  Alarms for Fail to Turn ON, Fail to turn OFF (if feedbacks are$N"
				    "      used), Interlock Trip, I/O Fault$N"
				    "*  $QAvailable$Q status for use by automation logic to know whether$N"
				    "      output can be controlled by other objects.$N"
				    "$N"
				    "Command Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$N"
				    "Command Sources: Operator, External, Program, External, Override, Maintenance,$N"
				    "Out of Service, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)CONCAT(Cfg_Desc,Cfg_Label,Cfg_Tag)CONCAT(Cfg_Area,Cfg_0StText,Cfg_1StText)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "COMMAND SOURCE PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Command Source selection Inputs and Commands:$N"
				    "$N"
				    "NOTE:  All Commands for Command Source and Alarm are aliased directly to the$N"
				    "corresponding Commands in the contained P_CmdSrc and P_Alarm AOIs.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Changed P_Mode to P_CmdSrc.  #####";
				N: LBL(SkipText)P_CmdSrc(CmdSrc);
				RC: "This rung handles simple First-Come First-Served Ownership Arbitration.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "If the device does not even HAVE Feedback inputs,$N"
				    "they cannot be USED for feedback checking!";
				N: [XIO(Cfg_HasOnFdbk) OTU(Cfg_UseOnFdbk) ,XIO(Cfg_HasOffFdbk) OTU(Cfg_UseOffFdbk) ];
				RC: "These rungs get Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration data are used directly in-place.$N"
				    "$N"
				    "Enter the time (in seconds) for the device to successfully turn ON before declaring a fault.$N"
				    "Enter the time (in seconds) for the device to successfully turn OFF before declaring a fault.$N"
				    "$N"
				    "If the timer preset calcuated wraps negative (more than 2.14... million seconds), then use a default$N"
				    "limit value and report Bad Configuration.  Note that a negative timer preset will fault the controller!!!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Changed delay / time configuration items to REAL seconds.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  Added Inp_HornInh to disable Horn operation.  #####";
				N: [[MUL(Cfg_OnDelayT,1000.0,Wrk_OnDelayT.PRE) XIC(Wrk_OnDelayT.PRE.31) MOV(0,Wrk_OnDelayT.PRE) ,MUL(Cfg_OffDelayT,1000.0,Wrk_OffDelayT.PRE) XIC(Wrk_OffDelayT.PRE.31) MOV(0,Wrk_OffDelayT.PRE) ,MUL(Cfg_OnPulseT,1000.0,Wrk_OnPulseT.PRE) XIC(Wrk_OnPulseT.PRE.31) MOV(2147483647,Wrk_OnPulseT.PRE) ,MUL(Cfg_OffPulseT,1000.0,Wrk_OffPulseT.PRE) XIC(Wrk_OffPulseT.PRE.31) MOV(2147483647,Wrk_OffPulseT.PRE) ,MUL(Cfg_OnFailT,1000.0,Wrk_OnT.PRE) XIC(Wrk_OnT.PRE.31) MOV(2147483647,Wrk_OnT.PRE) ,MUL(Cfg_OffFailT,1000.0,Wrk_OffT.PRE) XIC(Wrk_OffT.PRE.31) MOV(2147483647,Wrk_OffT.PRE) ,MUL(Cfg_StartHornT,1000.0,Wrk_StartHornT.PRE) [XIC(Wrk_StartHornT.PRE.31) ,GRT(Wrk_StartHornT.PRE,1000000) ] CLR(Wrk_StartHornT.PRE) ] OTE(Err_Timer) ,XIC(Inp_HornInh) CLR(Wrk_StartHornT.PRE) ];
				RC: "Enter the time (in seconds) to echo back the desired state when running in simulation$N"
				    "$N"
				    "Handle timer preset invalid values as above.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-08:  Changed delay / time configuration items to REAL seconds.  #####$N"
				    "";
				N: MUL(Cfg_SimFdbkT,1000.0,Wrk_SimOnT.PRE)[XIC(Wrk_SimOnT.PRE.31) MOV(0,Wrk_SimOnT.PRE) OTE(Err_Sim) ,MOV(Wrk_SimOnT.PRE,Wrk_SimOffT.PRE) ];
				RC: "This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N"
				    "(in the Configuration handling section).";
				N: [XIC(Err_Timer) ,XIC(Err_Sim) ]OTE(Nrdy_CfgErr);
				RC: "============================================================$N"
				    "SIMULATION AND FAIL TIMERS$N"
				    "============================================================$N"
				    "These rungs CHECK the timers that are based on the determined output state.$N"
				    "$N"
				    "This rung checks the OFF state timers.$N"
				    "$N"
				    "#####  V4.00.02  2018-10-30:  Handle case where simulation time is set to zero.  #####";
				N: XIO(Wrk_State.0)TON(Wrk_OffT,?,?)TON(Wrk_SimOffT,?,?)TON(Wrk_SimOffT,?,?);
				RC: "And this rung checks the ON State timers.$N"
				    "$N"
				    "#####  V4.00.02  2018-10-30:  Handle case where simulation time is set to zero.  #####";
				N: XIC(Wrk_State.0)TON(Wrk_OnT,?,?)TON(Wrk_SimOnT,?,?)TON(Wrk_SimOnT,?,?);
				RC: "============================================================$N"
				    "FEEDBACK DETERMINATION$N"
				    "============================================================$N"
				    "If the Device is being simulated or has no feedbacks, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to turn ON and OFF the device.$N"
				    "$N"
				    "If the Device is NOT being simulated and it HAS and IS USING feedback,$N"
				    "interpret the state of the configured feedbacks to determint the Device state..$N"
				    "$N"
				    "#####  V4.00.02  2018-10-30:  Fixed feedback determination for simulation or no feedback.  #####";
				N: [[XIC(Inp_Sim) ,XIO(Cfg_UseOnFdbk) XIO(Cfg_UseOffFdbk) ] [XIC(Wrk_SimOnT.DN) XIC(Cfg_FdbkFail) ,XIO(Wrk_SimOffT.DN) XIO(Cfg_FdbkFail) ] ,XIO(Inp_Sim) [XIC(Cfg_UseOnFdbk) XIC(Inp_OnFdbk) ,XIO(Cfg_UseOnFdbk) XIC(Cfg_UseOffFdbk) XIO(Inp_OffFdbk) ] ]OTE(Wrk_OnFdbk);
				RC: "If the Device is being simulated or has no feedbacks, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to turn ON and OFF the device.$N"
				    "$N"
				    "If the Device is NOT being simulated and it HAS and IS USING feedback,$N"
				    "interpret the state of the configured feedbacks to determint the Device state.$N"
				    "$N"
				    "#####  V4.00.02  2018-10-30:  Fixed feedback determination for simulation or no feedback.  #####";
				N: [[XIC(Inp_Sim) ,XIO(Cfg_UseOffFdbk) XIO(Cfg_UseOnFdbk) ] [XIC(Wrk_SimOffT.DN) XIC(Cfg_FdbkFail) ,XIO(Wrk_SimOnT.DN) XIO(Cfg_FdbkFail) ] ,XIO(Inp_Sim) [XIC(Cfg_UseOffFdbk) XIC(Inp_OffFdbk) ,XIO(Cfg_UseOffFdbk) XIC(Cfg_UseOnFdbk) XIO(Inp_OnFdbk) ] ]OTE(Wrk_OffFdbk);
				N: [XIO(Wrk_OnFdbk) XIC(Wrk_OffFdbk) OTE(Sts_FdbkOff) MOV(1,Val_Fdbk) ,XIC(Wrk_OnFdbk) XIO(Wrk_OffFdbk) OTE(Sts_FdbkOn) MOV(2,Val_Fdbk) ];
				RC: "The Device can be configured to have Feedbakc Failure shown for both$N"
				    "feedback inputs ON or for both inputs OFF.";
				N: [XIC(Cfg_FdbkFail) XIC(Wrk_OnFdbk) XIC(Wrk_OffFdbk) ,XIO(Cfg_FdbkFail) XIO(Wrk_OnFdbk) XIO(Wrk_OffFdbk) ]OTE(Sts_FdbkFail)MOV(3,Val_Fdbk);
				RC: "The OTHER (non-failure) state with both feedback inputs ON or both inputs OFF is$N"
				    "DEVICE IN TRANSIT.";
				N: [XIC(Cfg_FdbkFail) XIO(Wrk_OnFdbk) XIO(Wrk_OffFdbk) ,XIO(Cfg_FdbkFail) XIC(Wrk_OnFdbk) XIC(Wrk_OffFdbk) ]CLR(Val_Fdbk);
				RC: "============================================================$N"
				    "INTERLOCK / PERMISSIVE BYPASS / CHECK COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Bypass Command bypasses the Bypassable Permissives and Interlocks.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Changed Bypass/Check to Maintenance commands.  #####";
				N: XIC(MCmd_Bypass)OTU(MCmd_Bypass)OTL(Wrk_Bypass);
				RC: "The Check Command enables checking of ALL$N"
				    "Permissives and Interlocks (cancels the bypass).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Changed Bypass/Check to Maintenance commands.  #####";
				N: XIC(MCmd_Check)OTU(MCmd_Check)OTU(Wrk_Bypass);
				RC: "If the internal Bypass flag is set, Bypassable Interlocks and Permissives ARE BYPASSED.$N"
				    "Bypassing is ACTIVE if Bypass selected OR in Maintenance,$N"
				    "or in Override if Override Bypassing is configured.";
				N: [XIC(Wrk_Bypass) OTE(Sts_Bypass) ,XIC(Sts_Maint) ,XIC(Sts_Ovrd) XIC(Cfg_OvrdPermIntlk) ]OTE(Sts_BypActive);
				RC: "If a Maintenance Bypass function is active, display the Maintenance Bypass$N"
				    "Indicator (triangle symbol) on the graphic symbol.  Bypass functions are:$N"
				    "*  Interlock / Permissive Bypass function is enabled$N"
				    "* Device HAS OFF or ON feedback designated by engineer, but$N"
				    "maintenance has selected to NOT USE that feedback";
				N: [XIC(Cfg_HasOnFdbk) XIO(Cfg_UseOnFdbk) ,XIC(Cfg_HasOffFdbk) XIO(Cfg_UseOffFdbk) ,XIC(Sts_Bypass) ]OTE(Sts_MaintByp);
				RC: "Ready for Interlock / Permissive Bypass if not bypassed.$N"
				    "Ready to cancel Bypass (resume checking) if bypassed.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Aligned Ready bit naming with Command bits.  #####";
				N: [XIO(Wrk_Bypass) OTE(MRdy_Bypass) ,XIC(Wrk_Bypass) OTE(MRdy_Check) ];
				RC: "============================================================$N"
				    "ALARM AND DEVICE RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "The rungs in this section handle commands for this Device, received$N"
				    "in Operator, Program, Override and Maintenance.$N"
				    "(Hand Command Source is handled separately, below.$N"
				    "$N"
				    "For any command which involves energizing the device (all commands$N"
				    "except OFF), permissives must be OK to energize.";
				N: [XIC(Inp_PermOK) ,XIC(Sts_BypActive) ]XIC(Inp_NBPermOK)OTE(Wrk_PermOK);
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "This rung processes received Reset Commands from:$N"
				    "$N"
				    "1.  The Operator via HMI Operator Command, or$N"
				    "2.  Higher-level strategies via Program Command$N"
				    "3.  Pushbuttons or other block via Input$N"
				    "4.  Resets initiated by other device Operator Commands (if configured to do so)$N"
				    "and forwards the Reset to ALL Alarms and latched Shed conditions.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(XCmd_Reset) OTU(XCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ,[XIC(OCmd_Off) ,[XIC(OCmd_On) ,XIC(Cfg_HasPulse) [XIC(OCmd_OffPulse) ,XIC(OCmd_OnPulse) ,XIC(OCmd_ContPulse) ] ] XIC(Wrk_PermOK) ] XIC(Cfg_OCmdResets) XIO(Nrdy_CfgErr) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,[XIC(XCmd_Off) ,[XIC(XCmd_On) ,XIC(Cfg_HasPulse) [XIC(XCmd_OffPulse) ,XIC(XCmd_OnPulse) ,XIC(XCmd_ContPulse) ] ] XIC(Wrk_PermOK) ] XIC(Cfg_XCmdResets) XIO(Nrdy_CfgErr) XIC(Sts_Ext) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(PCmd_OnFailAck) ,OTL(PCmd_OffFailAck) ,OTL(PCmd_IntlkTripAck) ,OTL(PCmd_IOFaultAck) ] ][OTL(OnFail.PCmd_Reset) ,OTL(OffFail.PCmd_Reset) ,OTL(IntlkTrip.PCmd_Reset) ,OTL(IOFault.PCmd_Reset) ,XIC(Sts_OnFail) RES(Wrk_OnT) ,XIC(Sts_OffFail) RES(Wrk_OffT) ,OTU(Nrdy_PrioOff) OTU(Nrdy_Fail) ,[XIO(Inp_IOFault) ,XIC(Inp_Sim) ] OTU(Nrdy_IOFault) ];
				RC: "============================================================$N"
				    "DEVICE FAIL TO TURN ON DETECTION$N"
				    "============================================================$N"
				    "If the DEVICE SHOULD BE ON, run an $QOn$Q Timer to check for Fail to Turn On,$N"
				    "and run a Simulation Timer to provide simulated ON feedback if needed.$N"
				    "$N"
				    "If the ON Timer times out and the device feedback (or simulated feedback) never showed up,$N"
				    "show the device as $QFAILED TO TURN ON$Q and issue an Alarm.";
				N: XIC(Wrk_OnT.DN)NEQ(Wrk_OnT.PRE,0)NEQ(Val_Fdbk,2)XIO(Sts_Maint)OTE(Sts_OnFail);
				RC: "============================================================$N"
				    "DEVICE FAIL TO TURN OFF DETECTION$N"
				    "============================================================$N"
				    "If the Device SHOULD BE OFF, run an OFF Timer to check for Fail to Trun OFF,$N"
				    "and run a Simulation Timer to provide simulated OFF feedback if needed.$N"
				    "$N"
				    "If the OFF Timer times out and the device OFF feedback (or simulated feedback) never showed $QOff$Q,$N"
				    "show the device as $QFAILED TO TURN OFF$Q and issue an Alarm.";
				N: XIC(Wrk_OffT.DN)NEQ(Wrk_OffT.PRE,0)NEQ(Val_Fdbk,1)XIO(Sts_Maint)OTE(Sts_OffFail);
				RC: "Higher Priority:$N"
				    "If Interlocks are not OK (Non-Bypassable not OK, or bypassable not OK$N"
				    "and not bypassed by Maintenance, Override or Bypass Command), $N"
				    "OR if the Device is DISABLED or FAULTED, set it to its FAIL STATE.$N"
				    "$N"
				    "If the Device is NOT in its fail state (if it is energized) and the Interlock$N"
				    "de-energized it, raise the Interlock Trip alarm.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_CfgErr) ,XIC(Sts_OoS) OTE(Nrdy_OoS) ,XIO(Wrk_PermOK) XIO(Wrk_State.0) OTE(Nrdy_Perm) ,[XIO(Inp_IntlkOK) XIO(Sts_BypActive) ,XIO(Inp_NBIntlkOK) ] [XIO(Wrk_Cmd.0) NEQ(Val_Sts,0) OTE(Sts_IntlkTrip) ,OTE(Nrdy_Intlk) ] ,XIC(Inp_IOFault) XIO(Inp_Sim) OTE(Sts_IOFault) XIC(Cfg_ShedOnIOFault) OTL(Nrdy_IOFault) ,XIC(Sts_OnFail) XIC(Cfg_ShedOnFail) OTL(Nrdy_Fail) ]OTE(Wrk_NotRdy);
				RC: "Higher Priority:$N"
				    "If Interlocks are not OK (Non-Bypassable not OK, or bypassable not OK$N"
				    "and not bypassed by Maintenance, Override or Bypass Command), $N"
				    "OR if the Device is DISABLED or FAULTED, set it to its FAIL STATE.$N"
				    "$N"
				    "If the Device is NOT in its fail state (if it is energized) and the Interlock$N"
				    "de-energized it, raise the Interlock Trip alarm.";
				N: [XIC(Wrk_NotRdy) ,XIC(Nrdy_PrioOff) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) ]OTE(Sts_NotRdy);
				RC: "If the device isn$'t $Qnot ready$Q (it IS ready) and it$'s in Program Mode,$N"
				    "then it is AVAILABLE to be controlled by automation (Program Mode logic).$N"
				    "#####  V4.10.00  2019-03-08:  Changed availability to use input availability from interlocks.  #####";
				N: XIC(Sts_Prog)XIO(Nrdy_CfgErr)XIO(Nrdy_OoS)XIO(Nrdy_Perm)XIO(Nrdy_IOFault)XIO(Nrdy_Fail)XIO(Nrdy_PrioOff)[[XIC(Inp_IntlkOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBIntlkOK) ,XIC(Inp_IntlkAvail) ]OTE(Sts_Available);
				RC: "============================================================$N"
				    "DEVICE COMMAND HANDLING$N"
				    "============================================================$N"
				    "If a Device CONTINUOUS PULSE command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is CONTINUOUSE PULSE,$N"
				    "mark the Device Target State as CONTINUOUS PULSE (4).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External commands.  Added option: Cfg_HasPulse.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: [XIC(OCmd_ContPulse) OTU(OCmd_ContPulse) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_ContPulse) OTU(XCmd_ContPulse) XIC(Sts_Ext) ,XIC(PCmd_ContPulse) OTU(PCmd_ContPulse) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,5) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]XIC(Cfg_HasPulse)XIC(Wrk_PermOK)XIO(Sts_NotRdy)NEQ(Wrk_OffPulseT.PRE,0)NEQ(Wrk_OnPulseT.PRE,0)[[XIC(Cfg_HornOnChange) NEQ(Wrk_Cmd,16) ,EQU(Wrk_Cmd,0) EQU(Wrk_State,0) ] OTL(Wrk_StartHorn) ,MOV(16,Wrk_Cmd) ];
				RC: "If a Device ON PULSE command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is ON PULSE,$N"
				    "mark the Device Target State as ON PULSE (2).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Added External commands.  Added option: Cfg_HasPulse.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: [XIC(OCmd_OnPulse) OTU(OCmd_OnPulse) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_OnPulse) OTU(XCmd_OnPulse) XIC(Sts_Ext) ,XIC(PCmd_OnPulse) OTU(PCmd_OnPulse) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,4) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]XIC(Cfg_HasPulse)XIC(Wrk_PermOK)XIO(Sts_NotRdy)NEQ(Wrk_OnPulseT.PRE,0)[[XIC(Cfg_HornOnChange) NEQ(Wrk_Cmd,8) ,EQU(Wrk_Cmd,0) EQU(Wrk_State,0) ] OTL(Wrk_StartHorn) ,MOV(8,Wrk_Cmd) ];
				RC: "If a Device OFF PULSE command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is OFF PULSE,$N"
				    "mark the Device Target State as OFF PULSE (3).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Added External commands.  Added option: Cfg_HasPulse.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: [XIC(OCmd_OffPulse) OTU(OCmd_OffPulse) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_OffPulse) OTU(XCmd_OffPulse) XIC(Sts_Ext) ,XIC(PCmd_OffPulse) OTU(PCmd_OffPulse) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,3) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]XIC(Cfg_HasPulse)XIC(Wrk_PermOK)XIO(Sts_NotRdy)NEQ(Wrk_OffPulseT.PRE,0)[[XIC(Cfg_HornOnChange) NEQ(Wrk_Cmd,4) ,EQU(Wrk_Cmd,0) EQU(Wrk_State,0) ] OTL(Wrk_StartHorn) ,MOV(4,Wrk_Cmd) ];
				RC: "If a Device ON command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is ON,$N"
				    "mark the Device Target State as ON (1).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External commands.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: [XIC(OCmd_On) OTU(OCmd_On) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_On) OTU(XCmd_On) XIC(Sts_Ext) ,XIC(PCmd_On) OTU(PCmd_On) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,2) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]XIC(Wrk_PermOK)XIO(Sts_NotRdy)[[XIC(Cfg_HornOnChange) NEQ(Wrk_State,1) ,EQU(Wrk_Cmd,0) EQU(Wrk_State,0) ] OTL(Wrk_StartHorn) ,MOV(2,Wrk_Cmd) ];
				RC: "If a Device OFF command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is OFF,$N"
				    "mark the Device Target State as OFF (0).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External commands.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: [XIC(OCmd_Off) OTU(OCmd_Off) [XIC(Sts_Oper) ,XIC(Sts_Maint) ,XIC(Cfg_OperOffPrio) XIO(Sts_Oper) XIO(Sts_Maint) OTL(Nrdy_PrioOff) ] ,XIC(XCmd_Off) OTU(XCmd_Off) [XIC(Sts_Ext) ,XIC(Cfg_ExtOffPrio) XIO(Sts_Ext) OTL(Nrdy_PrioOff) ] ,XIC(PCmd_Off) OTU(PCmd_Off) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,1) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ,XIC(Sts_NotRdy) NEQ(Wrk_State,0) ][[XIC(Cfg_HornOnChange) NEQ(Wrk_State,0) ,EQU(Wrk_Cmd,0) EQU(Wrk_State,0) ] XIO(Sts_NotRdy) OTL(Wrk_StartHorn) ,MOV(1,Wrk_Cmd) ];
				RC: "Higher Priority: HAND mode wins over others:$N"
				    "If in Hand, have the Device follow the feedback.$N"
				    "If the Device is ON, set the Target State to ON, and if the Device$N"
				    "is OFF, set the Target State to OFF; upon transition out of Hand, the$N"
				    "device will hold its last state.$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIC(Sts_Hand) ,XIO(Inp_Sim) ONS(Wrk_NoLongerSim) ,XIC(S:FS) ]CLR(Wrk_Cmd)OTU(Wrk_StartHorn)[EQU(Val_Fdbk,2) XIO(Sts_NotRdy) MOV(1,Val_Sts) MOV(1,Wrk_State) ,[NEQ(Val_Fdbk,2) ,XIC(Sts_NotRdy) ] CLR(Val_Sts) CLR(Wrk_State) ];
				RC: "============================================================$N"
				    "STATE MACHINE$N"
				    "============================================================$N"
				    "The Discrete Output is processed using a State Machine to handle pulsing$N"
				    "delays, On and Off delays, commands for changes of state, etc.$N"
				    "$N"
				    "These rungs handle changes of Actual State based on Target State$N"
				    "set by Commands above.  (Timers and the time-based$N"
				    "transitions follow...)$N"
				    "$N"
				    "See the Timing Diagrams and state tables in the Reference$N"
				    "Manual for details on the state machine.$N"
				    "$N"
				    "On Prestart Horn - Sound the horn for the configured time.$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: [XIC(Wrk_StartHorn) TON(Wrk_StartHornT,?,?) TON(Wrk_StartHornT,?,?) ,XIC(Wrk_StartHornT.DN) OTU(Wrk_StartHorn) ];
				N: XIC(Wrk_StartHorn)[XIO(Wrk_State.0) MOV(14,Wrk_State) ,XIC(Wrk_State.0) MOV(15,Wrk_State) ];
				RC: "STATE 14:  SOUNDING HORN WITH OUTPUT OFF$N"
				    "#####  V4.10.01  2019-10-16:  Added state.  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,14)[XIC(Wrk_Cmd.0) OTU(Wrk_StartHorn) MOV(0,Wrk_State) ,XIO(Wrk_StartHorn) [XIC(Wrk_Cmd.1) MOV(2,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(4,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(8,Wrk_State) ] ];
				RC: "STATE 15:  SOUNDING HORN WITH OUTPUT ON$N"
				    "$N"
				    "#####  V4.10.01  2019-10-16:  Added state.  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,15)[XIC(Wrk_Cmd.1) OTU(Wrk_StartHorn) MOV(1,Wrk_State) ,XIO(Wrk_StartHorn) [XIC(Wrk_Cmd.0) MOV(3,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(5,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(9,Wrk_State) ] ];
				RC: "STATE 0:  Turned OFF";
				N: EQU(Wrk_State,0)[XIC(Wrk_Cmd.1) MOV(2,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(4,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(8,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 1:  Turned ON";
				N: EQU(Wrk_State,1)[XIC(Wrk_Cmd.0) MOV(3,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(5,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(9,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 2:  ON-DELAY when commanded ON";
				N: EQU(Wrk_State,2)[XIC(Wrk_Cmd.0) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(4,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(8,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 3:  OFF-DELAY when commanded OFF$N"
				    "";
				N: EQU(Wrk_State,3)[XIC(Wrk_Cmd.1) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(5,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(9,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 4:  ON-DELAY when commanded PULSE ON$N"
				    "";
				N: EQU(Wrk_State,4)[XIC(Wrk_Cmd.0) XIO(Cfg_CompletePulse) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.1) MOV(2,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(8,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 5:  OFF-DELAY when commanded PULSE OFF$N"
				    "";
				N: EQU(Wrk_State,5)[XIC(Wrk_Cmd.0) MOV(3,Wrk_State) ,XIC(Wrk_Cmd.1) XIO(Cfg_CompletePulse) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(9,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 6:  PULSE OFF TIME when commanded PULSE OFF$N"
				    "";
				N: EQU(Wrk_State,6)[XIC(Wrk_Cmd.0) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.1) XIO(Cfg_CompletePulse) MOV(2,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(4,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(10,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 7:  PULSE ON TIME when commanded PULSE ON";
				N: EQU(Wrk_State,7)[XIC(Wrk_Cmd.0) XIO(Cfg_CompletePulse) MOV(3,Wrk_State) ,XIC(Wrk_Cmd.1) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(5,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(11,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 8:  ON-DELAY when commanded PULSE CONTINUOUS$N"
				    "";
				N: EQU(Wrk_State,8)[XIC(Wrk_Cmd.0) XIO(Cfg_CompletePulse) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.1) MOV(2,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(4,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 9:  OFF-DELAY when commanded PULSE CONTINUOUS$N"
				    "$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,9)[XIC(Wrk_Cmd.0) MOV(3,Wrk_State) ,XIC(Wrk_Cmd.1) XIO(Cfg_CompletePulse) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(5,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 10:  OFF PULSE TIME when commanded PULSE CONTINUOUS$N"
				    "";
				N: EQU(Wrk_State,10)[XIC(Wrk_Cmd.0) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.1) [XIO(Cfg_CompletePulse) MOV(2,Wrk_State) ,XIC(Cfg_CompletePulse) MOV(12,Wrk_State) ] ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.3) [XIO(Cfg_CompletePulse) MOV(4,Wrk_State) ,XIC(Cfg_CompletePulse) MOV(12,Wrk_State) ] ,JMP(DelayTimers) ];
				RC: "STATE 11:  ON PULSE TIME when commanded PULSE CONTINUOUS$N"
				    "";
				N: EQU(Wrk_State,11)[XIC(Wrk_Cmd.0) [XIO(Cfg_CompletePulse) MOV(3,Wrk_State) ,XIC(Cfg_CompletePulse) MOV(13,Wrk_State) ] ,XIC(Wrk_Cmd.1) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.2) [XIO(Cfg_CompletePulse) MOV(5,Wrk_State) ,XIC(Cfg_CompletePulse) MOV(13,Wrk_State) ] ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 12:  OFF TIME when COMPLETING OFF PULSE$N"
				    "";
				N: EQU(Wrk_State,12)[XIC(Wrk_Cmd.0) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.1) XIO(Cfg_CompletePulse) MOV(2,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ,XIC(Wrk_Cmd.3) XIO(Cfg_CompletePulse) MOV(4,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(10,Wrk_State) ,JMP(DelayTimers) ];
				RC: "STATE 13:  ON TIME when COMPLETING OFF PULSE$N"
				    "";
				N: EQU(Wrk_State,13)[XIC(Wrk_Cmd.0) XIO(Cfg_CompletePulse) MOV(3,Wrk_State) ,XIC(Wrk_Cmd.1) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.2) XIO(Cfg_CompletePulse) MOV(5,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ,XIC(Wrk_Cmd.4) MOV(11,Wrk_State) ,JMP(DelayTimers) ];
				RC: "============================================================$N"
				    "ON-DELAY, OFF-DELAY TIMERS$N"
				    "============================================================$N"
				    "The TON timers here are used to check for on-delay / off-delay in each of the$N"
				    "delaying states, based on the state entering the scan or the state determined$N"
				    "in the transitions above.  (If a delay time is zero, we transition immediately.)$N"
				    "$N"
				    "@@@@@  Each TON is doubled to ensure it sets or clears the  @@@@@$N"
				    "@@@@@  .DN bit the same scan if the timer preset is zero.  @@@@@$N"
				    "The Timers will be disabled while Horn is active, preventing change of state$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: LBL(DelayTimers)[[EQU(Wrk_State,2) ,EQU(Wrk_State,4) ,EQU(Wrk_State,8) ] TON(Wrk_OnDelayT,?,?) TON(Wrk_OnDelayT,?,?) ,[EQU(Wrk_State,3) ,EQU(Wrk_State,5) ,EQU(Wrk_State,9) ] TON(Wrk_OffDelayT,?,?) TON(Wrk_OffDelayT,?,?) ];
				RC: "If this object is in a PULSING state (6=PulseOFF, 7=PulseON, 8-13=PulseCONTINUOUS),$N"
				    "and if the current state$'s pulse time is configured to a ZERO preset,$N"
				    "revert to the current ON or OFF state (and command).";
				N: GEQ(Wrk_State,6)[XIO(Wrk_State.0) EQU(Wrk_OffPulseT.PRE,0) [XIC(Wrk_Cmd.3) ,XIC(Wrk_Cmd.4) ] MOV(0,Wrk_State) MOV(1,Wrk_Cmd) ,XIC(Wrk_State.0) EQU(Wrk_OnPulseT.PRE,0) [XIC(Wrk_Cmd.2) ,XIC(Wrk_Cmd.4) ] MOV(1,Wrk_State) MOV(2,Wrk_Cmd) ]JMP(PulseTimers);
				RC: "============================================================$N"
				    "ON-DELAY, OFF-DELAY TRANSITIONS$N"
				    "============================================================$N"
				    "These rungs check for timer-done based transitions.$N"
				    "Checks are done here to properly handle transitions for timers$N"
				    "with ZERO presets.$N"
				    "$N"
				    "STATE 2: ON-DELAY when commanded ON";
				N: EQU(Wrk_State,2)[XIC(Wrk_Cmd.1) XIC(Wrk_OnDelayT.DN) MOV(1,Wrk_State) ,JMP(PulseTimers) ];
				RC: "STATE 3:  OFF-DELAY when commanded OFF";
				N: EQU(Wrk_State,3)[XIC(Wrk_Cmd.0) XIC(Wrk_OffDelayT.DN) MOV(0,Wrk_State) ,JMP(PulseTimers) ];
				RC: "STATE 4:  ON-DELAY when commanded PULSE ON";
				N: EQU(Wrk_State,4)[[XIC(Wrk_Cmd.0) ,XIC(Wrk_Cmd.3) ] XIC(Wrk_OnDelayT.DN) MOV(7,Wrk_State) ,JMP(PulseTimers) ];
				RC: "STATE 5:  OFF-DELAY when commanded PULSE OFF";
				N: EQU(Wrk_State,5)[[XIC(Wrk_Cmd.1) ,XIC(Wrk_Cmd.2) ] XIC(Wrk_OffDelayT.DN) MOV(6,Wrk_State) ,JMP(PulseTimers) ];
				RC: "STATE 8:  ON-DELAY when commanded PULSE CONTINUOUS";
				N: EQU(Wrk_State,8)[[XIC(Wrk_Cmd.0) ,XIC(Wrk_Cmd.4) ] XIC(Wrk_OnDelayT.DN) MOV(11,Wrk_State) ,JMP(PulseTimers) ];
				RC: "STATE 9:  OFF-DELAY when commanded PULSE CONTINUOUS";
				N: EQU(Wrk_State,9)[[XIC(Wrk_Cmd.1) ,XIC(Wrk_Cmd.4) ] XIC(Wrk_OffDelayT.DN) MOV(10,Wrk_State) ,JMP(PulseTimers) ];
				RC: "============================================================$N"
				    "PULSE STATE TIMERS$N"
				    "============================================================$N"
				    "The TON timers here are used to check for pulse complete in each of the$N"
				    "pulsing states, based on the state entering the scan or the state determined$N"
				    "in the transitions above.  (If a pulse time is zero, we transition immediately.)$N"
				    "$N"
				    "@@@@@  Each TON is doubled to ensure it sets or clears the  @@@@@$N"
				    "@@@@@  .DN bit the same scan if the timer preset is zero.  @@@@@";
				N: LBL(PulseTimers)[[EQU(Wrk_State,6) ,EQU(Wrk_State,10) ,EQU(Wrk_State,12) ] TON(Wrk_OffPulseT,?,?) TON(Wrk_OffPulseT,?,?) ,[EQU(Wrk_State,7) ,EQU(Wrk_State,11) ,EQU(Wrk_State,13) ] TON(Wrk_OnPulseT,?,?) TON(Wrk_OnPulseT,?,?) ];
				RC: "STATE 6:  PULSE OFF TIME when commanded PULSE OFF$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,6)[[XIC(Wrk_Cmd.1) ,XIC(Wrk_Cmd.2) ] XIC(Wrk_OffPulseT.DN) MOV(2,Wrk_Cmd) MOV(1,Wrk_State) ,JMP(Output) ];
				RC: "STATE 7:  PULSE ON TIME when commanded PULSE ON$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,7)[[XIC(Wrk_Cmd.0) ,XIC(Wrk_Cmd.3) ] XIC(Wrk_OnPulseT.DN) MOV(1,Wrk_Cmd) MOV(0,Wrk_State) ,JMP(Output) ];
				RC: "STATE 10:  OFF PULSE TIME when commanded PULSE CONTINUOUS$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,10)[XIC(Wrk_Cmd.4) XIC(Wrk_OffPulseT.DN) MOV(11,Wrk_State) ,JMP(Output) ];
				RC: "STATE 11:  ON PULSE TIME when commanded PULSE CONTINUOUS$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: EQU(Wrk_State,11)[XIC(Wrk_Cmd.4) XIC(Wrk_OnPulseT.DN) MOV(10,Wrk_State) ,JMP(Output) ];
				RC: "STATE 12:  OFF TIME when COMPLETING OFF PULSE";
				N: EQU(Wrk_State,12)[XIC(Wrk_OffPulseT.DN) [XIC(Wrk_Cmd.1) MOV(1,Wrk_State) ,XIC(Wrk_Cmd.3) MOV(7,Wrk_State) ] ,JMP(Output) ];
				RC: "STATE 13:  ON TIME when COMPLETING OFF PULSE";
				N: EQU(Wrk_State,13)[XIC(Wrk_OnPulseT.DN) [XIC(Wrk_Cmd.0) MOV(0,Wrk_State) ,XIC(Wrk_Cmd.2) MOV(6,Wrk_State) ] ,JMP(Output) ];
				RC: "Clear the current Command if the DOut reaches a terminal state (OFF or ON).$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Corrected operation of state machine with alert horn.  #####";
				N: LBL(Output)[XIC(Wrk_Cmd.0) EQU(Wrk_State,0) CLR(Wrk_Cmd) ,XIC(Wrk_Cmd.1) EQU(Wrk_State,1) CLR(Wrk_Cmd) ];
				RC: "============================================================$N"
				    "OUTPUT GENERATION$N"
				    "============================================================$N"
				    "If the Device is NOT SIMULATED, generate the appropriate output.$N"
				    "From the design of the State Machine, all ODD Actual States have the$N"
				    "output ENERGIZED.  So just copy the least significant bit out!$N"
				    "#####  V4.10.00  2019-03-08:  Added audible alert on commanded energize/state change.  #####";
				N: [XIC(Wrk_State.0) [XIO(Inp_Sim) OTE(Out) ,OTE(Sts_Out) ] ,XIC(Wrk_StartHorn) [XIO(Inp_Sim) OTE(Out_Horn) ,OTE(Sts_Horn) ] ];
				RC: "============================================================$N"
				    "SIMULATION AND FAIL TIMERS$N"
				    "============================================================$N"
				    "These rungs START the timers that are based on the determined output state.$N"
				    "$N"
				    "This rung starts the OFF state timers.";
				N: XIO(Sts_Out)TON(Wrk_OffT,?,?)TON(Wrk_SimOffT,?,?);
				RC: "And this rung starts the ON State timers.";
				N: XIC(Sts_Out)TON(Wrk_OnT,?,?)TON(Wrk_SimOnT,?,?);
				RC: "============================================================$N"
				    "REMAINING DEVICE STATUS$N"
				    "============================================================$N"
				    "This device is PULSING if any of the Pulse commands has been issued$N"
				    "(and, for single pulses, not completed):$N"
				    "ON PULSE, OFF PULSE or CONTINUOUS PULSE";
				N: [XIC(Wrk_Cmd.2) ,XIC(Wrk_Cmd.3) ,XIC(Wrk_Cmd.4) ]OTE(Sts_Pulsing);
				RC: "============================================================$N"
				    "PULSE STATE TIMERS$N"
				    "============================================================$N"
				    "The timers here are used to START timing immedately for each of the$N"
				    "given states THIS SCAN.";
				N: [[EQU(Wrk_State,6) ,EQU(Wrk_State,10) ,EQU(Wrk_State,12) ] TON(Wrk_OffPulseT,?,?) ,[EQU(Wrk_State,7) ,EQU(Wrk_State,11) ,EQU(Wrk_State,13) ] TON(Wrk_OnPulseT,?,?) ];
				RC: "============================================================$N"
				    "DEVICE ENUMERATED VALUES$N"
				    "============================================================$N"
				    "Wrk_Cmd is the command currently being processed:$N"
				    "0 = None$N"
				    "1 = State 0$N"
				    "2 = State 1$N"
				    "3 = State 2$N"
				    "4 = State 3$N"
				    "$N"
				    "Wrk_State is the internal state machine state:$N"
				    "0 = OFF$N"
				    "1 = ON$N"
				    "2 = ON command ON-DELAY$N"
				    "3 = OFF command OFF-DELAY$N"
				    "4 = PULSE ON command ON-DELAY$N"
				    "5 = PULSE OFF command OFF-DELAY$N"
				    "6 = PULSE ON command ON PULSE time$N"
				    "7 = PULSE OFF command OFF PULSE time$N"
				    "8 = PULSE CONTINUOUS command ON-DELAY$N"
				    "9 = PULSE CONTINUOUS command OFF-DELAY$N"
				    "10 = PULSE CONTINUOUS command OFF PULSE time$N"
				    "11 = PULSE CONTINUOUS command ON PULSE time$N"
				    "12 = OFF PULSE completion time$N"
				    "13 = ON PULSE completion time";
				N: [MOV(Wrk_State,Val_State) ,EQU(Wrk_Cmd,0) CLR(Val_Cmd) ,XIC(Wrk_Cmd.0) MOV(1,Val_Cmd) ,XIC(Wrk_Cmd.1) MOV(2,Val_Cmd) ,XIC(Wrk_Cmd.2) MOV(3,Val_Cmd) ,XIC(Wrk_Cmd.3) MOV(4,Val_Cmd) ,XIC(Wrk_Cmd.4) MOV(5,Val_Cmd) ];
				RC: "Val_Sts is the current device status, as determined by this AOI,$N"
				    "based on its knowledge of commands executed and feedback.$N"
				    "(This is the status that should be monitored by, for example, FT Historian.)$N"
				    "0 = Off$N"
				    "1 = On$N"
				    "2 = Pulse Off$N"
				    "3 = Pulse On$N"
				    "4 = Pulse Continuous$N"
				    "5 = Turning On$N"
				    "6 = Turning Off$N"
				    "7 = Horn$N"
				    "33 = Out of Service (here or in EnableInFalse routine)$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02: Using P_CmdSrc, Disabled replaced by Out of Service.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added Horn Status.  #####";
				N: XIO(Sts_Hand)[XIO(Wrk_StartHorn) [EQU(Wrk_Cmd,0) [EQU(Wrk_State,0) CLR(Val_Sts) ,EQU(Wrk_State,1) MOV(1,Val_Sts) ] ,XIC(Wrk_Cmd.2) MOV(2,Val_Sts) ,XIC(Wrk_Cmd.3) MOV(3,Val_Sts) ,XIC(Wrk_Cmd.4) MOV(4,Val_Sts) ,XIC(Wrk_Cmd.0) MOV(5,Val_Sts) ,XIC(Wrk_Cmd.1) MOV(6,Val_Sts) ] ,XIC(Wrk_StartHorn) MOV(7,Val_Sts) ];
				RC: "============================================================$N"
				    "OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "$N"
				    "Ready to TURN OFF if in Operator Manual, NOT in the OFF target state, and Interlocks are OK.$N"
				    "Ready to TURN ON if in Operator or Maintenancel, NOT in the ON target state, and Interlocks and permissives are OK.$N"
				    "$N"
				    "Similar logic applies to the PULSE ON, PULSE OFF and CONTINUOUS PULSE readies.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Added option: Cfg_HasPulse.  #####";
				N: XIO(Wrk_NotRdy)[XIO(Sts_NotRdy) ,XIC(Cfg_OCmdResets) ][[XIC(Sts_Oper) ,XIC(Sts_Maint) ,XIC(Cfg_OperOffPrio) ] XIO(Wrk_Cmd.0) NEQ(Val_Sts,0) OTE(ORdy_Off) ,[XIC(Sts_Oper) ,XIC(Sts_Maint) ] XIC(Wrk_PermOK) [XIO(Wrk_Cmd.1) NEQ(Val_Sts,1) OTE(ORdy_On) ,XIC(Cfg_HasPulse) [XIO(Wrk_Cmd.2) NEQ(Val_Sts,2) NEQ(Val_Sts,0) NEQ(Wrk_OffPulseT.PRE,0) OTE(ORdy_OffPulse) ,XIO(Wrk_Cmd.3) NEQ(Val_Sts,3) NEQ(Val_Sts,1) NEQ(Wrk_OnPulseT.PRE,0) OTE(ORdy_OnPulse) ,XIO(Wrk_Cmd.4) NEQ(Val_Sts,4) NEQ(Wrk_OffPulseT.PRE,0) NEQ(Wrk_OnPulseT.PRE,0) OTE(ORdy_ContPulse) ] ] ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1), EXCEPT:$N"
				    "* If the device DOES NOT HAVE ANY FEEDBACKS, the On Fail and Off Fail$N"
				    "alarms will never occur and should not exist.  (If either feedback exists, $N"
				    "the Fail alarm must be allowed to exist.)";
				N: [OTL(IntlkTrip.PCfg_AllowExist) OTL(IOFault.PCfg_AllowExist) ,[XIC(Cfg_HasOnFdbk) ,XIC(Cfg_HasOffFdbk) ] OTE(OnFail.PCfg_AllowExist) OTE(OffFail.PCfg_AllowExist) ];
				RC: "Let the Alarm instance know if this object is taken Out of Service$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Now using P_CmdSrc, including Out of Service.  #####";
				N: XIC(CmdSrc.Sts_OoS)OTE(OnFail.Inp_OoS)OTE(OffFail.Inp_OoS)OTE(IntlkTrip.Inp_OoS)OTE(IOFault.Inp_OoS);
				RC: "Handle Failed to Confirm Output ON Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(OnFail);
				RC: "Handle Failed to Confirm Output OFF Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(OffFail);
				RC: "Handle Interlock Trip Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IntlkTrip);
				RC: "Handle I/O Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).";
				N: [XIC(OnFail.Sts_AlmInh) ,XIC(OffFail.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N"
				    "(in the Configuration handling section).";
				N: [XIC(Nrdy_CfgErr) ,[XIC(OnFail.Sts_Err) ,XIC(OffFail.Sts_Err) ,XIC(IntlkTrip.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "Val_Fault is the current device fault status, as determined by this AOI,$N"
				    "based on its knowledge of commands executed and feedback.$N"
				    "(This is the fault status that should be monitored by, for example, FT Historian.)$N"
				    "0 = None$N"
				    "16 = Feedback Fault$N"
				    "32 = I/O Fault (from Input)$N"
				    "34 = Configuration Error";
				N: [CLR(Wrk_Fault) ,[XIC(Sts_OnFail) ,XIC(Sts_OffFail) ] MOV(16,Wrk_Fault) ,[XIC(Sts_IOFault) ,XIC(Nrdy_IOFault) ] MOV(32,Wrk_Fault) ,XIC(Nrdy_CfgErr) MOV(34,Wrk_Fault) ,MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [CLR(Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(SrcQ_IO,SrcQ);
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count.  #####";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) ,GRT(OnFail.Val_Notify,Wrk_Notify) MOV(OnFail.Val_Notify,Wrk_Notify) ,GRT(OffFail.Val_Notify,Wrk_Notify) MOV(OffFail.Val_Notify,Wrk_Notify) ,GRT(IntlkTrip.Val_Notify,Wrk_Notify) MOV(IntlkTrip.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(OnFail.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(OffFail.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IntlkTrip.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTE(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_Notify,Val_NotifyAll) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "This rung identifies:$N"
				    "* if a latched Shed condition requires a reset in order to run the motor;$N"
				    "* if that reset or any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(OnFail.Sts_RdyAck) ,XIC(OffFail.Sts_RdyAck) ,XIC(IntlkTrip.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(OnFail.Sts_RdyReset) ,XIC(OffFail.Sts_RdyReset) ,XIC(IntlkTrip.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ,XIC(Nrdy_PrioOff) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) XIO(Sts_IOFault) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownershp, clear $Qlurking$Q Commands, de-energize output")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, set the Ownership to NO OWNER (0).";
				N: CLR(PSet_Owner)CLR(Val_Owner);
				RC: "$QLurking$Q Commands not handled elsewhere are cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [OTU(OCmd_On) OTU(OCmd_Off) OTU(OCmd_OnPulse) OTU(OCmd_OffPulse) OTU(OCmd_ContPulse) ,OTU(XCmd_On) OTU(XCmd_Off) OTU(XCmd_OnPulse) OTU(XCmd_OffPulse) OTU(XCmd_ContPulse) ,OTU(PCmd_On) OTU(PCmd_Off) OTU(PCmd_OnPulse) OTU(PCmd_OffPulse) OTU(PCmd_ContPulse) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,CLR(Inp_OvrdCmd) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-02:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_On) OTU(ORdy_Off) OTU(ORdy_OnPulse) OTU(ORdy_OffPulse) OTU(ORdy_ContPulse) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) ];
				RC: "Clear the latched Shed faults.";
				N: OTU(Nrdy_PrioOff)OTU(Nrdy_Fail)OTU(Nrdy_IOFault);
				RC: "Output is cleared on Prescan.";
				N: [OTU(Out) OTU(Sts_Out) ,OTU(Wrk_StartHorn) OTU(Out_Horn) OTU(Sts_Horn) ];
				RC: "Show the enumerated device command as NONE.$N"
				    "Show the enumerated device status as POWERUP / UNKNOWN$N"
				    "Show the enumerated internal state as DE-ENERGIZED.$N"
				    "$N"
				    "#####  V3.5-08  2017-10-11:  Reworked internal state machine logic.  #####";
				N: CLR(Wrk_Cmd)CLR(Val_Cmd)CLR(Wrk_State)CLR(Val_State)CLR(Val_Sts);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_VSD (Description := "Variable Speed Drive",
	                                     Revision := "4.10",
	                                     RevisionExtension := ".01 Release",
	                                     RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                     Vendor := "Rockwell Automation",
	                                     ExecutePrescan := Yes,
	                                     ExecutePostscan := No,
	                                     ExecuteEnableInFalse := Yes,
	                                     CreatedDate := "2008-03-27T19:50:50.098Z",
	                                     CreatedBy := "Not Available",
	                                     EditedDate := "2023-10-07T00:14:32.516Z",
	                                     EditedBy := "DESKTOP-1FEFFUM\Rockwell24",
	                                     SoftwareRevision := "v32.03",
	                                     AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction controls and monitors a Variable-Speed (AC or DC) Drive$Nand provides:$N$N*  Starting drive, stopping drive, jogging drive, setting speed reference and setting direction$N*  Monitoring of run feedback, display of actual drive status, including accel, decel, direction, speed$N*  Detection of Failure to Start, Failure to Stop, Drive Fault/Not Ready$N*  Monitoring of Permissive conditions to allow starting$N*  Monitoring of Interlock conditions to stop drive or prevent starting$N*  Simulation, providing feedback of a working drive while disabling outputs$N*  Monitoring of I/O communication faults$N*  Alarms for Fail to Start, Fail to Stop, Interlock Trip, Drive Fault/Not Ready, I/O Fault$N*  Operation in Hand, Maintenance, Override, Program and Operator Modes$N*  $QAvailable$Q status for use by automation logic to know whether drive$N      can be controlled by other objects.$N*  Horn output for audible alert prior to starting motor.$N$NCommand Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$NCommand Sources: Operator, External, Program, Override, Maintenance, Out of$NService, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* Corrected handling of Start Horn on shed conditions.$N* Modified to lock out jog when jog time expires until jog commands are cleared$N* Modified to handle overlapping Horn and Jog times.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.02)$NSee 4.10 Release Notes for details.$N* Changed availability to use input availability from interlocks.$N* Added Horn Status, Horn Inhibit.$N* Updated to P_CmdSrc V4.10.00.$N* Modified simulated run feedback to handle run at zero speed ref.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.00 Release Notes for details.$N* Corrected handling Allow Local when horn is enabled.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-11)$NSee 4.00 Release Notes for details.$N* Changed $QMode$Q to $QCommand Source$Q.$N* Added audible alert on commanded start.  Added unacked alarm count.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Changed Start / Stop / Fwd / Rev / Jog to StartFwd / StartRev /Stop / JogFwd / JogRev.$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N* Aligned ready bit naming with command bit names.$N* Added configurable decimal places for display on HMI.$N* Modifications to Output Datalink clamp limit restrictions / checking.$N* Changed delay / time configuration items to REAL seconds.$N* Updated Val_Sts to common enumeration across all motors and drives.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Ref_FaultCodeList : P_DescList[1] (Description := "Tag containing List of Fault Codes (DINT) and their Descriptions (STRING)",
			                             Usage := InOut,
			                             Required := Yes,
			                             Visible := Yes);
			Inp_SpeedFdbk : REAL (Description := "Speed Feedbak in Drive Units (typ. 0-32767 = 0 to max freq.)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 0.00000000e+000);
			Inp_LastFaultCode : DINT (Description := "Most recent drive fault code (enumeration)",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := Yes,
			                             DefaultData := 0);
			Inp_Datalink : REAL (Description := "Auxiliary Signal (datalink) Input in Drive (raw) Units",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Inp_Ready : BOOL (Description := "1=Drive is ready to run",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 1);
			Inp_Running : BOOL (Description := "1=Drive is Running (active)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Inp_CommandDir : BOOL (Description := "1=Drive is commanded Forward, 0=Drive is commanded Reverse",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          DefaultData := 1);
			Inp_ActualDir : BOOL (Description := "1=Drive is running Forward, 0=Drive is running Reverse",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_Accelerating : BOOL (Description := "1=Drive is accelerating",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            DefaultData := 0);
			Inp_Decelerating : BOOL (Description := "1=Drive is decelerating",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            DefaultData := 0);
			Inp_Alarm : BOOL (Description := "1=Drive has an Alarm Condition (see drive display or manual)",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Inp_Faulted : BOOL (Description := "1=Drive has Faulted (see drive display or manual)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Inp_AtSpeed : BOOL (Description := "1=Drive is at commanded speed",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Inp_FwdPermOK : BOOL (Description := "1=Permissives OK, drive can start Forward",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_FwdNBPermOK : BOOL (Description := "1=Non-Bypassable Permissives OK, drive can start Forward",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           DefaultData := 1);
			Inp_RevPermOK : BOOL (Description := "1=Permissives OK, drive can start Reverse",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_RevNBPermOK : BOOL (Description := "1=Non-Bypassable Permissives OK, motor can start Reverse",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           DefaultData := 1);
			Inp_IntlkOK : BOOL (Description := "1=Interlocks OK, drive can start/run",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBIntlkOK : BOOL (Description := "1=Non-Bypassable Interlocks OK, drive can start/run",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkAvail : BOOL (Description := "1 = Interlock Availibility OK",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Inp_IOFault : BOOL (Description := "Input Communication Status 0=OK, 1=fail",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=Simulate working drive; 0=Start/Stop/ Monitor actual drive",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Hand OF CmdSrc.Inp_Hand (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_Ovrd OF CmdSrc.Inp_Ovrd (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_OvrdCmd : DINT (Description := "Override Command: 0=None, 1=Stop, 2=Start Fwd 3=Start Rev",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_OvrdSpeed : REAL (Description := "Value to set Speed Reference in Override Mode (SpeedRef EU)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			Inp_OvrdOutDatalink : REAL (Description := "Value to set Output Datalink in Override Mode (OutDatalink EU)",
			                               Usage := Input,
			                               RADIX := Float,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 0.00000000e+000);
			Inp_ExtInh OF CmdSrc.Inp_ExtInh (Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_HornInh : BOOL (Description := "1 = Inhibit audible alert, 0 = Alllow audible alert",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Reset : BOOL (Description := "1=Reset Shed Latches and Cleared Alarms",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_HasReverse : BOOL (Description := "1=Drive can be run reverse, 0=Forward only",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasJog : BOOL (Description := "1=Drive Jog Command enabled/visible, 0=Drive Jog Command not allowed",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Cfg_AllowLocal : BOOL (Description := "1=Allow Local Start/Stop without alarm, 0=Start/Stop from HMI/prog only",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasRunFdbk : BOOL (Description := "1=Drive provides feedback signal on Inp_Running when running",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_UseRunFdbk : BOOL (Description := "1=Drive run feedback should be used for failure checking",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasSpeedFdbk : BOOL (Description := "1=Drive provides speed feedback on Inp_SpeedFdbk",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_UseSpeedFdbk : BOOL (Description := "1=Drive speed determines running state, 0=state determined by drive Active input bit",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 1);
			Cfg_HasInpDatalink : BOOL (Description := "1=A signal is connected to Inp_Datalink",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 0);
			Cfg_HasOutDatalink : BOOL (Description := "1=A signal is connected to Out_Datalink",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 0);
			Cfg_HasFwdPermObj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_FwdPerm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_HasRevPermObj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_RevPerm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_HasIntlkObj : BOOL (Description := "1=Tells HMI a P_Intlk is connected to Inp_Intlk",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasResInhObj : BOOL (Description := "1=Tells HMI a P_ResInh Restart Inhibit is connected",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_HasRunTimeObj : BOOL (Description := "1=Tells HMI a P_RunTime is connected",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_SetTrack : BOOL (Description := "1=Settings track for unselected sources, 0=no tracking",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1);
			Cfg_SetTrackOvrdHand : BOOL (Description := "1=Prog/Oper/Ext Settings track Override/Hand",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 0);
			Cfg_OperStopPrio : BOOL (Description := "1=OCmd_Stop any time, 0=OCmd_Stop only when Oper selected",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_ExtStopPrio : BOOL (Description := "1=XCmd_Stop any time, 0=XCmd_Stop only when Ext selected",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_OCmdResets : BOOL (Description := "1=New drive OCmd resets shed latches and cleared alarms, 0=OCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_XCmdResets : BOOL (Description := "1=New drive XCmd resets shed latches and cleared alarms, 0=XCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OvrdPermIntlk : BOOL (Description := "1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_ShedOnFailToStart : BOOL (Description := "1=Stop Motor and Alarm on Fail to Start; 0=Alarm only on Fail to Start",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 1);
			Cfg_ShedOnIOFault : BOOL (Description := "1=Stop Motor and Alarm on I/O Fault; 0=Alarm only on I/O Fault",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_SimScaleEU : BOOL (Description := "1=In simulation, scale Speed Ref EU to Speed Fdbk EU",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_SimScaleRaw : BOOL (Description := "1=In simulation, scale Speed Ref EU to raw, then raw to Speed Fdbk EU",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_DecPlcs : DINT (Description := "Number of decimal places for speed ref/fdbk display (0..6)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 2);
			Cfg_InpDLDecPlcs : DINT (Description := "Number of decimal places for Input Datalink display (0..6)",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 2);
			Cfg_OutDLDecPlcs : DINT (Description := "Number of decimal places for Output Datalink display (0..6)",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 2);
			Cfg_HasFailToStartAlm OF FailToStart.Cfg_Exists (Description := "1=Fail to Start Alarm exists and will be checked",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_HasFailToStopAlm OF FailToStop.Cfg_Exists (Description := "1=Fail to Stop Alarm exists and will be checked",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_HasIntlkTripAlm OF IntlkTrip.Cfg_Exists (Description := "1=Interlock Trip Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasDriveFaultAlm OF DriveFault.Cfg_Exists (Description := "1=Drive Fault alarm exists and will be checked",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=I/O Fault Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_FailToStartResetReqd OF FailToStart.Cfg_ResetReqd (Description := "1=Reset requied to clear Fail to Start Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			Cfg_FailToStopResetReqd OF FailToStop.Cfg_ResetReqd (Description := "1=Reset required to clear Fail to Stop Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_IntlkTripResetReqd OF IntlkTrip.Cfg_ResetReqd (Description := "1=Reset required to clear Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_DriveFaultResetReqd OF DriveFault.Cfg_ResetReqd (Description := "1=Reset required to clear Drive Fault Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Reset required to clear I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_FailToStartAckReqd OF FailToStart.Cfg_AckReqd (Description := "1=Acknowledge required for Fail to Start Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_FailToStopAckReqd OF FailToStop.Cfg_AckReqd (Description := "1=Acknowledge required for Fail to Stop Alarm",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_IntlkTripAckReqd OF IntlkTrip.Cfg_AckReqd (Description := "1=Acknowledge required for Interlock Trip Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_DriveFaultAckReqd OF DriveFault.Cfg_AckReqd (Description := "1=Acknowledge required for Drive Fault Alarm",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Acknowledge required for I/O Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_FailToStartSeverity OF FailToStart.Cfg_Severity (Description := "Fail To Start Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_FailToStopSeverity OF FailToStop.Cfg_Severity (Description := "Fail To Stop Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IntlkTripSeverity OF IntlkTrip.Cfg_Severity (Description := "Interlock Trip Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_DriveFaultSeverity OF DriveFault.Cfg_Severity (Description := "Drive Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "I/O Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_MinSpdRef : REAL (Description := "Minimum Speed Reference in EU (for limiting)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			Cfg_MaxSpdRef : REAL (Description := "Maximum Speed Reference in EU (for limiting)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 6.00000000e+001);
			Cfg_SpeedRefRawMin : REAL (Description := "Speed Reference Minimum in Drive (raw) Units (for scaling)",
			                              Usage := Input,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 0.00000000e+000);
			Cfg_SpeedRefRawMax : REAL (Description := "Speed Reference Maximum in Drive (raw) Units (for scaling)",
			                              Usage := Input,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 3.27670000e+004);
			Cfg_SpeedRefEUMin : REAL (Description := "Speed Reference Minimum in Engineering Units (for scaling)",
			                             Usage := Input,
			                             RADIX := Float,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0.00000000e+000);
			Cfg_SpeedRefEUMax : REAL (Description := "Speed Reference Maximum in Engineering Units (for scaling)",
			                             Usage := Input,
			                             RADIX := Float,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1.30000000e+002);
			Cfg_SpeedFdbkRawMin : REAL (Description := "Speed Feedback Minimum in Drive (raw) Units (for scaling)",
			                               Usage := Input,
			                               RADIX := Float,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 0.00000000e+000);
			Cfg_SpeedFdbkRawMax : REAL (Description := "Speed Feedback Maximum in Drive (raw) Units (for scaling)",
			                               Usage := Input,
			                               RADIX := Float,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 3.27670000e+004);
			Cfg_SpeedFdbkEUMin : REAL (Description := "Speed Feedback Minimum in Engineering Units (for scaling)",
			                              Usage := Input,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 0.00000000e+000);
			Cfg_SpeedFdbkEUMax : REAL (Description := "Speed Feedback Maximum in Engineering Units (for scaling)",
			                              Usage := Input,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 1.30000000e+002);
			Cfg_InpDatalinkRawMin : REAL (Description := "Input Datalink Minimum in Drive (raw) Units (for scaling)",
			                                 Usage := Input,
			                                 RADIX := Float,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 0.00000000e+000);
			Cfg_InpDatalinkRawMax : REAL (Description := "Input Datalink Maximum in Drive (raw) Units (for scaling)",
			                                 Usage := Input,
			                                 RADIX := Float,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 4.09500000e+003);
			Cfg_InpDatalinkEUMin : REAL (Description := "Input Datalink Minimum in Engineering Units (for scaling)",
			                                Usage := Input,
			                                RADIX := Float,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 0.00000000e+000);
			Cfg_InpDatalinkEUMax : REAL (Description := "Input Datalink Maximum in Engineering Units (for scaling)",
			                                Usage := Input,
			                                RADIX := Float,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 4.09500000e+002);
			Cfg_OutDatalinkMin : REAL (Description := "Minimum Output Datalink in EU (for limiting)",
			                              Usage := Input,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 0.00000000e+000);
			Cfg_OutDatalinkMax : REAL (Description := "Maximum Output Datalink in EU (for limiting)",
			                              Usage := Input,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              DefaultData := 1.00000000e+002);
			Cfg_OutDatalinkRawMin : REAL (Description := "Output Datalink Minimum in Drive (raw) Units (for scaling)",
			                                 Usage := Input,
			                                 RADIX := Float,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 0.00000000e+000);
			Cfg_OutDatalinkRawMax : REAL (Description := "Output Datalink Maximum in Drive (raw) Units (for scaling)",
			                                 Usage := Input,
			                                 RADIX := Float,
			                                 Required := No,
			                                 Visible := No,
			                                 DefaultData := 4.09500000e+003);
			Cfg_OutDatalinkEUMin : REAL (Description := "Output Datalink Minimum in Engineering Units (for scaling)",
			                                Usage := Input,
			                                RADIX := Float,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 0.00000000e+000);
			Cfg_OutDatalinkEUMax : REAL (Description := "Output Datalink Maximum in Engineering Units (for scaling)",
			                                Usage := Input,
			                                RADIX := Float,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 4.09500000e+002);
			Cfg_StartHornT : REAL (Description := "Time to sound audible on commanded start (sec) (0=disabled)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_SimRampT : REAL (Description := "Time to ramp speed fdbk when in Simulation (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+001);
			Cfg_FailToStartT : REAL (Description := "Time after Start to get Run Feedback before Fault (sec)",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 1.50000000e+001);
			Cfg_FailToStopT : REAL (Description := "Time after Stop to drop Run Feedback before Fault (sec)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 1.50000000e+001);
			Cfg_ResetPulseT : REAL (Description := "Time to pulse Out_Reset to clear drive fault",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 2.00000000e+000);
			Cfg_MaxJogT : REAL (Description := "Maximum jog time (sec, 0=unlimited)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_OperKeep : SINT (Description := "Oper keeps control in Prog / Ext: .0=Reference, .1=Start/Stop/Fwd/ Rev, .3=OutDatalink",
			                        Usage := Input,
			                        RADIX := Binary,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_ProgKeep : SINT (Description := "Prog keeps control in Oper / Ext: .0=Reference, .1=Start/Stop/Fwd/ Rev, .3=OutDatalink",
			                        Usage := Input,
			                        RADIX := Binary,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_ExtKeep : SINT (Description := "Ext keeps control in Prog / Oper: .0=Reference, .1=Start/Stop/Fwd/ Rev, .3=OutDatalink",
			                       Usage := Input,
			                       RADIX := Binary,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			PSet_SpeedRef : REAL (Description := "Program Setting of Speed Reference (EU)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			PSet_OutDatalink : REAL (Description := "Program Setting of Output Datalink (EU)",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0.00000000e+000);
			PSet_Owner : DINT (Description := "Program Owner Request ID (non-zero) or Release (zero)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			XSet_SpeedRef : REAL (Description := "External Setting of Speed Reference (EU)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0.00000000e+000);
			XSet_OutDatalink : REAL (Description := "External Setting of Output Datalink (EU)",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0.00000000e+000);
			PCmd_StartFwd : BOOL (Description := "Program Command to Start Drive Forward",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			PCmd_StartRev : BOOL (Description := "Program Command to Start Drive Reverse",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			PCmd_Stop : BOOL (Description := "Program Command to Stop Drive",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			PCmd_Prog OF CmdSrc.PCmd_Prog (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Oper OF CmdSrc.PCmd_Oper (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Lock OF CmdSrc.PCmd_Lock (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Unlock OF CmdSrc.PCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Normal OF CmdSrc.PCmd_Normal (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Reset : BOOL (Description := "Program Command to Reset drive fault and all Alarms requiring Reset",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_FailToStartAck OF FailToStart.PCmd_Ack (Description := "Program Command to Acknowledge Fail to Start Alarm",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			PCmd_FailToStartSuppress OF FailToStart.PCmd_Suppress (Description := "Program Command to Suppress Fail to Start Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_FailToStartUnsuppress OF FailToStart.PCmd_Unsuppress (Description := "Program Command to Unsuppress Fail to Start Alarm",
			                                      Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No);
			PCmd_FailToStartUnshelve OF FailToStart.PCmd_Unshelve (Description := "Program Command to Unshelve Fail to Start Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_FailToStopAck OF FailToStop.PCmd_Ack (Description := "Program Command to Acknowledge Fail to Stop Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_FailToStopSuppress OF FailToStop.PCmd_Suppress (Description := "Program Command to Suppress Fail to Stop Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			PCmd_FailToStopUnsuppress OF FailToStop.PCmd_Unsuppress (Description := "Program Command to Unsuppress Fail to Stop Alarm",
			                                     Usage := Input,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No);
			PCmd_FailToStopUnshelve OF FailToStop.PCmd_Unshelve (Description := "Program Command to Unshelve Fail to Stop Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			PCmd_IntlkTripAck OF IntlkTrip.PCmd_Ack (Description := "Program Command to Acknowledge Interlock Trip Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_IntlkTripSuppress OF IntlkTrip.PCmd_Suppress (Description := "Program Command to Suppress Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IntlkTripUnsuppress OF IntlkTrip.PCmd_Unsuppress (Description := "Program Command to Unsuppress Interlock Trip Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripUnshelve OF IntlkTrip.PCmd_Unshelve (Description := "Program Command to Unshelve Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_DriveFaultAck OF DriveFault.PCmd_Ack (Description := "Program Command to Acknowledge Drive Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			PCmd_DriveFaultSuppress OF DriveFault.PCmd_Suppress (Description := "Program Command to Suppress Drive Fault Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			PCmd_DriveFaultUnsuppress OF DriveFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress Drive Fault Alarm",
			                                     Usage := Input,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No);
			PCmd_DriveFaultUnshelve OF DriveFault.PCmd_Unshelve (Description := "Program Command to Unshelve Drive Fault Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			MCmd_Rel OF CmdSrc.MCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			OCmd_Unlock OF CmdSrc.OCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			XCmd_StartFwd : BOOL (Description := "External Command to Start Drive Forward",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			XCmd_StartRev : BOOL (Description := "External Command to Start Drive Reverse",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			XCmd_Stop : BOOL (Description := "External Command to Stop Drive",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			XCmd_JogFwd : BOOL (Description := "External Command to Jog Drive Forward",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			XCmd_JogRev : BOOL (Description := "External Command to Jog Drive Reverse",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			XCmd_Acq OF CmdSrc.XCmd_Acq (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Rel OF CmdSrc.XCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Reset : BOOL (Description := "Ext Cmd to clear shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Out_SpeedRef : REAL (Description := "Drive Speed Reference in Drive Units (typ. 0-32767 = 0 to max freq.)",
			                        Usage := Output,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0.00000000e+000);
			Out_Datalink : REAL (Description := "Auxiliary Signal (datalink) Output in Drive (raw) Units",
			                        Usage := Output,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0.00000000e+000);
			Out_Run : BOOL (Description := "1=Start/Run Drive, 0=Stop Drive (for held starter type)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Out_Stop : BOOL (Description := "1=Stop Drive, 0=drive left in current state",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Out_Start : BOOL (Description := "1=Start Drive, 0=drive left in current state",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Out_Jog : BOOL (Description := "1=Jog drive at Jog Speed, -->0=stop jogging",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Out_ClearFault : BOOL (Description := "1=Attempt to clear Drive Fault",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Out_Fwd : BOOL (Description := "1=Set drive direction to Forward",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Out_Rev : BOOL (Description := "1=Set drive direction to Reverse",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Out_Horn : BOOL (Description := "1=Sound audible prior to commanded motor start",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Val_SpeedRef : REAL (Description := "Speed Reference (target) to drive",
			                        Usage := Output,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0.00000000e+000);
			Val_SpeedFdbk : REAL (Description := "Speed Feedback (actual) from drive",
			                         Usage := Output,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0.00000000e+000);
			Val_InpDatalink : REAL (Description := "Input Datalink value from drive",
			                           Usage := Output,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0.00000000e+000);
			Val_OutDatalink : REAL (Description := "Output Datalink value to drive",
			                           Usage := Output,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0.00000000e+000);
			Val_SpeedRefEUMin : REAL (Description := "Minimum of Speed Reference = MIN (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)",
			                             Usage := Output,
			                             RADIX := Float,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0.00000000e+000);
			Val_SpeedRefEUMax : REAL (Description := "Maximum of Speed Reference = MAX (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)",
			                             Usage := Output,
			                             RADIX := Float,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read Only,
			                             DefaultData := 1.30000000e+002);
			Val_SpeedFdbkEUMin : REAL (Description := "Minimum of Speed Feedback = MIN (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)",
			                              Usage := Output,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read Only,
			                              DefaultData := 0.00000000e+000);
			Val_SpeedFdbkEUMax : REAL (Description := "Maximum of Speed Feedback = MAX (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)",
			                              Usage := Output,
			                              RADIX := Float,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read Only,
			                              DefaultData := 1.30000000e+002);
			Val_LastFaultCode : DINT (Description := "Most recent drive fault code (enumeration)",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read Only,
			                             DefaultData := 0);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Cmd : DINT (Description := "Device Command 0=None, 1=Stop, 2=StartFwd 3=StartRev 4=JogFwd 5=JogRev",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fdbk : DINT (Description := "Device Feedback 0=Stopped, 1=Running Fwd 2=Running Rev 3=Accelerating 4=Decelerating",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Val_Sts : DINT (Description := "Device Sts: 0=? 1=Stopped 2=RunFwd 3=RunRev 4=RunSlow 5=StartFwd 6=StartRev 7=StartSlow 8=JogFwd 9=JogRev 10=Stopping",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=None, 16=Fail to Start, 17 = Fail to Stop, 18=Drive Fault, 32=I/O Fault, 34=Config Error",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + channel (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_Owner : DINT (Description := "Current Object Owner ID (0=not owned)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Stopped : BOOL (Description := "1=Drive requested to stop and is confirmed stopped",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_StartingFwd : BOOL (Description := "1=Drive requested to run forward and awaiting run feedback",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Sts_StartingRev : BOOL (Description := "1=Drive requested to run reverse and awaiting run feedback",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Sts_RunningFwd : BOOL (Description := "1=Drive requested to run and is confirmed running forward",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_RunningRev : BOOL (Description := "1=Drive requested to run and is confirmed running reverse",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_StoppingFwd : BOOL (Description := "1=Drive running forward requested to stop and awaiting stopped feedback",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Sts_StoppingRev : BOOL (Description := "1=Drive running reverse requested to stop and awaiting stopped feedback",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Sts_JoggingFwd : BOOL (Description := "1=Drive requested to Jog Forward",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_JoggingRev : BOOL (Description := "1=Drive requested to Jog Reverse",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_Horn : BOOL (Description := "1=Motor Horn Active",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_CommandDir : BOOL (Description := "1=Drive commanded to Forward, 0=Reverse",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_ActualDir : BOOL (Description := "1=Drive Actual direction is Forward, 0=Reverse",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Accel : BOOL (Description := "1=Drive is Accelerating",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Decel : BOOL (Description := "1=Drive is Decelerating",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_NotReady : BOOL (Description := "1=Drive is Not Ready (cannot be started)$NCheck alarms, stops, faults",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_Alarm : BOOL (Description := "1=Drive has an Alarm (see drive display or manual)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_AtSpeed : BOOL (Description := "1=Drive is running at reference speed",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_SpeedLimited : BOOL (Description := "1=Speed Reference Setting exceeds configured Max/Min limit",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Sts_Available : BOOL (Description := "1=Drive available for control by automation (Prog)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Bypass : BOOL (Description := "1=Bypassable Interlocks and Permissives are Bypassed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_BypActive : BOOL (Description := "1=Bypassing Active (Bypassed or Maintenance)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_NotRdy : BOOL (Description := "1=Device Not Ready, see detail bits for reason",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_CfgErr : BOOL (Description := "1=Device Not Ready: Configuration Error",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Nrdy_DriveNR : BOOL (Description := "1=Device Note Ready: Drive Not Ready",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_Fail : BOOL (Description := "1=Device Not Ready: Device Failure (Shed Requires Reset)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Nrdy_Intlk : BOOL (Description := "1=Device Not Ready: Interlock Not OK",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_IOFault : BOOL (Description := "1=Device Not Ready: I/O Fault (Shed Requires Reset)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_OoS : BOOL (Description := "1=Device Not Ready: Device is Out of Service",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Nrdy_Perm : BOOL (Description := "1=Device Not Ready: Permissive Not OK",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Nrdy_PrioStop : BOOL (Description := "1=Device Not Ready: Oper/Ext Priority Stop Requires Reset",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Nrdy_Trip : BOOL (Description := "1=Device not Ready: Deivce Tripped (Drive Fault)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=A Maintenance Bypass is Active, display icon",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=An Alarm is Shelved, Disabled or Suppressed, display icon",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Invalid Check or Reset Pulse Time (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Sim : BOOL (Description := "1=Error in Config: simulation timer preset: use 0 to 2147483)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_FdbkRaw : BOOL (Description := "1=Erron in Config: Speed Fdbk Raw Min = Max",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Err_FdbkEU : BOOL (Description := "1=Error in Config: Speed Fdbk EU Min = Max",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Err_RefLim : BOOL (Description := "1=Error in Config: Speed Ref Limit Min > Max",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Err_RefEU : BOOL (Description := "1=Error in Config: Speed Ref EU Min = Max",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_RefRaw : BOOL (Description := "1=Error in Config: Speed Ref Raw Min = Max",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Err_InpDLRaw : BOOL (Description := "1=Error in Config: Input Datalink Raw Min = Max",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Err_InpDLEU : BOOL (Description := "1=Error in Config: Input Datalink EU Min = Max",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Err_OutDLLim : BOOL (Description := "1=Error in Config: Output Datalink Limits Min > Max",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Err_OutDLEU : BOOL (Description := "1=Error in Config: Output Datalink EU Min = Max",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Err_OutDLRaw : BOOL (Description := "1=Error in Config: Output Datalink Raw Min = Max",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_Hand OF CmdSrc.Sts_Hand (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OoS OF CmdSrc.Sts_OoS (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Maint OF CmdSrc.Sts_Maint (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only);
			Sts_Ovrd OF CmdSrc.Sts_Ovrd (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_Ext OF CmdSrc.Sts_Ext (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Prog OF CmdSrc.Sts_Prog (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_ProgLocked OF CmdSrc.Sts_ProgLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Oper OF CmdSrc.Sts_Oper (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OperLocked OF CmdSrc.Sts_OperLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Normal OF CmdSrc.Sts_Normal (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_ExtReqInh OF CmdSrc.Sts_ExtReqInh (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_ProgReqInh OF CmdSrc.Sts_ProgReqInh (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_MAcqRcvd OF CmdSrc.Sts_MAcqRcvd (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_FailToStart OF FailToStart.Inp (Description := "1=Drive Failed to Start (One-Shot)",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Alm_FailToStart OF FailToStart.Alm (Description := "1=Drive Fail to Start Alarm",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Ack_FailToStart OF FailToStart.Ack (Description := "1=Fail to Start Alarm has been acknowledged",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read/Write);
			Sts_FailToStartDisabled OF FailToStart.Disabled (Description := "1=Fail to Start Alarm has been Disabled by Maintenance",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_FailToStartShelved OF FailToStart.Shelved (Description := "1=Fail to Start Alarm has been Shelved by Operator",
			                                  Usage := Output,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No,
			                                  ExternalAccess := Read/Write);
			Sts_FailToStartSuppressed OF FailToStart.Suppressed (Description := "1=Fail to Start Alarm has been Suppressed by Program",
			                                     Usage := Output,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No,
			                                     ExternalAccess := Read/Write);
			Sts_FailToStop OF FailToStop.Inp (Description := "1=Drive Failed to Stop",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Alm_FailToStop OF FailToStop.Alm (Description := "1=Drive Fail to Stop Alarm",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Ack_FailToStop OF FailToStop.Ack (Description := "1=Fail to Stop Alarm has been acknowledged",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Sts_FailToStopDisabled OF FailToStop.Disabled (Description := "1=Fail to Stop Alarm has been Disabled by Maintenance",
			                                  Usage := Output,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No,
			                                  ExternalAccess := Read/Write);
			Sts_FailToStopShelved OF FailToStop.Shelved (Description := "1=Fail to Stop Alarm has been Shelved by Operator",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_FailToStopSuppressed OF FailToStop.Suppressed (Description := "1=Fail to Stop Alarm has been Suppressed by Program",
			                                    Usage := Output,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No,
			                                    ExternalAccess := Read/Write);
			Sts_IntlkTrip OF IntlkTrip.Inp (Description := "1=Drive was stopped by an Interlock NOT OK (One-Shot)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_IntlkTrip OF IntlkTrip.Alm (Description := "1=Alarm: Drive stopped by an Interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_IntlkTrip OF IntlkTrip.Ack (Description := "1=Interlock Trip Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_IntlkTripDisabled OF IntlkTrip.Disabled (Description := "1=Interlock Trip Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTripShelved OF IntlkTrip.Shelved (Description := "1=Interlock Trip Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_IntlkTripSuppressed OF IntlkTrip.Suppressed (Description := "1=Interlock Trip Alarm has been Suppressed by Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_DriveFault OF DriveFault.Inp (Description := "1=Drive Fault (see drive display or manual)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Alm_DriveFault OF DriveFault.Alm (Description := "1=Alarm: Drive Fault (see drive display or manual)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Ack_DriveFault OF DriveFault.Ack (Description := "1=Drive Fault Alarm has been acknowledged",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read/Write);
			Sts_DriveFaultDisabled OF DriveFault.Disabled (Description := "1=Drive Fault Alarm has been Disabled by Maintenance",
			                                  Usage := Output,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No,
			                                  ExternalAccess := Read/Write);
			Sts_DriveFaultShelved OF DriveFault.Shelved (Description := "1=Drive Fault Alarm has been Shelved by Operator",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_DriveFaultSuppressed OF DriveFault.Suppressed (Description := "1=Drive Fault Alarm has been Suppressed by Program",
			                                    Usage := Output,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No,
			                                    ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "I/O Comm Fault Status (0=OK, 1=Bad)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=I/O Fault Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			MRdy_Rel OF CmdSrc.MRdy_Rel (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			ORdy_Unlock OF CmdSrc.ORdy_Unlock (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only);
			P_VSD : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                 Usage := Output,
			                 RADIX := Decimal,
			                 Required := No,
			                 Visible := No,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			CmdSrc : P_CmdSrc (Description := "Drive Mode Selection",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[7649,0,0,1,0,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']]");
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			IntlkTrip : P_Alarm (Description := "Interlock Trip Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			FailToStop : P_Alarm (Description := "Drive Failed to Stop Alarm",
			                     ExternalAccess := Read/Write,
			                     DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Failed to Stop$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			FailToStart : P_Alarm (Description := "Drive Failed to Start Alarm",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Failed to Start$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[19,'Motor Speed Control$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_Run : BOOL (Description := "1=Drive should be $Qrunning$Q, 0=should be $Qstopped$Q",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_StartRetrigT : TIMER (Description := "Time to pulse start output on start command retrigger (Maint)",
			                           ExternalAccess := None,
			                           DefaultData := "[0,0,0]");
			Wrk_StopRetrigT : TIMER (Description := "Time to pulse stop output on stop command retrigger (Maint)",
			                          ExternalAccess := None,
			                          DefaultData := "[0,0,0]");
			Wrk_RunFdbk : BOOL (Description := "Run Feedback based on mode, simulation, etc. 1=running",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Bypass : BOOL (Description := "Internal Bypassable Permissives and Interlocks are Bypassed flag",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			DriveFault : P_Alarm (Description := "Drive Faulted Alarm",
			                     ExternalAccess := Read/Write,
			                     DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_SpeedRefEU : STRING_8 (Description := "Speed Reference Engineering Units for display on HMI",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[2,'Hz$00$00$00$00$00$00']");
			Wrk_SpeedRef : REAL (Description := "Working copy of Speed Reference (for limiting)",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_Rev : BOOL (Description := "Working (internal) Direction 1=Reverse 0=Forward (default)",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Jog : BOOL (Description := "1=Jog Drive, 0=Drive not jogging",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_ResetT : TIMER (Description := "Reset Output Pulse Timer",
			                     ExternalAccess := None,
			                     DefaultData := "[0,0,0]");
			Wrk_ResetONS : BOOL (Description := "One-Shot to fire Reset Timer to ensure min. output ON time.",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Cfg_SpeedFdbkEU : STRING_8 (Description := "Speed Feedback Engineering Units for display on HMI",
			                          ExternalAccess := Read/Write,
			                          DefaultData := "[2,'Hz$00$00$00$00$00$00']");
			Cfg_OutDatalinkLabel : STRING_20 (Description := "Datalink Output Label displayed on faceplate",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_InpDatalinkLabel : STRING_20 (Description := "Datalink Input Label displayed on faceplate",
			                               ExternalAccess := Read/Write,
			                               DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_OutDatalinkEU : STRING_8 (Description := "Datalink Output Engineering Units for display on HMI",
			                            ExternalAccess := Read/Write,
			                            DefaultData := "[0,'$00$00$00$00$00$00$00$00']");
			Cfg_InpDatalinkEU : STRING_8 (Description := "Datalink Input Engineering Units for display on HMI",
			                            ExternalAccess := Read/Write,
			                            DefaultData := "[0,'$00$00$00$00$00$00$00$00']");
			Wrk_OutDatalink : REAL (Description := "Selected Output Datalink setting",
			                          RADIX := Float,
			                          ExternalAccess := None,
			                          DefaultData := 0.00000000e+000);
			Cfg_RevText : STRING_16 (Description := "Name for Reverse Direction, e.g., $QDown$Q, $QReverse$Q",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[7,'Reverse$00$00$00$00$00$00$00$00$00']");
			Cfg_FwdText : STRING_16 (Description := "Name for Forward Direction, e.g., $QUp$Q, $QForward$Q",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[7,'Forward$00$00$00$00$00$00$00$00$00']");
			Wrk_StopT : TIMER (Description := "Stop Check Timer (for Fail to Stop)",
			                    ExternalAccess := Read Only,
			                    DefaultData := "[0,0,0]");
			Wrk_StartT : TIMER (Description := "Start Check Timer (for Fail to Start)",
			                     ExternalAccess := Read Only,
			                     DefaultData := "[0,0,0]");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_Cmd : DINT (Description := "Buffer for building Val_Cmd",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Sts : DINT (Description := "Buffer for building Val_Sts",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_Retrigger : BOOL (Description := "Maint Start issued while running or Stop while stopped",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_Step : REAL (Description := "Amount to change simulated Speed Fdbk this scan (ramp)",
			                   RADIX := Float,
			                   ExternalAccess := None,
			                   DefaultData := 0.00000000e+000);
			Wrk_ScanTime : REAL (Description := "Seconds since previous scan",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_ScanT : TIMER (Description := "Scan Timer (milliseconds, always runs)",
			                    ExternalAccess := None,
			                    DefaultData := "[0,2147483647,0]");
			Wrk_SimFdbkTgt : REAL (Description := "Speed Ref converted to Speed Fdbk units for simulation: target speed fdbk",
			                         RADIX := Float,
			                         ExternalAccess := None,
			                         DefaultData := 0.00000000e+000);
			HMI_Type : STRING_16 (Description := "Type identifier for HMI navigation",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_JogT : TIMER (Description := "Jog Timer",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[0,0,0]");
			Wrk_FaultDescFSC : CONTROL (Description := "FSC control for Fault Code List search",
			                           ExternalAccess := None,
			                           DefaultData := "[0,1,0]");
			Val_FaultDesc : STRING_40 (Description := "Description of Drive Fault (given LastFaultCode)",
			                        ExternalAccess := Read Only,
			                        DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_OperKeep3ONS : BOOL (Description := "Oper Keep bit 3 one-shot store",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_OperKeep1ONS : BOOL (Description := "Oper Keep bit 1 one-shot store",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_OperKeep0ONS : BOOL (Description := "Oper Keep bit 0 one-shot store",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_ProgKeep3ONS : BOOL (Description := "Prog Keep bit 3 one-shot store",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_ProgKeep1ONS : BOOL (Description := "Prog Keep bit 1 one-shot store",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_ProgKeep0ONS : BOOL (Description := "Prog Keep bit 0 one-shot store",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Wrk_SimScaleEUONS : BOOL (Description := "Cfg_SimScaleEU became true this scan",
			                            RADIX := Decimal,
			                            ExternalAccess := None,
			                            DefaultData := 0);
			Wrk_SimScaleRawONS : BOOL (Description := "Cfg_SimScaleRaw became true this scan",
			                             RADIX := Decimal,
			                             ExternalAccess := None,
			                             DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Val_Notify : DINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wrk_NotRdyONS : BOOL (Description := "Assert Stop on One-Shot of Sts_NotRdy",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_NotRdy : BOOL (Description := "Device Not Ready conditions excluding shed latches",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_StartInhT : TIMER (Description := "Local Start Inhibit Timer",
			                        ExternalAccess := None,
			                        DefaultData := "[0,0,0]");
			Wrk_StopInhT : TIMER (Description := "Local Stop Inhibit Timer",
			                       ExternalAccess := None,
			                       DefaultData := "[0,0,0]");
			Wrk_NoLongerSim : BOOL (Description := "Switched from Simulated to Real Drive this scan",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_Hand : BOOL (Description := "Perform Hand Mode alignment with actual device state",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_StartHornT : TIMER (Description := "Timer for audible alert or start",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_StartHorn : BOOL (Description := "1=Sound audible prior to commanded motor start",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_RevPermOK : BOOL (Description := "Reverse Permissives and NB Permissive OK",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_FwdPermOK : BOOL (Description := "Forward Permissives and NB Permissive OK",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			OCmd_ResetAckAll : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms, plus  Acknowledge alarms",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Oper Cmd to clear shed latches and cleared alarms",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			OCmd_JogRev : BOOL (Description := "Operator Command to Jog Drive Reverse (not cleared by instruction!)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			OCmd_JogFwd : BOOL (Description := "Operator Command to Jog Drive Forward (not cleared by instruction!)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			OCmd_StartRev : BOOL (Description := "Operator Command to Start Drive Reverse",
			                        RADIX := Decimal,
			                        ExternalAccess := Read/Write,
			                        DefaultData := 0);
			OCmd_StartFwd : BOOL (Description := "Operator Command to Start Drive Forward",
			                        RADIX := Decimal,
			                        ExternalAccess := Read/Write,
			                        DefaultData := 0);
			MCmd_Check : BOOL (Description := "Maintenance Command to Check (not bypass) all Interlocks and Permissives",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Bypass : BOOL (Description := "Maintenance Command to Bypass all Bypassable Interlocks and Permissives",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			OSet_OutDatalink : REAL (Description := "Operator Setting of Output Datalink (EU)",
			                           RADIX := Float,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0.00000000e+000);
			OSet_SpeedRef : REAL (Description := "Operator Setting of Speed Reference (EU)",
			                        RADIX := Float,
			                        ExternalAccess := Read/Write,
			                        DefaultData := 0.00000000e+000);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_JogRev : BOOL (Description := "1=Ready for OCmd_JogRev (enabled HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			ORdy_JogFwd : BOOL (Description := "1=Ready for OCmd_JogFwd (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			ORdy_Stop : BOOL (Description := "1=Ready for OCmd_Stop (enables HMI button)",
			                    RADIX := Decimal,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			ORdy_StartRev : BOOL (Description := "1=Ready for OCmd_StartRev (enables HMI button)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			ORdy_StartFwd : BOOL (Description := "1=Ready for OCmd_StartFwd (enables HMI button)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			ORdy_OSet : BOOL (Description := "1=Ready for OSets (other than Speed Ref) (enables data entry fields)",
			                    RADIX := Decimal,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			ORdy_SpeedRef : BOOL (Description := "1=Ready for OSet_SpeedRef (enables data entry field)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			MRdy_Check : BOOL (Description := "1=Ready for MCmd_Check (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Bypass : BOOL (Description := "1=Ready for MCmd_Bypass (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Wrk_ExtKeep3ONS : BOOL (Description := "Ext Keep bit 3 one-shot store",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_ExtKeep1ONS : BOOL (Description := "Ext Keep bit 1 one-shot store",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_ExtKeep0ONS : BOOL (Description := "Ext Keep bit 0 one-shot store",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_ExtHas3 : BOOL (Description := "External has Output Datalink",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_ExtHas1 : BOOL (Description := "External has Commands",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_ExtHas0 : BOOL (Description := "External has Speed Reference",
			                      RADIX := Decimal,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_ProgHas3 : BOOL (Description := "Program has Output Datalink",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_ProgHas1 : BOOL (Description := "Program has Commands",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_ProgHas0 : BOOL (Description := "Program has Speed Reference",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_OperHas3 : BOOL (Description := "Operator has Output Datalink",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_OperHas1 : BOOL (Description := "Operator has Commands",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_OperHas0 : BOOL (Description := "Operator has Speed Reference",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			OCmd_Stop : BOOL (Description := "Operator Command to Stop Drive",
			                    RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Out of Service is asserted; Outputs OFF; Run Status shown but Alarms inhibited")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "Handle $QProgrammed Out of Servie$Q Selection using the standard$N"
				    "P_CmdSrc AOI (EnableInFalse";
				N: XIC(EnableIn)P_CmdSrc(CmdSrc);
				RC: "First-Come First-Served Ownership Arbitration still needs to happen, even when device is disabled.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "$QLurking$Q Operator and Program Commands are cleared.$N"
				    "(Lurking Acknowledge Commands are left to perform their action.)$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Commands.  #####";
				N: [OTU(OCmd_StartFwd) OTU(OCmd_StartRev) OTU(OCmd_Stop) ,OTU(OCmd_JogFwd) OTU(OCmd_JogRev) ,OTU(XCmd_StartFwd) OTU(XCmd_StartRev) OTU(XCmd_Stop) ,OTU(XCmd_JogFwd) OTU(XCmd_JogRev) ,OTU(PCmd_StartFwd) OTU(PCmd_StartRev) OTU(PCmd_Stop) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,CLR(Inp_OvrdCmd) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Command Source and Commands. Added Jog function.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [OTU(ORdy_StartFwd) OTU(ORdy_StartRev) OTU(ORdy_Stop) OTU(ORdy_JogFwd) OTU(ORdy_JogRev) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_ResetAckAll) OTU(ORdy_Reset) OTU(Sts_RdyAck) OTU(ORdy_SpeedRef) OTU(ORdy_OSet) ];
				RC: "============================================================$N"
				    "VALUES PROCESSING$N"
				    "============================================================$N"
				    "This rung outputs instruction Values:$N"
				    "$N"
				    "Val_SpeedFdbk (actual running speed), if not in simulation,$N"
				    "from Input";
				N: [[EQU(Cfg_SpeedFdbkRawMax,Cfg_SpeedFdbkRawMin) OTE(Err_FdbkRaw) ,EQU(Cfg_SpeedFdbkEUMax,Cfg_SpeedFdbkEUMin) OTE(Err_FdbkEU) ] ,XIO(Inp_Sim) XIO(Err_FdbkRaw) CPT(Val_SpeedFdbk,Cfg_SpeedFdbkEUMin+(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)/(Cfg_SpeedFdbkRawMax-Cfg_SpeedFdbkRawMin)*(Inp_SpeedFdbk-Cfg_SpeedFdbkRawMin)) ,[XIC(Inp_Sim) ,XIC(Err_FdbkRaw) ] CLR(Val_SpeedFdbk) ];
				RC: "This rung publishes the Values for the scaled speed feedback range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.";
				N: [GEQ(Cfg_SpeedFdbkEUMax,Cfg_SpeedFdbkEUMin) MOV(Cfg_SpeedFdbkEUMin,Val_SpeedFdbkEUMin) MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMax) ,LES(Cfg_SpeedFdbkEUMax,Cfg_SpeedFdbkEUMin) MOV(Cfg_SpeedFdbkEUMin,Val_SpeedFdbkEUMax) MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMin) ];
				RC: "Inputs, including Input Datalink, are updated, even on false rung!$N"
				    "$N"
				    "If the Input Datalink is used, scale the value and report errors.$N"
				    "If not used, set value to zero.";
				N: [XIC(Cfg_HasInpDatalink) [[EQU(Cfg_InpDatalinkRawMax,Cfg_InpDatalinkRawMin) OTE(Err_InpDLRaw) ,EQU(Cfg_InpDatalinkEUMax,Cfg_InpDatalinkEUMin) OTE(Err_InpDLEU) ] ,XIO(Err_InpDLRaw) CPT(Val_InpDatalink,Cfg_InpDatalinkEUMin+(Cfg_InpDatalinkEUMax-Cfg_InpDatalinkEUMin)/(Cfg_InpDatalinkRawMax-Cfg_InpDatalinkRawMin)*(Inp_Datalink-Cfg_InpDatalinkRawMin)) ] ,[XIO(Cfg_HasInpDatalink) ,XIC(Err_InpDLRaw) ] CLR(Val_InpDatalink) ];
				RC: "These are the only Config Error bits we$'re checking in EnableInFalse.$N"
				    "Still, generate the summary Sts_Err for breadcrumb and Val_Sts.";
				N: [XIC(Err_FdbkRaw) ,XIC(Err_FdbkEU) ,XIC(Err_InpDLRaw) ,XIC(Err_InpDLEU) ]OTE(Sts_Err);
				RC: "The Running Forward / Running Reverse Status bits showsif the drive is running,$N"
				    "even though the drive is Out of Service (Prog) by being on a false rung.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Changed Running/Stoppped / Forward/Reverse  #####$N"
				    "#####  to Running Fwd / Running Rev / Stopped.  #####";
				N: XIO(Inp_Sim)[XIC(Cfg_UseRunFdbk) XIC(Inp_Running) ,XIO(Cfg_UseRunFdbk) CMP(ABS(Val_SpeedFdbk)>(0.001*Cfg_SpeedFdbkEUMax)) ][XIC(Inp_ActualDir) OTE(Sts_RunningFwd) ,XIO(Inp_ActualDir) OTE(Sts_RunningRev) ];
				RC: "The Stopped Status (Sts_Stopped) bit shows if the drive is stopped,$N"
				    "even though the drive is Out of Service (Prog) by being on a false rung.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Changed Running/Stoppped / Forward/Reverse  #####$N"
				    "#####  to Running Fwd / Running Rev / Stopped.  #####";
				N: XIO(Sts_RunningFwd)XIO(Sts_RunningRev)OTE(Sts_Stopped);
				RC: "The remaining actual drive status bits are passed through to Status,$N"
				    "even though the drive is Out of Service (Prog) by being on a false rung.";
				N: [[XIO(Inp_Sim) XIC(Inp_ActualDir) ,XIC(Inp_Sim) XIO(Wrk_Rev) ] OTE(Sts_ActualDir) ,[XIO(Inp_Sim) XIC(Inp_CommandDir) ,XIC(Inp_Sim) XIO(Wrk_Rev) ] OTE(Sts_CommandDir) ,XIO(Inp_Sim) [XIC(Inp_Accelerating) OTE(Sts_Accel) ,XIC(Inp_Decelerating) OTE(Sts_Decel) ,XIC(Inp_AtSpeed) OTE(Sts_AtSpeed) ,XIO(Inp_Ready) OTE(Sts_NotReady) OTE(Nrdy_DriveNR) ] ];
				RC: "If the drive is Faulted, this rung finds the Fault Description for$N"
				    "the given Fault Code within the Reference Fault Code List $N"
				    "(In/Out Parameter).  (The same Fault Code List tag$N"
				    "can be referenced by ALL instances of this instruction$N"
				    "that use the fault code -- same drive class!!!)$N"
				    "$N"
				    "1.  Find the number of entries in the Fault Code List (Array SIZE).$N"
				    "2.  Search (FSC) the Fault Code List for a matching Code.$N"
				    "3.  If found, copy the corresponding Description to Val_FaultDesc.$N"
				    "4.  If NOT found, copy list entry zero ($QNo Help Available for this code$Q).";
				N: XIC(Sts_DriveFault)[RES(Wrk_FaultDescFSC) SIZE(Ref_FaultCodeList,0,Wrk_FaultDescFSC.LEN) ,FSC(Wrk_FaultDescFSC,?,?,ALL,Ref_FaultCodeList[Wrk_FaultDescFSC.POS].Code=Inp_LastFaultCode) ,XIC(Wrk_FaultDescFSC.FD) COP(Ref_FaultCodeList[Wrk_FaultDescFSC.POS].Desc,Val_FaultDesc,1) ,XIO(Wrk_FaultDescFSC.FD) COP(Ref_FaultCodeList[0].Desc,Val_FaultDesc,1) ];
				RC: "Val_Fdbk is the current state of the device feedback, as seen on the AOI$'s Inputs:$N"
				    "0 = Stopped$N"
				    "1 = Running Forward$N"
				    "2 = Running Reverse$N"
				    "3 = Accelerating$N"
				    "4 = Decelerating$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Changed Running/Stoppped / Forward/Reverse  #####$N"
				    "#####  to Running Fwd / Running Rev / Stopped.  #####";
				N: [XIC(Sts_Stopped) XIO(Sts_Accel) XIO(Sts_Decel) CLR(Val_Fdbk) ,XIC(Sts_RunningFwd) MOV(1,Val_Fdbk) ,XIC(Sts_RunningRev) MOV(2,Val_Fdbk) ,XIC(Sts_Accel) MOV(3,Val_Fdbk) ,XIC(Sts_Decel) MOV(4,Val_Fdbk) ];
				RC: "When Out of Service, set drive to stop.";
				N: OTU(Wrk_Run)OTU(Wrk_Jog);
				RC: "Reset the fault and command retrigger timers.";
				N: RES(Wrk_StartT)RES(Wrk_StopT)RES(Wrk_JogT)RES(Wrk_StartRetrigT)RES(Wrk_StopRetrigT);
				RC: "Set drive to Stop in Programmed Out of Service (PooS).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-03:  Added Audible Alert on start.  #####";
				N: [OTU(Out_Start) OTL(Out_Stop) OTU(Out_Run) OTU(Out_Jog) ,OTU(Out_Fwd) OTU(Out_Rev) OTU(Out_ClearFault) OTU(Out_Horn) ,CLR(Out_SpeedRef) CLR(Out_Datalink) ];
				RC: "============================================================$N"
				    "REMAINING DRIVE VALUES AND STATUS$N"
				    "============================================================$N"
				    "This rung copies a number of values from the drive directly$N"
				    "to their final Value and Status out";
				N: NEQ(Inp_LastFaultCode,0)MOV(Inp_LastFaultCode,Val_LastFaultCode);
				RC: "If the drive is Faulted, this rung finds the Fault Description for$N"
				    "the given Fault Code within the Reference Fault Code List $N"
				    "(In/Out Parameter).  (The same PF75x Fault Code List$N"
				    "can be referenced by ALL instances of this instruction!!!)$N"
				    "$N"
				    "1.  Find the number of entries in the Fault Code List (Array SIZE).$N"
				    "2.  Search (FSC) the Fault Code List for a matching Code.$N"
				    "3.  If found, copy the corresponding Description to Val_FaultDesc.$N"
				    "4.  If NOT found, copy list entry zero ($QNo Help Available for this code$Q).$N"
				    "$N"
				    "And if the drive is not faulted, clear the Val_FaultDesc string.";
				N: [XIC(Sts_DriveFault) [RES(Wrk_FaultDescFSC) SIZE(Ref_FaultCodeList,0,Wrk_FaultDescFSC.LEN) ,FSC(Wrk_FaultDescFSC,?,?,ALL,Ref_FaultCodeList[Wrk_FaultDescFSC.POS].Code=Val_LastFaultCode) ,XIC(Wrk_FaultDescFSC.FD) COP(Ref_FaultCodeList[Wrk_FaultDescFSC.POS].Desc,Val_FaultDesc,1) ,XIO(Wrk_FaultDescFSC.FD) COP(Ref_FaultCodeList[0].Desc,Val_FaultDesc,1) ] ,XIO(Sts_DriveFault) FLL(0,Val_FaultDesc,1) ];
				RC: "Show the drive as Out of Service and Not Ready, not Available, and with no$N"
				    "Maintenance Bypass breadcrumb.$N"
				    "Clear speed reference and output datalink values.$N"
				    "Show the enumerated drive command as NONE.$N"
				    "Show the enumerated drive status as STOPPED, RUNNING FORWARD, OR RUNNING REVERSE.$N"
				    "Show the enumberated drive fault status as NONE, except show$N"
				    "as CONFIG ERR if there is a configuration error.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  Updated Val_Sts to common enumeration across all motors and drives.  #####";
				N: [OTL(Sts_NotRdy) OTU(Sts_Available) OTU(Sts_MaintByp) ,OTL(Nrdy_OoS) OTU(Nrdy_Intlk) OTU(Nrdy_Perm) ,OTU(Nrdy_PrioStop) OTU(Nrdy_Fail) OTU(Nrdy_IOFault) ,OTU(Sts_StartingFwd) OTU(Sts_StoppingFwd) OTU(Sts_JoggingFwd) OTU(Sts_Horn) ,CLR(Val_SpeedRef) ,XIC(Sts_Stopped) MOV(1,Val_Sts) ,XIC(Sts_RunningFwd) MOV(2,Val_Sts) ,XIC(Sts_RunningRev) MOV(3,Val_Sts) ,CLR(Val_Cmd) CLR(Val_Fault) ,XIC(Sts_Err) OTE(Nrdy_CfgErr) MOV(34,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed go";
				N: [CLR(Wrk_SrcQ) ,[XIO(Cfg_HasRunFdbk) ,XIO(Cfg_HasSpeedFdbk) ] MOV(1,Wrk_SrcQ) ,XIO(Cfg_HasRunFdbk) XIO(Cfg_HasSpeedFdbk) MOV(2,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,[XIC(Err_FdbkRaw) ,XIC(Err_FdbkEU) ] MOV(35,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(20,SrcQ);
				RC: "If the device is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then show the alarms as $QParent object out of service$Q.$N"
				    "Show the overall acknowledgement status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Changed P_Mode to P_CmdSrc, added Out of Service.  #####";
				N: [OTL(FailToStart.Inp_OoS) P_Alarm(FailToStart) ,OTL(FailToStop.Inp_OoS) P_Alarm(FailToStop) ,OTL(IntlkTrip.Inp_OoS) P_Alarm(IntlkTrip) ,OTL(DriveFault.Inp_OoS) P_Alarm(DriveFault) ,OTL(IOFault.Inp_OoS) P_Alarm(IOFault) ,CLR(Val_Notify) CLR(Val_NotifyAll) ,[XIC(FailToStart.Val_Notify.0) ,XIC(FailToStop.Val_Notify.0) ,XIC(IntlkTrip.Val_Notify.0) ,XIC(DriveFault.Val_Notify.0) ,XIC(IOFault.Val_Notify.0) ] OTL(Val_Notify.0) OTL(Val_NotifyAll.0) ,[XIC(FailToStart.Sts_AlmInh) ,XIC(FailToStop.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(DriveFault.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ] OTE(Sts_AlmInh) ];
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan: control / monitor Variable-Speed Drive")
				RC: "Copyright ? Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_VSD :  PROCESS -- VARIABLE SPEED DRIVE$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-16:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-07-13:  Changed $QMode$Q to $QCommand Source$Q.$N"
				    "Added audible alert on commanded start.  Added unacked alarm count.$N"
				    "Changed Inf_ items to HMI_, and added Cfg_Area for security.$N"
				    "Changed Start / Stop / Fwd / Rev / Jog to StartFwd / StartRev /Stop / JogFwd / JogRev.$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyAck and Sts_ResetReqd for use by external objects.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "Added configurable decimal places for display on HMI.$N"
				    "Modifications to Output Datalink clamp limit restrictions / checking.$N"
				    "Changed delay / time configuration items to REAL seconds.$N"
				    "Updated Val_Sts to common enumeration across all motors and drives.$N"
				    "V4.00.02  2018-10-30:  Corrected handling Allow Local when horn is enabled$N"
				    "V4.10.00  2019-03-25:  Changed availability to use input availability from interlocks.$N"
				    "Added Horn Status, Horn Inhibit. Updated to P_CmdSrc V4.10.00.$N"
				    "Modified simulated run feedback to handle run at zero speed ref.$N"
				    "Added Cfg_HasMoreObj.$N"
				    "V4.10.01  2019-10-16:  Corrected handling of Start Horn on shed conditions.$N"
				    "Modified to lock out jog when jog time expires until jog commands$N"
				    "are cleared. Modified to handle overlapping Horn and Jog times.$N"
				    "============================================================$N"
				    "This Instruction controls and monitors a Variable-Speed Drive (AC or DC) and provides:$N"
				    "$N"
				    "*  Starting, stopping, jogging of drive, setting speed reference and direction$N"
				    "*  Monitoring of run feedback, display of actual drive status, including accel, decel, direction, speed$N"
				    "*  Detection of Failure to Start, Failure to Stop, Drive Fault$N"
				    "*  Monitoring of Permissive conditions to allow starting$N"
				    "* Monitoring of Interlock conditions to stop / prevent starting$N"
				    "* Simulation, providing feedback of a working drive while disabling outputs$N"
				    "* Monitoring of I/O communication faults$N"
				    "* Alarms for Fail to Start, Fail to Stop, Interlock Trip, Drive Fault, I/O Fault$N"
				    "* Option to automatically reset faults and alarms when operator commands$N"
				    "motor to start or stop$N"
				    "* Supports HMI $Qbreadcrumbs$Q for Alarm Inhibited, Bad Configuration,$N"
				    "Not Ready, Maintenance Bypass Active$N"
				    "* $QAvailable$Q status for use by automation logic to know whether motor$N"
				    "can be controlled by other objects.$N"
				    "* Horn output for audible alert prior to starting motor.$N"
				    "$N"
				    "Command Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$N"
				    "Command Sources: Operator, External, Program, External, Override, Maintenance,$N"
				    "Out of Service, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)[LOWER(Cfg_Desc,Cfg_Label) LOWER(Cfg_Tag,Cfg_Area) LOWER(Cfg_FwdText,Cfg_RevText) LOWER(Cfg_SpeedRefEU,Cfg_SpeedFdbkEU) ,LOWER(Cfg_InpDatalinkLabel,Cfg_InpDatalinkEU) LOWER(Cfg_OutDatalinkLabel,Cfg_OutDatalinkEU) LOWER(HMI_Lib,HMI_Type) ];
				RC: "This rung handles received Command Source selection Inputs and Commands:$N"
				    "$N"
				    "NOTE:  All Commands for Command Source and Alarm are aliased directly to the$N"
				    "corresponding Commands in the contained P_CmdSrc and P_Alarm AOIs.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Changed P_Mode to P_CmdSrc.  #####";
				N: LBL(SkipText)P_CmdSrc(CmdSrc);
				RC: "This rung handles simple First-Come First-Served Ownership Arbitration.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "============================================================$N"
				    "CONFIGURATION PROCESSING$N"
				    "============================================================$N"
				    "If the device is configured to not HAVE device feedback input (engineer),$N"
				    "it cannot be USE the feedback";
				N: XIO(Cfg_HasRunFdbk)OTU(Cfg_UseRunFdbk)OTU(Cfg_AllowLocal);
				RC: "If the device is configured to not HAVE speed feedback input (engineer),$N"
				    "it cannot be USE the feedback (maintenance).";
				N: XIO(Cfg_HasSpeedFdbk)OTU(Cfg_UseSpeedFdbk);
				RC: "============================================================$N"
				    "COMMAND SOURCE PROCESSING: $QASPECT$Q OWNERSHIP$N"
				    "============================================================$N"
				    "Using the Command Source determined above, and the Cfg_OperKeep,$N"
				    "Cfg_ProgKeep and";
				N: [XIC(Cfg_OperKeep.0) ONS(Wrk_OperKeep0ONS) OTU(Cfg_ProgKeep.0) OTU(Cfg_ExtKeep.0) ,XIC(Cfg_OperKeep.1) ONS(Wrk_OperKeep1ONS) OTU(Cfg_ProgKeep.1) OTU(Cfg_ExtKeep.1) ,XIC(Cfg_OperKeep.3) ONS(Wrk_OperKeep3ONS) OTU(Cfg_ProgKeep.3) OTU(Cfg_ExtKeep.3) ,XIC(Cfg_ProgKeep.0) ONS(Wrk_ProgKeep0ONS) OTU(Cfg_OperKeep.0) OTU(Cfg_ExtKeep.0) ,XIC(Cfg_ProgKeep.1) ONS(Wrk_ProgKeep1ONS) OTU(Cfg_OperKeep.1) OTU(Cfg_ExtKeep.1) ,XIC(Cfg_ProgKeep.3) ONS(Wrk_ProgKeep3ONS) OTU(Cfg_OperKeep.3) OTU(Cfg_ExtKeep.3) ,XIC(Cfg_ExtKeep.0) ONS(Wrk_ExtKeep0ONS) OTU(Cfg_ProgKeep.0) OTU(Cfg_OperKeep.0) ,XIC(Cfg_ExtKeep.1) ONS(Wrk_ExtKeep1ONS) OTU(Cfg_ProgKeep.1) OTU(Cfg_OperKeep.1) ,XIC(Cfg_ExtKeep.3) ONS(Wrk_ExtKeep3ONS) OTU(Cfg_ProgKeep.3) OTU(Cfg_OperKeep.3) ];
				RC: "These three rungs determine who actually currently owns the various aspects of the drive:$N"
				    "the Operator, the Program, or the External command source.$N"
				    "$N"
				    "These rungs help simplify the logic later, removing the repetition of these branch structures!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Using P_CmdSrc, added External command source.  #####";
				N: [[XIC(Sts_Oper) XIO(Cfg_ProgKeep.0) XIO(Cfg_ExtKeep.0) ,XIC(Sts_Maint) ,[XIC(Sts_Prog) ,XIC(Sts_Ext) ] XIC(Cfg_OperKeep.0) ] OTE(Wrk_OperHas0) ,[XIC(Sts_Oper) XIO(Cfg_ProgKeep.1) XIO(Cfg_ExtKeep.1) ,XIC(Sts_Maint) ,[XIC(Sts_Prog) ,XIC(Sts_Ext) ] XIC(Cfg_OperKeep.1) ] OTE(Wrk_OperHas1) ,[XIC(Sts_Oper) XIO(Cfg_ProgKeep.3) XIO(Cfg_ExtKeep.3) ,XIC(Sts_Maint) ,[XIC(Sts_Prog) ,XIC(Sts_Ext) ] XIC(Cfg_OperKeep.3) ] OTE(Wrk_OperHas3) ];
				N: [[XIC(Sts_Prog) XIO(Cfg_OperKeep.0) XIO(Cfg_ExtKeep.0) ,[XIC(Sts_Oper) ,XIC(Sts_Ext) ] XIC(Cfg_ProgKeep.0) ] OTE(Wrk_ProgHas0) ,[XIC(Sts_Prog) XIO(Cfg_OperKeep.1) XIO(Cfg_ExtKeep.1) ,[XIC(Sts_Oper) ,XIC(Sts_Ext) ] XIC(Cfg_ProgKeep.1) ] OTE(Wrk_ProgHas1) ,[XIC(Sts_Prog) XIO(Cfg_OperKeep.3) XIO(Cfg_ExtKeep.3) ,[XIC(Sts_Oper) ,XIC(Sts_Ext) ] XIC(Cfg_ProgKeep.3) ] OTE(Wrk_ProgHas3) ];
				N: [[XIC(Sts_Ext) XIO(Cfg_ProgKeep.0) XIO(Cfg_OperKeep.0) ,[XIC(Sts_Prog) ,XIC(Sts_Oper) ] XIC(Cfg_ExtKeep.0) ] OTE(Wrk_ExtHas0) ,[XIC(Sts_Ext) XIO(Cfg_ProgKeep.1) XIO(Cfg_OperKeep.1) ,[XIC(Sts_Prog) ,XIC(Sts_Oper) ] XIC(Cfg_ExtKeep.1) ] OTE(Wrk_ExtHas1) ,[XIC(Sts_Ext) XIO(Cfg_ProgKeep.3) XIO(Cfg_OperKeep.3) ,[XIC(Sts_Prog) ,XIC(Sts_Oper) ] XIC(Cfg_ExtKeep.3) ] OTE(Wrk_ExtHas3) ];
				RC: "These rungs get Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration data are used directly in-place.$N"
				    "$N"
				    "Enter the time (in seconds) for the Drive to successfully start before declaring a fault.$N"
				    "Enter the time (in seconds) for the Drive to successfully stop before declaring a fault.$N"
				    "Enter the time (in seconds) for the Drive Fault Reset output to be pulsed when a reset is received.$N"
				    "(The reset pulse time is also used for pulsing Start or Stop$N"
				    "output on a start or stop command retrigger in Maintenance.)$N"
				    "$N"
				    "If the timer preset calcuated wraps negative (more than 2.14... million seconds), then max out the$N"
				    "or clear the Timer Preset (as appropriate) and flag it.  Note that a negative timer preset will fault the controller!!!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added audible alert prior to commanded start.  #####$N"
				    "#####  Changed delay / time configuration items to REAL seconds.  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added Inp_HornInh to disable Horn operation.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Modified to handle overlapping Horn and Jog times.  #####";
				N: [[MUL(Cfg_FailToStartT,1000.0,Wrk_StartT.PRE) XIC(Wrk_StartT.PRE.31) MOV(2147483647,Wrk_StartT.PRE) ,MUL(Cfg_FailToStopT,1000.0,Wrk_StopT.PRE) XIC(Wrk_StopT.PRE.31) MOV(2147483647,Wrk_StopT.PRE) ,MUL(Cfg_ResetPulseT,1000.0,Wrk_ResetT.PRE) XIC(Wrk_ResetT.PRE.31) CLR(Wrk_ResetT.PRE) ,[GRT(Cfg_StartHornT,1000.0) CLR(Cfg_StartHornT) ,MUL(Cfg_StartHornT,1000.0,Wrk_StartHornT.PRE) ,XIC(Inp_HornInh) CLR(Wrk_StartHornT.PRE) ] XIC(Wrk_StartHornT.PRE.31) CLR(Wrk_StartHornT.PRE) ,CPT(Wrk_JogT.PRE,Cfg_MaxJogT*1000.0+Wrk_StartHornT.PRE) XIC(Wrk_JogT.PRE.31) CLR(Wrk_JogT.PRE) ] OTE(Err_Timer) ,MOV(Wrk_StartT.PRE,Wrk_StartInhT.PRE) MOV(Wrk_StopT.PRE,Wrk_StopInhT.PRE) MOV(Wrk_ResetT.PRE,Wrk_StartRetrigT.PRE) MOV(Wrk_ResetT.PRE,Wrk_StopRetrigT.PRE) ];
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Bad Raw Scaling configs$N"
				    "Bad Engineering Units Scaling configs$N"
				    "Bad Min or Max Speed Reference clamp limit$N"
				    "Bad simulation speed ramp time$N"
				    "Bad timer config from (rung above)$N"
				    "Bad Alarm config (from P_Alarm)$N"
				    "Bad Cfg_OperKeep / Cfg_ProgKeep config$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Modified to allow the special case where min and max clamping  #####$N"
				    "#####  limits (speed or output datalink) can be EQUAL (clamp at a specific value).  #####$N"
				    "#####  Changed delay / time configuration items to REAL seconds.  #####";
				N: [XIC(Cfg_HasSpeedFdbk) [EQU(Cfg_SpeedFdbkRawMax,Cfg_SpeedFdbkRawMin) OTE(Err_FdbkRaw) ,EQU(Cfg_SpeedFdbkEUMax,Cfg_SpeedFdbkEUMin) OTE(Err_FdbkEU) ] ,EQU(Cfg_SpeedRefEUMax,Cfg_SpeedRefEUMin) OTE(Err_RefEU) ,EQU(Cfg_SpeedRefRawMax,Cfg_SpeedRefRawMin) OTE(Err_RefRaw) ,XIC(Cfg_HasInpDatalink) [EQU(Cfg_InpDatalinkRawMax,Cfg_InpDatalinkRawMin) OTE(Err_InpDLRaw) ,EQU(Cfg_InpDatalinkEUMax,Cfg_InpDatalinkEUMin) OTE(Err_InpDLEU) ] ,XIC(Cfg_HasOutDatalink) [LES(Cfg_OutDatalinkMax,Cfg_OutDatalinkMin) OTE(Err_OutDLLim) ,EQU(Cfg_OutDatalinkEUMax,Cfg_OutDatalinkEUMin) OTE(Err_OutDLEU) ,EQU(Cfg_OutDatalinkRawMax,Cfg_OutDatalinkRawMin) OTE(Err_OutDLRaw) ] ,[LES(Cfg_MaxSpdRef,Cfg_MinSpdRef) ,LES(Cfg_MinSpdRef,0.0) ] OTE(Err_RefLim) ,LES(Cfg_SimRampT,0.0) OTE(Err_Sim) ,XIC(Err_Timer) ]OTE(Nrdy_CfgErr);
				RC: "This rung publishes the Values for the scaled speed reference range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the configuration of another block so the VSD$'s range$N"
				    " and other block$'s range are in lockstep.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added configurable decimal places for display on HMI.  #####$N"
				    "#####  Added checks to ensure Datalink clamp limits are within scaled (EU) range.  #####";
				N: [GEQ(Cfg_SpeedRefEUMax,Cfg_SpeedRefEUMin) MOV(Cfg_SpeedRefEUMin,Val_SpeedRefEUMin) MOV(Cfg_SpeedRefEUMax,Val_SpeedRefEUMax) ,LES(Cfg_SpeedRefEUMax,Cfg_SpeedRefEUMin) MOV(Cfg_SpeedRefEUMin,Val_SpeedRefEUMax) MOV(Cfg_SpeedRefEUMax,Val_SpeedRefEUMin) ,LES(Cfg_OutDatalinkMin,Cfg_OutDatalinkEUMin) MOV(Cfg_OutDatalinkEUMin,Cfg_OutDatalinkMin) ,GRT(Cfg_OutDatalinkMin,Cfg_OutDatalinkEUMax) MOV(Cfg_OutDatalinkEUMax,Cfg_OutDatalinkMin) ,LES(Cfg_OutDatalinkMax,Cfg_OutDatalinkEUMin) MOV(Cfg_OutDatalinkEUMin,Cfg_OutDatalinkMax) ,GRT(Cfg_OutDatalinkMax,Cfg_OutDatalinkEUMax) MOV(Cfg_OutDatalinkEUMax,Cfg_OutDatalinkMax) ,LIM(7,Cfg_DecPlcs,-1) MOV(2,Cfg_DecPlcs) ,LIM(7,Cfg_InpDLDecPlcs,-1) MOV(2,Cfg_InpDLDecPlcs) ,LIM(7,Cfg_OutDLDecPlcs,-1) MOV(2,Cfg_OutDLDecPlcs) ];
				RC: "This rung publishes the Values for the scaled speed feedback range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.";
				N: [GEQ(Cfg_SpeedFdbkEUMax,Cfg_SpeedFdbkEUMin) MOV(Cfg_SpeedFdbkEUMin,Val_SpeedFdbkEUMin) MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMax) ,LES(Cfg_SpeedFdbkEUMax,Cfg_SpeedFdbkEUMin) MOV(Cfg_SpeedFdbkEUMin,Val_SpeedFdbkEUMax) MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMin) ];
				RC: "============================================================$N"
				    "SETTINGS PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Program Settings:$N"
				    "$N"
				    "First, handle clamping of the Program Output Datalink Setting.";
				N: [GRT(PSet_OutDatalink,Cfg_OutDatalinkMax) MOV(Cfg_OutDatalinkMax,PSet_OutDatalink) ,LES(PSet_OutDatalink,Cfg_OutDatalinkMin) MOV(Cfg_OutDatalinkMin,PSet_OutDatalink) ,XIC(Wrk_ProgHas3) MOV(PSet_OutDatalink,Wrk_OutDatalink) ,XIC(Wrk_ProgHas0) MOV(PSet_SpeedRef,Wrk_SpeedRef) ];
				RC: "This rung handles received Operator Settings:$N"
				    "$N"
				    "First, handle clamping of the Operator Output Datalink Setting.$N"
				    "(Clamping of the Speed Reference is handled below.)$N"
				    "$N"
				    "Then, if the command source is Operator and the Program and External do not retain the Output Datalink,$N"
				    "or if the command source is Maintenance,$N"
				    "or if the command source is Program or External but the Operator retains the Output Datalink,$N"
				    "use the Operator Setting for the Output Datalink.$N"
				    "$N"
				    "The Operator Setting for the Speed Reference is handled similarly.$N"
				    "$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [GRT(OSet_OutDatalink,Cfg_OutDatalinkMax) MOV(Cfg_OutDatalinkMax,OSet_OutDatalink) ,LES(OSet_OutDatalink,Cfg_OutDatalinkMin) MOV(Cfg_OutDatalinkMin,OSet_OutDatalink) ,XIC(Wrk_OperHas3) MOV(OSet_OutDatalink,Wrk_OutDatalink) ,XIC(Wrk_OperHas0) MOV(OSet_SpeedRef,Wrk_SpeedRef) ];
				RC: "This rung handles received External Settings:$N"
				    "$N"
				    "First, handle clamping of the External Output Datalink Setting.$N"
				    "(Clamping of the Speed Reference is handled below.)$N"
				    "$N"
				    "Then, if the command source is External and the Program and Operator do not retain the Output Datalink,$N"
				    "or if the command source is Program or Operator but External retains the Output Datalink,$N"
				    "use the External Setting for the Output Datalink.$N"
				    "$N"
				    "The External Setting for the Speed Reference is handled similarly.$N"
				    "$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [GRT(XSet_OutDatalink,Cfg_OutDatalinkMax) MOV(Cfg_OutDatalinkMax,XSet_OutDatalink) ,LES(XSet_OutDatalink,Cfg_OutDatalinkMin) MOV(Cfg_OutDatalinkMin,XSet_OutDatalink) ,XIC(Wrk_ExtHas3) MOV(XSet_OutDatalink,Wrk_OutDatalink) ,XIC(Wrk_ExtHas0) MOV(XSet_SpeedRef,Wrk_SpeedRef) ];
				RC: "This rung handles Override command source for Output Datalink and Speed Reference.$N"
				    "$N"
				    "First, handle clamping of the Override Output Datalink Input.$N"
				    "(Clamping of the Speed Reference is handled below.)$N"
				    "Then, if the command source is Override, use the Override Output Datalink Input$N"
				    "and the Override Speed Reference Input.$N"
				    "$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [GRT(Inp_OvrdOutDatalink,Cfg_OutDatalinkMax) MOV(Cfg_OutDatalinkMax,Inp_OvrdOutDatalink) ,LES(Inp_OvrdOutDatalink,Cfg_OutDatalinkMin) MOV(Cfg_OutDatalinkMin,Inp_OvrdOutDatalink) ,XIC(Sts_Ovrd) MOV(Inp_OvrdSpeed,Wrk_SpeedRef) MOV(Inp_OvrdOutDatalink,Wrk_OutDatalink) ];
				RC: "Ready to receive a new OSet_SpeedRef if tracking is NOT enabled,$N"
				    "or we$'re in Operator or Maintenance, or,$N"
				    "if we$'re in Hand or Ovrd, tracking is NOT configured for Ovrd and Hand.$N"
				    "$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [XIO(Cfg_SetTrack) ,XIC(Wrk_OperHas0) ,[XIC(Sts_Hand) ,XIC(Sts_Ovrd) ] XIO(Cfg_SetTrackOvrdHand) ]OTE(ORdy_SpeedRef);
				RC: "Ready to receive other Operator Settings (OSet_xxx) if tracking is NOT enabled,$N"
				    "or we$'re in Operator or Maintenance.$N"
				    "$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [XIO(Cfg_SetTrack) ,XIC(Wrk_OperHas3) ]OTE(ORdy_OSet);
				RC: "============================================================$N"
				    "DEVICE FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "In preparation for ramping the simulated speed feedback, this rung$N"
				    "determines the time since the previ";
				N: MOV(2147483647,Wrk_ScanT.PRE)TON(Wrk_ScanT,?,?)DIV(Wrk_ScanT.ACC,1000.0,Wrk_ScanTime)CLR(Wrk_ScanT.ACC);
				RC: "If the device is in Hand Mode, or if the device was switched from$N"
				    "simulated to real THIS SCAN (ONS), we need to align the object$N"
				    "state with the actual state of the drive.";
				N: [XIC(Sts_Hand) ,XIO(Inp_Sim) ONS(Wrk_NoLongerSim) ]OTE(Wrk_Hand);
				RC: "============================================================$N"
				    "SPEED FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "If not in simulation and scaling config is valid, the speed feedback is scaled from the raw Input.$N"
				    "$N"
				    "If";
				N: XIO(Inp_Sim)XIO(Err_FdbkRaw)[XIC(Cfg_HasSpeedFdbk) [XIC(Cfg_SimScaleEU) ONS(Wrk_SimScaleEUONS) OTU(Cfg_SimScaleRaw) ,XIC(Cfg_SimScaleRaw) ONS(Wrk_SimScaleRawONS) OTU(Cfg_SimScaleEU) ,CPT(Val_SpeedFdbk,(Inp_SpeedFdbk-Cfg_SpeedFdbkRawMin)/(Cfg_SpeedFdbkRawMax-Cfg_SpeedFdbkRawMin)*(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)+Cfg_SpeedFdbkEUMin) ,XIC(Wrk_Hand) [XIO(Cfg_SimScaleEU) XIO(Cfg_SimScaleRaw) MOV(Val_SpeedFdbk,Wrk_SpeedRef) ,XIC(Cfg_SimScaleEU) XIO(Cfg_SimScaleRaw) CPT(Wrk_SpeedRef,(Val_SpeedFdbk-Cfg_SpeedFdbkEUMin)/(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)*(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)+Cfg_SpeedRefEUMin) ,XIC(Cfg_SimScaleRaw) XIO(Cfg_SimScaleEU) CPT(Wrk_SpeedRef,(Inp_SpeedFdbk-Cfg_SpeedRefRawMin)/(Cfg_SpeedRefRawMax-Cfg_SpeedRefRawMin)*(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)+Cfg_SpeedRefEUMin) ] ] ,XIO(Cfg_HasSpeedFdbk) [XIC(Wrk_RunFdbk) MOV(Wrk_SpeedRef,Val_SpeedFdbk) ,XIO(Wrk_RunFdbk) CLR(Val_SpeedFdbk) ] ]JMP(SkipSpeedSim);
				RC: "If the Speed Feedback scaling config values are invalid, just clear$N"
				    "Val_SpeedFdbk and skip the actual speed feedback processing.";
				N: [XIO(Inp_Sim) XIC(Err_FdbkRaw) ,XIC(Err_FdbkEU) ,XIC(Inp_Sim) [XIC(Cfg_SimScaleEU) XIC(Err_RefEU) ,XIC(Cfg_SimScaleRaw) [XIC(Err_FdbkRaw) ,XIC(Err_RefEU) ] ] ]CLR(Val_SpeedFdbk)JMP(SkipSpeedSim);
				RC: "If in simulation, simulate accel/decel.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Changed delay / time configuration items to REAL seconds.  #####";
				N: XIC(Inp_Sim)[[XIC(Wrk_Run) ,XIC(Wrk_Jog) ] [XIO(Cfg_SimScaleEU) XIO(Cfg_SimScaleRaw) MOV(Wrk_SpeedRef,Wrk_SimFdbkTgt) ,[XIC(Cfg_SimScaleEU) XIO(Cfg_SimScaleRaw) CPT(Wrk_SimFdbkTgt,(Wrk_SpeedRef-Cfg_SpeedRefEUMin)/(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)*(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)+Cfg_SpeedFdbkEUMin) ,XIC(Cfg_SimScaleRaw) [CPT(Wrk_SimFdbkTgt,(Wrk_SpeedRef-Cfg_SpeedRefEUMin)/(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)*(Cfg_SpeedRefRawMax-Cfg_SpeedRefRawMin)+Cfg_SpeedRefRawMin) ,CPT(Wrk_SimFdbkTgt,(Wrk_SimFdbkTgt-Cfg_SpeedFdbkRawMin)/(Cfg_SpeedFdbkRawMax-Cfg_SpeedFdbkRawMin)*(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)+Cfg_SpeedFdbkEUMin) ] ] ] ,[XIO(Wrk_Run) XIO(Wrk_Jog) ,XIO(Wrk_Rev) XIO(Sts_ActualDir) ,XIC(Wrk_Rev) XIC(Sts_ActualDir) ] CLR(Wrk_SimFdbkTgt) ,GRT(Cfg_SimRampT,0.0) [CPT(Wrk_Step,Cfg_MaxSpdRef/Cfg_SimRampT*Wrk_ScanTime) ,XIC(Cfg_SimScaleEU) XIO(Cfg_SimScaleRaw) CPT(Wrk_Step,(Wrk_Step-Cfg_SpeedRefEUMin)/(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)*(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)+Cfg_SpeedFdbkEUMin) ,XIC(Cfg_SimScaleRaw) [CPT(Wrk_Step,(Wrk_Step-Cfg_SpeedRefEUMin)/(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)*(Cfg_SpeedRefRawMax-Cfg_SpeedRefRawMin)+Cfg_SpeedRefRawMin) ,CPT(Wrk_Step,(Wrk_Step-Cfg_SpeedFdbkRawMin)/(Cfg_SpeedFdbkRawMax-Cfg_SpeedFdbkRawMin)*(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)+Cfg_SpeedFdbkEUMin) ] ] ,LEQ(Cfg_SimRampT,0.0) MOV(1.50000000e+038,Wrk_Step) ,CMP(ABS(Val_SpeedFdbk-Wrk_SimFdbkTgt)<=Wrk_Step) MOV(Wrk_SimFdbkTgt,Val_SpeedFdbk) ,CMP((Val_SpeedFdbk-Wrk_SimFdbkTgt)>Wrk_Step) SUB(Val_SpeedFdbk,Wrk_Step,Val_SpeedFdbk) ,CMP((Wrk_SimFdbkTgt-Val_SpeedFdbk)>Wrk_Step) ADD(Val_SpeedFdbk,Wrk_Step,Val_SpeedFdbk) ];
				RC: "============================================================$N"
				    "INPUT DATALINK PROCESSING$N"
				    "============================================================$N"
				    "Scale the Input Datalink (if we have one) to its engineering units.";
				N: LBL(SkipSpeedSim)[XIO(Err_InpDLEU) XIC(Cfg_HasInpDatalink) CPT(Val_InpDatalink,Cfg_InpDatalinkEUMin+(Cfg_InpDatalinkEUMax-Cfg_InpDatalinkEUMin)/(Cfg_InpDatalinkRawMax-Cfg_InpDatalinkRawMin)*(Inp_Datalink-Cfg_InpDatalinkRawMin)) ,[XIO(Cfg_HasInpDatalink) ,XIC(Err_InpDLEU) ] CLR(Val_InpDatalink) ];
				RC: "============================================================$N"
				    "RUN FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "If the drive is NOT being simulated and it HAS and IS USING a run feedback,$N"
				    "use the state of the run feed";
				N: [XIO(Inp_Sim) XIC(Cfg_UseRunFdbk) XIC(Inp_Running) ,[XIC(Inp_Sim) ,XIO(Cfg_UseRunFdbk) ] [XIC(Cfg_UseSpeedFdbk) [CMP(ABS(Val_SpeedFdbk)>(0.001*Cfg_SpeedFdbkEUMax)) ,XIC(Wrk_Run) ,XIC(Wrk_Jog) ] ,XIO(Cfg_UseSpeedFdbk) [XIC(Wrk_StartRetrigT.DN) ,XIC(Wrk_StopRetrigT.TT) ] ] ]OTE(Wrk_RunFdbk);
				RC: "This rung copies the drive Status Word bits to external Status parameters of the instruction.$N"
				    "When this instruction is in simulation, simulated status is generated to $Qact like$Q a drive.";
				N: [[XIO(Inp_Sim) XIC(Inp_CommandDir) ,XIC(Inp_Sim) XIO(Wrk_Rev) ] OTE(Sts_CommandDir) ,[XIO(Inp_Sim) [XIC(Inp_ActualDir) OTL(Sts_ActualDir) ,XIO(Inp_ActualDir) OTU(Sts_ActualDir) ] ,XIC(Inp_Sim) EQU(Val_SpeedFdbk,0.0) [XIO(Wrk_Rev) OTL(Sts_ActualDir) ,XIC(Wrk_Rev) OTU(Sts_ActualDir) ] ] ,[XIO(Inp_Sim) XIC(Inp_Accelerating) ,XIC(Inp_Sim) LES(Val_SpeedFdbk,Wrk_SimFdbkTgt) ] OTE(Sts_Accel) ,[XIO(Inp_Sim) XIC(Inp_Decelerating) ,XIC(Inp_Sim) GRT(Val_SpeedFdbk,Wrk_SimFdbkTgt) ] OTE(Sts_Decel) ,XIO(Inp_Sim) XIC(Inp_Alarm) OTE(Sts_Alarm) ,XIO(Inp_Sim) XIO(Inp_Ready) OTE(Sts_NotReady) ,[XIO(Inp_Sim) XIC(Inp_AtSpeed) ,XIC(Inp_Sim) EQU(Wrk_SimFdbkTgt,Val_SpeedFdbk) NEQ(Wrk_SimFdbkTgt,0.0) ] OTE(Sts_AtSpeed) ];
				RC: "Val_Fdbk is the current state of the device feedback, as seen on the AOI$'s Inputs:$N"
				    "0 = Stopped$N"
				    "1 = Running Forward$N"
				    "2 = Running Reverse$N"
				    "3 = Accelerating$N"
				    "4 = Decelerating";
				N: [XIO(Wrk_RunFdbk) XIO(Sts_Accel) XIO(Sts_Decel) CLR(Val_Fdbk) ,XIC(Wrk_RunFdbk) XIC(Sts_ActualDir) MOV(1,Val_Fdbk) ,XIC(Wrk_RunFdbk) XIO(Sts_ActualDir) MOV(2,Val_Fdbk) ,XIC(Sts_Accel) MOV(3,Val_Fdbk) ,XIC(Sts_Decel) MOV(4,Val_Fdbk) ];
				RC: "============================================================$N"
				    "INTERLOCK / PERMISSIVE BYPASS / CHECK COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Bypass Command bypasses the Bypassable Permissives and Interlocks.";
				N: XIC(MCmd_Bypass)OTU(MCmd_Bypass)OTL(Wrk_Bypass);
				RC: "The Check Command enables checking of ALL$N"
				    "Permissives and Interlocks (cancels the bypass).";
				N: XIC(MCmd_Check)OTU(MCmd_Check)OTU(Wrk_Bypass);
				RC: "If the internal Bypass flag is set, Bypassable Interlocks and Permissives ARE BYPASSED.$N"
				    "Bypassing is ACTIVE if Bypass selected OR in Maintenance Mode,$N"
				    "or in Override Mode if Override Bypassing is configured.";
				N: [XIC(Wrk_Bypass) OTE(Sts_Bypass) ,XIC(Sts_Maint) ,XIC(Sts_Ovrd) XIC(Cfg_OvrdPermIntlk) ]OTE(Sts_BypActive);
				RC: "If a Maintenance Bypass function is active, display the Maintenance Bypass$N"
				    "Indicator (triangle symbol) on the graphic symbol.  Bypass functions are:$N"
				    "*  Interlock / Permissive Bypass function is enabled$N"
				    "*  Motor HAS run feedback designated by engineer, but$N"
				    "maintenance has selected to NOT USE run feedback";
				N: [XIC(Sts_Bypass) ,XIC(Cfg_HasRunFdbk) XIO(Cfg_UseRunFdbk) ]OTE(Sts_MaintByp);
				RC: "Ready for Interlock / Permissive Bypass if not bypassed.$N"
				    "Ready to cancel Bypass (resume checking) if bypassed.";
				N: [XIO(Wrk_Bypass) OTE(MRdy_Bypass) ,XIC(Wrk_Bypass) OTE(MRdy_Check) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(XCmd_Reset) OTU(XCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ONS(Wrk_ResetONS) ,[XIC(OCmd_StartFwd) ,XIC(OCmd_StartRev) ,XIC(OCmd_Stop) ,[XIC(OCmd_JogFwd) ,XIC(OCmd_JogRev) ] XIC(Cfg_HasJog) ] XIC(Cfg_OCmdResets) XIC(Wrk_OperHas1) ,[XIC(XCmd_StartFwd) ,XIC(XCmd_StartRev) ,XIC(XCmd_Stop) ,[XIC(XCmd_JogFwd) ,XIC(XCmd_JogRev) ] XIC(Cfg_HasJog) ] XIC(Cfg_XCmdResets) XIC(Wrk_ExtHas1) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(PCmd_FailToStartAck) ,OTL(PCmd_FailToStopAck) ,OTL(PCmd_DriveFaultAck) ,OTL(PCmd_IntlkTripAck) ,OTL(PCmd_IOFaultAck) ] ][OTL(FailToStart.PCmd_Reset) OTL(FailToStop.PCmd_Reset) OTL(IntlkTrip.PCmd_Reset) OTL(IOFault.PCmd_Reset) ,XIC(Sts_FailToStart) RES(Wrk_StartT) ,XIC(Sts_FailToStop) RES(Wrk_StopT) ,OTU(Nrdy_PrioStop) OTU(Nrdy_Fail) ,[XIO(Inp_IOFault) ,XIC(Inp_Sim) ] OTU(Nrdy_IOFault) ,TOF(Wrk_ResetT,?,?) ];
				RC: "The Hold Timer $Qdone$Q bit comes on immediately and stays on$N"
				    "for the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.";
				N: XIC(Wrk_ResetT.DN)[XIC(Inp_Faulted) XIO(Inp_Sim) OTE(Out_ClearFault) ,OTL(DriveFault.PCmd_Reset) ];
				RC: "============================================================$N"
				    "DRIVE START / STOP COMMAND HANDLING$N"
				    "============================================================$N"
				    "In preparation for the Start / Stop logic that follows, this rung$N"
				    "stashes away the Permissive";
				N: [[XIC(Inp_FwdPermOK) ,XIC(Sts_BypActive) ] XIC(Inp_FwdNBPermOK) OTE(Wrk_FwdPermOK) ,[XIC(Inp_RevPermOK) ,XIC(Sts_BypActive) ] XIC(Inp_RevNBPermOK) OTE(Wrk_RevPermOK) ];
				RC: "The drive is NOT READY TO RUN if:$N"
				    "* Interlocks are not OK and not bypassed;$N"
				    "* Non-bypassable Interlocks are not OK;$N"
				    "* Permissives are not OK and not bypassed,$N"
				    "or Non-Bypassable Permissives are not OK, $N"
				    "and the motor is not already starting or running;$N"
				    "* The drive (not simulated) reports that it is faulted;$N"
				    "* There$'s an I/O failure and the motor is NOT being simulated;$N"
				    "* The motor has a Fail to Start that has not been reset;$N"
				    "* The drive is disabled (by Maintenance);$N"
				    "* This instruction instance has a configuration error.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  V4.00.00  2018-07-13:  Replaced start / stop / fwd / rev with start fwd / start rev / stop  #####";
				N: [XIC(Sts_OoS) OTE(Nrdy_OoS) ,XIC(Nrdy_CfgErr) ,[XIO(Inp_IntlkOK) XIO(Sts_BypActive) ,XIO(Inp_NBIntlkOK) ] [[XIC(Wrk_Run) ,XIC(Wrk_Jog) ] XIO(Sts_Hand) OTE(Sts_IntlkTrip) ,OTE(Nrdy_Intlk) ] ,XIO(Wrk_FwdPermOK) XIO(Sts_StartingFwd) XIO(Sts_RunningFwd) [XIO(Wrk_RevPermOK) XIO(Sts_StartingRev) XIO(Sts_RunningRev) ,XIO(Cfg_HasReverse) ] OTE(Nrdy_Perm) ,XIO(Inp_Sim) [XIC(Inp_Faulted) OTE(Sts_DriveFault) OTE(Nrdy_Trip) ,XIO(Inp_Ready) OTE(Nrdy_DriveNR) ] ,XIC(Inp_IOFault) XIO(Inp_Sim) OTE(Sts_IOFault) XIC(Cfg_ShedOnIOFault) OTL(Nrdy_IOFault) ]OTE(Wrk_NotRdy);
				RC: "The drive is NOT READY TO RUN if:$N"
				    "* Interlocks are not OK and not bypassed;$N"
				    "* Non-bypassable Interlocks are not OK;$N"
				    "* Permissives are not OK and not bypassed,$N"
				    "or Non-Bypassable Permissives are not OK, $N"
				    "and the motor is not already starting or running;$N"
				    "* The drive (not simulated) reports that it is faulted;$N"
				    "* There$'s an I/O failure and the motor is NOT being simulated;$N"
				    "* The motor has a Fail to Start that has not been reset;$N"
				    "* The drive is disabled (by Maintenance);$N"
				    "* This instruction instance has a configuration error.";
				N: [XIC(Wrk_NotRdy) ,XIC(Nrdy_PrioStop) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) ]OTE(Sts_NotRdy);
				RC: "The motor is AVAILABLE to be run by automation if it is in PROGRAM$N"
				    "Mode and the $QNot Ready$Q status is cleared.$N"
				    "#####  V4.10.00  2019-03-25:  Changed availability to use input availability from interlocks.  #####";
				N: XIC(Sts_Prog)XIO(Nrdy_PrioStop)XIO(Nrdy_Fail)XIO(Nrdy_CfgErr)XIO(Nrdy_DriveNR)XIO(Nrdy_Trip)XIO(Nrdy_OoS)XIO(Nrdy_Perm)XIO(Nrdy_IOFault)[[XIC(Inp_IntlkOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBIntlkOK) ,XIC(Inp_IntlkAvail) ]OTE(Sts_Available);
				RC: "If we$'re not timing an HMI or programmed Start or Stop,$N"
				    "and there$'s no sealed-in fail-to-start or fail-to-stop,$N"
				    "and if Local Start/Stop Control is permitted,$N"
				    "and if we are using run feedback (not in simulation),$N"
				    "detect a local start or stop transition and track state with it.$N"
				    "(Don$'t track the Start if conditions do not allow the motor to run$N"
				    "or a Jog operation is active.)$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd /  #####$N"
				    "#####  StartRev / Stop / JogFwd / JogRev.  Deleted Cfg_PCmdClear.  #####$N"
				    "##### V4.00.02  2018-10-30:  Corrected handling Allow Local when horn is enabled.  #####";
				N: XIC(Cfg_AllowLocal)XIO(Wrk_StartInhT.TT)XIO(Wrk_StartHornT.TT)XIO(Wrk_StopInhT.TT)XIO(Sts_FailToStart)XIO(Sts_FailToStop)XIC(Cfg_UseRunFdbk)XIO(Inp_Sim)XIO(Wrk_Jog)[XIC(Inp_Running) XIO(Sts_NotRdy) OTL(Wrk_Run) ,XIO(Inp_Running) OTU(Wrk_Run) ,[XIC(Inp_CommandDir) ,XIO(Cfg_HasReverse) ] OTU(Wrk_Rev) ,XIO(Inp_CommandDir) XIC(Cfg_HasReverse) OTL(Wrk_Rev) ];
				RC: "These next several rungs, in priority order, determine whether$N"
				    "the drive should be running, jogging or stopped.$N"
				    "$N"
				    "If a Drive START FORWARD command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is RUN, mark the Drive to RUN FORWARD.$N"
				    "Permissives must be OK or bypassed to start the Drive (Interlocks are checked below...).$N"
				    "The drive must be READY (or in simulation), and the drive can$'t already be jogging.$N"
				    "(Command Sources are mutually exclusive, thus handling the priority.)$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd /  #####$N"
				    "#####  StartRev / Stop / JogFwd / JogRev.  Deleted Cfg_PCmdClear.  #####$N"
				    "#####  Added audible alert prior to commanded start.  #####$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_StartFwd) OTU(OCmd_StartFwd) [XIC(Wrk_OperHas1) ,XIC(Sts_Maint) OTL(Wrk_Retrigger) RES(Wrk_StartRetrigT) ] ,XIC(XCmd_StartFwd) OTU(XCmd_StartFwd) XIC(Wrk_ExtHas1) ,XIC(PCmd_StartFwd) OTU(PCmd_StartFwd) XIC(Wrk_ProgHas1) ,EQU(Inp_OvrdCmd,2) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]XIO(Sts_NotRdy)XIC(Wrk_FwdPermOK)XIO(Wrk_Jog)[[XIO(Wrk_Run) OTL(Wrk_StartHorn) ,XIC(CmdSrc.Sts_Maint) ] OTL(Wrk_Retrigger) RES(Wrk_StartRetrigT) ,OTL(Wrk_Run) OTU(Wrk_Rev) ];
				RC: "These next several rungs, in priority order, determine whether$N"
				    "the drive should be running, jogging or stopped.$N"
				    "$N"
				    "If a Drive START REVERSE command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is RUN, mark the Drive to RUN REVERSE.$N"
				    "Permissives must be OK or bypassed to start the Drive (Interlocks are checked below...).$N"
				    "The drive must be READY (or in simulation), and the drive can$'t already be jogging.$N"
				    "(Command Sources are mutually exclusive, thus handling the priority.)$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd /  #####$N"
				    "#####  StartRev / Stop / JogFwd / JogRev.  Deleted Cfg_PCmdClear.  #####$N"
				    "#####  Added audible alert prior to commanded start.  #####$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_StartRev) OTU(OCmd_StartRev) [XIC(Wrk_OperHas1) ,XIC(Sts_Maint) OTL(Wrk_Retrigger) RES(Wrk_StartRetrigT) ] ,XIC(XCmd_StartRev) OTU(XCmd_StartRev) XIC(Wrk_ExtHas1) ,XIC(PCmd_StartRev) OTU(PCmd_StartRev) XIC(Wrk_ProgHas1) ,EQU(Inp_OvrdCmd,3) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]XIC(Cfg_HasReverse)XIO(Sts_NotRdy)XIC(Wrk_RevPermOK)XIO(Wrk_Jog)[[XIO(Wrk_Run) OTL(Wrk_StartHorn) ,XIC(CmdSrc.Sts_Maint) ] OTL(Wrk_Retrigger) RES(Wrk_StartRetrigT) ,OTL(Wrk_Run) OTL(Wrk_Rev) ];
				RC: "This rung determines if the Drive SHOULD BE JOGGING FORWARD.  This is when:$N"
				    "$N"
				    "* The Operator is requesting to Jog$N"
				    "* The Drive is in OPER or MAINT$N"
				    "* Permissives and Interlocks are OK or bypassed if in OPER$N"
				    "* Non-Bypassable Interlocks and Permissives are OK,$N"
				    "* The drive is Ready (or in simulation), AND$N"
				    "* The drive is not otherwise requested to RUN$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd /  #####$N"
				    "#####  StartRev / Stop / JogFwd / JogRev.  Deleted Cfg_PCmdClear.  #####$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_JogFwd) XIC(Wrk_OperHas1) ,XIC(XCmd_JogFwd) XIC(Wrk_ExtHas1) ]XIO(Sts_NotRdy)XIC(Wrk_FwdPermOK)XIO(Wrk_Run)OTL(Wrk_Jog)OTU(Wrk_Rev)OTL(Wrk_StartHorn);
				RC: "This rung determines if the Drive SHOULD BE JOGGING REVERSE.  This is when:$N"
				    "$N"
				    "* The Operator is requesting to Jog$N"
				    "* The Drive is in OPER or MAINT$N"
				    "* Permissives and Interlocks are OK or bypassed if in OPER$N"
				    "* Non-Bypassable Interlocks and Permissives are OK,$N"
				    "* The drive is Ready (or in simulation), AND$N"
				    "* The drive is not otherwise requested to RUN$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd /  #####$N"
				    "#####  StartRev / Stop / JogFwd / JogRev.  Deleted Cfg_PCmdClear.  #####$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [XIC(OCmd_JogRev) XIC(Wrk_OperHas1) ,XIC(XCmd_JogRev) XIC(Wrk_ExtHas1) ]XIC(Cfg_HasReverse)XIO(Sts_NotRdy)XIC(Wrk_RevPermOK)XIO(Wrk_Run)OTL(Wrk_Jog)OTL(Wrk_Rev)OTL(Wrk_StartHorn);
				RC: "If the drive is being jogged, run the Jog Timer.";
				N: XIC(Wrk_Jog)TON(Wrk_JogT,?,?);
				RC: "If we are sounding the audible start alert (start command accepte) and we lose$N"
				    "the permissive before actually starting the motor, cancel the start$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added audible alert on commanded start.  #####";
				N: XIC(Wrk_StartHorn)[XIO(Wrk_FwdPermOK) XIO(Wrk_Rev) ,XIO(Wrk_RevPermOK) XIC(Wrk_Rev) ]OTU(Wrk_Run)OTU(Wrk_Jog)OTU(OCmd_JogFwd)OTU(OCmd_JogRev)OTU(XCmd_JogFwd)OTU(XCmd_JogFwd)OTU(Wrk_StartHorn);
				RC: "If the drive is changed to a Command Source other than Ext, Oper or Maint,$N"
				    "or if the Jog command goes away,$N"
				    "or if the Jog command does not clear within the Maximum Jog Time,$N"
				    "stop jogging.$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd /  #####$N"
				    "#####  StartRev / Stop / JogFwd / JogRev.  Deleted Cfg_PCmdClear.  #####$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Modified to lock out jog when jog time expires until jog commands are cleared.  #####";
				N: [[XIC(Wrk_OperHas1) XIO(OCmd_JogFwd) XIO(OCmd_JogRev) ,XIC(Wrk_ExtHas1) XIO(XCmd_JogFwd) XIO(XCmd_JogRev) ,XIO(Wrk_OperHas1) XIO(Wrk_ExtHas1) ,XIO(Cfg_HasJog) ] OTU(Wrk_Jog) ,XIC(Wrk_JogT.DN) NEQ(Wrk_JogT.PRE,0) ]OTU(OCmd_JogFwd)OTU(OCmd_JogRev)OTU(XCmd_JogFwd)OTU(XCmd_JogRev);
				RC: "If a Drive STOP command is received in Operator, External,$N"
				    "Program or Maintenance, or if in Override and the Override State$N"
				    "is STOP, mark the Drive TO STOP (jogging or running).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Commands.  #####";
				N: [XIC(OCmd_Stop) OTU(OCmd_Stop) [XIC(Wrk_OperHas1) ,XIC(Cfg_OperStopPrio) XIO(Wrk_OperHas1) OTL(Nrdy_PrioStop) ] ,XIC(XCmd_Stop) OTU(XCmd_Stop) [XIC(Wrk_ExtHas1) ,XIC(Cfg_ExtStopPrio) XIO(Wrk_ExtHas1) OTL(Nrdy_PrioStop) ] ,XIC(PCmd_Stop) OTU(PCmd_Stop) XIC(Wrk_ProgHas1) ,EQU(Inp_OvrdCmd,1) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ,XIC(Wrk_NotRdy) ,[XIC(Nrdy_PrioStop) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) ] XIO(Sts_Hand) ][[XIC(Wrk_Run) ,XIC(Wrk_Jog) ,[XIC(Sts_Oper) ,XIC(Sts_Maint) ] ONS(Wrk_NotRdyONS) ] OTL(Wrk_Retrigger) RES(Wrk_StopRetrigT) ,OTU(Wrk_Run) OTU(Wrk_Jog) OTU(Wrk_StartHorn) ,OTU(OCmd_JogFwd) OTU(OCmd_JogRev) OTU(XCmd_JogFwd) OTU(XCmd_JogRev) ];
				RC: "Higher Priority: HAND wins over other Modes:$N"
				    "If in Hand, have the Drive follow the RunFeedback.";
				N: [XIC(Wrk_Hand) ,XIC(S:FS) ][XIC(Wrk_RunFdbk) OTL(Wrk_Run) ,XIO(Wrk_RunFdbk) OTU(Wrk_Run) ,[XIC(Inp_CommandDir) ,XIO(Cfg_HasReverse) ] OTU(Wrk_Rev) ,XIO(Inp_CommandDir) XIC(Cfg_HasReverse) OTL(Wrk_Rev) ];
				RC: "If anything stops the motor, also stop the pre-start audible.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added audible alert prior to commanded start.  #####";
				N: XIO(Wrk_Run)XIO(Wrk_Jog)OTU(Wrk_StartHorn);
				RC: "============================================================$N"
				    "START HORN TIMER$N"
				    "============================================================$N"
				    "If the horn should be sounding, run the start horn timer.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added audible alert pr";
				N: [XIC(Wrk_Run) ,XIC(Wrk_Jog) ][XIC(Wrk_StartHorn) TON(Wrk_StartHornT,?,?) TON(Wrk_StartHornT,?,?) ,XIC(Wrk_StartHornT.DN) OTU(Wrk_StartHorn) ];
				RC: "============================================================$N"
				    "DRIVE START RETRIGGER AND FAIL TO START DETECTION$N"
				    "============================================================$N"
				    "If the drive SHOULD BE RUNNING, run a Start Timer to check for Fail to Start,$N"
				    "";
				N: [XIC(Wrk_Run) ,XIC(Wrk_Jog) [XIC(Wrk_JogT.TT) ,EQU(Wrk_JogT.PRE,0) ] ]XIO(Wrk_StartHorn)[TON(Wrk_StartT,?,?) ,TON(Wrk_StartRetrigT,?,?) TON(Wrk_StartRetrigT,?,?) ,XIO(Wrk_RunFdbk) TON(Wrk_StartInhT,?,?) ,XIC(Wrk_StartRetrigT.DN) OTU(Wrk_Retrigger) ];
				RC: "If the Start Timer times out and the motor run feedback (or simulated feedback) never showed up,$N"
				    "show the motor as $QFAILED TO START$Q";
				N: XIC(Wrk_StartT.DN)XIO(Wrk_RunFdbk)XIO(Sts_Maint)OTE(Sts_FailToStart);
				RC: "============================================================$N"
				    "DRIVE STOP RETRIGGER AND FAIL TO STOP DETECTION$N"
				    "============================================================$N"
				    "If the drive SHOULD BE STOPPED, run a Stop Timer to check for Fail to Stop,$N"
				    " and";
				N: XIO(Wrk_Run)[XIO(Wrk_Jog) ,XIC(Wrk_JogT.DN) NEQ(Wrk_JogT.PRE,0) ][TON(Wrk_StopT,?,?) ,TON(Wrk_StopRetrigT,?,?) TON(Wrk_StopRetrigT,?,?) ,XIC(Wrk_RunFdbk) TON(Wrk_StopInhT,?,?) ,XIC(Wrk_StopRetrigT.DN) OTU(Wrk_Retrigger) ];
				RC: "If the Stop Timer times out and the motor run feedback (or simulated feedback)$N"
				    "never showed $Qstopped$Q, show the motor as $QFAILED TO STOP$Q";
				N: XIC(Wrk_StopT.DN)XIC(Wrk_RunFdbk)XIO(Sts_Maint)OTE(Sts_FailToStop);
				RC: "============================================================$N"
				    "SHED ON FAULT LOGIC$N"
				    "============================================================$N"
				    "This rung handles latching in of conditions which are configured to cause$N"
				    "drive to shed (de-energize).";
				N: XIC(Sts_FailToStart)XIC(Cfg_ShedOnFailToStart)OTL(Nrdy_Fail);
				RC: "If a shed condition is latched in above, de-energize the drive.$N"
				    "$N"
				    "#####  V4.10.01  2019-10-16:  Corrected handling of Start Horn on shed conditions.  #####";
				N: [XIC(Nrdy_PrioStop) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) ]XIO(Sts_Hand)OTU(Wrk_Run)OTU(Wrk_Jog)OTU(Wrk_StartHorn);
				RC: "============================================================$N"
				    "DEVICE COMMAND ENUMERATED VALUE$N"
				    "============================================================$N"
				    "Val_Cmd is the command currently being processed:$N"
				    "0 = None$N"
				    "1 = Stop$N"
				    "2 = Start Forward$N"
				    "3 = Star";
				N: [CLR(Wrk_Cmd) ,XIO(Wrk_Run) XIO(Wrk_Jog) [XIC(Wrk_RunFdbk) ,XIC(Wrk_Retrigger) ] MOV(1,Wrk_Cmd) ,XIC(Wrk_Run) [XIO(Wrk_RunFdbk) ,XIC(Wrk_Retrigger) ] [XIC(Sts_CommandDir) MOV(2,Wrk_Cmd) ,XIO(Sts_CommandDir) MOV(3,Wrk_Cmd) ] ,XIC(Wrk_Jog) [XIC(Wrk_JogT.TT) ,EQU(Wrk_JogT.PRE,0) ] [XIC(Sts_CommandDir) MOV(4,Wrk_Cmd) ,XIO(Sts_CommandDir) MOV(5,Wrk_Cmd) ] ,MOV(Wrk_Cmd,Val_Cmd) ];
				RC: "============================================================$N"
				    "OUTPUT GENERATION$N"
				    "============================================================$N"
				    "If the Drive is NOT SIMULATED, generate the appropriate outputs for the Drive.$N"
				    "$N"
				    "If the Drive should be running";
				N: XIO(Inp_Sim)XIO(Sts_Hand)[XIO(Sts_NotRdy) XIO(Wrk_StartHorn) [XIC(Wrk_Run) [OTE(Out_Run) ,[XIO(Wrk_RunFdbk) ,XIC(Wrk_Retrigger) ] OTE(Out_Start) ] ,XIC(Wrk_Jog) [XIC(Wrk_JogT.TT) ,EQU(Wrk_JogT.PRE,0) ] OTE(Out_Jog) ] ,XIO(Wrk_Run) [XIO(Wrk_Jog) ,XIC(Wrk_JogT.DN) NEQ(Wrk_JogT.PRE,0) ] [XIC(Wrk_RunFdbk) ,XIC(Wrk_Retrigger) ] OTE(Out_Stop) ,XIC(Wrk_StartHorn) OTE(Out_Horn) ,XIO(Wrk_Rev) OTE(Out_Fwd) ,XIC(Wrk_Rev) OTE(Out_Rev) ];
				RC: "Check the selected speed reference against the configured Maximum and Minimum$N"
				    "allowed reference limits and ensure the speed is within limits.$N"
				    "Be sure the speed reference is not negative.  This object supports reversing$N"
				    "by command only; negative speed reference is NOT supported!";
				N: [GRT(Wrk_SpeedRef,Cfg_MaxSpdRef) MOV(Cfg_MaxSpdRef,Wrk_SpeedRef) ,LES(Wrk_SpeedRef,Cfg_MinSpdRef) MOV(Cfg_MinSpdRef,Wrk_SpeedRef) ,LES(Wrk_SpeedRef,0.0) CLR(Wrk_SpeedRef) ]OTE(Sts_SpeedLimited);
				RC: "If the drive is NOT simulated and its scaling config is valid, scale the$N"
				    "final speed reference from engineering units to Raw (drive) Units.$N"
				    "$N"
				    "If the drive is SIMULATED, set the Speed Reference output to ZERO.";
				N: [XIO(Inp_Sim) XIO(Err_RefEU) CPT(Out_SpeedRef,(Wrk_SpeedRef-Cfg_SpeedRefEUMin)*(Cfg_SpeedRefRawMax-Cfg_SpeedRefRawMin)/(Cfg_SpeedRefEUMax-Cfg_SpeedRefEUMin)+Cfg_SpeedRefRawMin) ,[XIC(Inp_Sim) ,XIC(Err_RefEU) ] CLR(Out_SpeedRef) ];
				RC: "If NOT in simulation, the Output Datalink exists, and its scaling is valid,$N"
				    "the working value is scaled to generate Out_Datalink.$N"
				    "If in simulation, the Output Datalink does not exist, or its scaling is invalid,$N"
				    "Out_Datalink is cleared.";
				N: [XIO(Inp_Sim) XIC(Cfg_HasOutDatalink) XIO(Err_OutDLEU) CPT(Out_Datalink,(Wrk_OutDatalink-Cfg_OutDatalinkEUMin)*(Cfg_OutDatalinkRawMax-Cfg_OutDatalinkRawMin)/(Cfg_OutDatalinkEUMax-Cfg_OutDatalinkEUMin)+Cfg_OutDatalinkRawMin) ,[XIC(Inp_Sim) ,XIO(Cfg_HasOutDatalink) ,XIC(Err_OutDLEU) ] CLR(Out_Datalink) ];
				RC: "If the Output Datalink exists and its scaling is valid, the working value is copied to Val_OutDatalink.$N"
				    "If the Output Datalink does not exist, or its scaling is invalid, Val_OutDatalink is cleared.";
				N: [XIC(Cfg_HasOutDatalink) XIO(Err_OutDLEU) MOV(Wrk_OutDatalink,Val_OutDatalink) ,[XIO(Cfg_HasOutDatalink) ,XIC(Err_OutDLEU) ] CLR(Val_OutDatalink) ];
				RC: "Val_SpeedRef (commanded speed)$N"
				    "$N"
				    "Based on Mode and Tracking settings, copy the Speed$N"
				    "Reference Value back into the Operator and Program Settings.$N"
				    "$N"
				    "#####  Changed P_Mode to P_CmdSrc. Added External Command Source and Commands.  #####";
				N: [MOV(Wrk_SpeedRef,Val_SpeedRef) ,XIC(Cfg_SetTrack) [[XIO(Sts_Ovrd) XIO(Sts_Hand) ,XIC(Cfg_SetTrackOvrdHand) ] MOV(Val_SpeedRef,PSet_SpeedRef) MOV(Val_SpeedRef,OSet_SpeedRef) MOV(Val_SpeedRef,XSet_SpeedRef) ,MOV(Val_OutDatalink,PSet_OutDatalink) MOV(Val_OutDatalink,OSet_OutDatalink) MOV(Val_OutDatalink,XSet_OutDatalink) ] ];
				RC: "This rung generates the Starting, Running, Stopping, Stopped and Jogging Status bits.$N"
				    "$N"
				    "If the Drive is commanded to run (Output on) and the feedback doesn$'t yet show it running,$N"
				    "the Drive is STARTING.$N"
				    "$N"
				    "If the Drive is commanded to run (Output on) and the feedback shows it running,$N"
				    "the Drive is RUNNING.$N"
				    "$N"
				    "If the Drive is commanded to stoop (Output off) and the feedback still shows it running,$N"
				    "the Drive is STOPPING.$N"
				    "$N"
				    "If the Drive is commanded to stop (Output off) and the feedback shows it has stopped,$N"
				    "the Drive is STOPPED.$N"
				    "$N"
				    "If the Drive is commanded to jog, show the status as JOGGING.$N"
				    "$N"
				    "If the audible alert is active, show the Status as HORN.$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd / StartRev / Stop / JogFwd / JogRev  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added Horn Status.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Modified to lock out jog when jog time expires until jog commands are cleared.  #####";
				N: [XIO(Wrk_StartHorn) XIC(Wrk_Run) XIO(Wrk_Jog) [XIO(Wrk_RunFdbk) [XIC(Sts_CommandDir) OTE(Sts_StartingFwd) ,XIO(Sts_CommandDir) OTE(Sts_StartingRev) ] ,XIC(Wrk_RunFdbk) [XIC(Sts_ActualDir) OTE(Sts_RunningFwd) ,XIO(Sts_ActualDir) OTE(Sts_RunningRev) ] ] ,XIO(Wrk_Run) [XIO(Wrk_Jog) ,XIC(Wrk_JogT.DN) NEQ(Wrk_JogT.PRE,0) ] [XIC(Wrk_RunFdbk) [XIC(Sts_ActualDir) OTE(Sts_StoppingFwd) ,XIO(Sts_ActualDir) OTE(Sts_StoppingRev) ] ,XIO(Wrk_RunFdbk) OTE(Sts_Stopped) ] ,XIO(Wrk_StartHorn) XIC(Wrk_Jog) [XIC(Wrk_JogT.TT) ,EQU(Wrk_JogT.PRE,0) ] [XIC(Sts_CommandDir) OTE(Sts_JoggingFwd) ,XIO(Sts_CommandDir) OTE(Sts_JoggingRev) ] ,XIC(Wrk_StartHorn) OTE(Sts_Horn) ];
				RC: "============================================================$N"
				    "OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "Ready to Start if in Operator Manual, Stopped, and Permissives and Interlocks are OK.$N"
				    "$N"
				    "Ready to Stop if";
				N: XIO(Wrk_NotRdy)[XIO(Sts_NotRdy) ,XIC(Cfg_OCmdResets) ][XIC(Wrk_OperHas1) [XIC(Inp_Ready) ,XIC(Inp_Sim) ] [[XIC(Sts_Stopped) ,XIC(Sts_Maint) [XIC(Sts_RunningFwd) ,XIC(Sts_RunningRev) ] ] [XIC(Wrk_FwdPermOK) OTE(ORdy_StartFwd) ,XIC(Wrk_RevPermOK) OTE(ORdy_StartRev) ] ,XIC(Cfg_HasJog) XIO(Wrk_Run) [XIC(Wrk_FwdPermOK) OTE(ORdy_JogFwd) ,XIC(Wrk_RevPermOK) OTE(ORdy_JogRev) ] ] ,[XIC(Wrk_OperHas1) ,XIC(Cfg_OperStopPrio) ] XIO(Sts_StoppingFwd) XIO(Sts_StoppingRev) OTE(ORdy_Stop) ];
				RC: "============================================================$N"
				    "REMAINING DRIVE VALUES AND STATUS$N"
				    "============================================================$N"
				    "This rung copies a number of values from the drive directly$N"
				    "to their final Value and Status out";
				N: NEQ(Inp_LastFaultCode,0)MOV(Inp_LastFaultCode,Val_LastFaultCode);
				RC: "If the drive is Faulted, this rung finds the Fault Description for$N"
				    "the given Fault Code within the Reference Fault Code List $N"
				    "(In/Out Parameter).  (The same Fault Code List tag$N"
				    "can be referenced by ALL instances of this instruction$N"
				    "that use the fault code -- same drive class!!!)$N"
				    "$N"
				    "1.  Find the number of entries in the Fault Code List (Array SIZE).$N"
				    "2.  Search (FSC) the Fault Code List for a matching Code.$N"
				    "3.  If found, copy the corresponding Description to Val_FaultDesc.$N"
				    "4.  If NOT found, copy list entry zero ($QNo Help Available for this code$Q).";
				N: XIC(Sts_DriveFault)[RES(Wrk_FaultDescFSC) SIZE(Ref_FaultCodeList,0,Wrk_FaultDescFSC.LEN) ,FSC(Wrk_FaultDescFSC,?,?,ALL,Ref_FaultCodeList[Wrk_FaultDescFSC.POS].Code=Inp_LastFaultCode) ,XIC(Wrk_FaultDescFSC.FD) COP(Ref_FaultCodeList[Wrk_FaultDescFSC.POS].Desc,Val_FaultDesc,1) ,XIO(Wrk_FaultDescFSC.FD) COP(Ref_FaultCodeList[0].Desc,Val_FaultDesc,1) ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1), EXCEPT:$N"
				    "* If the motor DOES NOT HAVE";
				N: [OTL(IntlkTrip.PCfg_AllowExist) OTL(DriveFault.PCfg_AllowExist) OTL(IOFault.PCfg_AllowExist) ,[XIC(Cfg_HasRunFdbk) ,XIC(Cfg_HasSpeedFdbk) ] OTE(FailToStart.PCfg_AllowExist) OTE(FailToStop.PCfg_AllowExist) ];
				RC: "Let the Alarm instance know if this object is taken Out of Service$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Now using P_CmdSrc, including Out of Service.  #####";
				N: XIC(CmdSrc.Sts_OoS)OTE(FailToStart.Inp_OoS)OTE(FailToStop.Inp_OoS)OTE(IntlkTrip.Inp_OoS)OTE(DriveFault.Inp_OoS)OTE(IOFault.Inp_OoS);
				RC: "Handle Motor Failed to Start Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(FailToStart);
				RC: "Handle Motor Failed to Stop Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(FailToStop);
				RC: "Handle Interlock Trip Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IntlkTrip);
				RC: "Handle Drive Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(DriveFault);
				RC: "Handle I/O Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).";
				N: [XIC(FailToStart.Sts_AlmInh) ,XIC(FailToStop.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(DriveFault.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Bad Raw Scaling configs$N"
				    "Bad Engineering Units Scaling configs$N"
				    "Bad Min or Max Speed Reference clamp limit$N"
				    "Bad simulation speed ramp time$N"
				    "Bad timer config from (rung above)$N"
				    "Bad Alarm config (from P_Alarm)$N"
				    "Bad Cfg_OperKeep / Cfg_ProgKeep config$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Modified to allow the special case where min and max clamping  #####$N"
				    "#####  limits (speed or output datalink) can be EQUAL (clamp at a specific value).  #####$N"
				    "#####  Changed delay / time configuration items to REAL seconds.  #####";
				N: [XIC(Nrdy_CfgErr) ,[XIC(FailToStart.Sts_Err) ,XIC(FailToStop.Sts_Err) ,XIC(IntlkTrip.Sts_Err) ,XIC(DriveFault.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "Val_Sts is the current device status, as determined by this AOI,$N"
				    "based on its knowledge of commands executed and feedback.$N"
				    "(This is the status that should be monitored by, for example, FT Historian.)$N"
				    "0 = Powerup / Unknown (in Hand but having no feedback, for example)$N"
				    "0 = Powerup / Unknown$N"
				    "1 = Stopped$N"
				    "2 = Running Forward$N"
				    "3 = Running Reverse$N"
				    "4 = Running Slow$N"
				    "5 = Starting Forward$N"
				    "6 = Starting Reverse$N"
				    "7 = Starting Slow$N"
				    "8 = Jogging Forward$N"
				    "9 = Jogging Reverse$N"
				    "10 = Stopping$N"
				    "14 = Horn$N"
				    "$N"
				    "Val_Fault is the current device fault status, as determined by this AOI,$N"
				    "based on its knowledge of commands executed and feedback.$N"
				    "(This is the fault status that should be monitored by, for example, FT Historian.)$N"
				    "0 = None$N"
				    "16 = Fail to Start$N"
				    "17 = Fail to Stop$N"
				    "18 = Drive Fault$N"
				    "32 = I/O Fault (from Input)$N"
				    "34 = Configuration Error$N"
				    "$N"
				    "#####  V4.00.00 2018-07-13:  Changed Start / Stop / Jog / Fwd / Rev to StartFwd / StartRev / Stop / JogFwd / JogRev  #####$N"
				    "#####  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added Horn Status.  #####";
				N: [CLR(Wrk_Sts) CLR(Wrk_Fault) ,XIC(Sts_Stopped) MOV(1,Wrk_Sts) ,XIC(Sts_RunningFwd) MOV(2,Wrk_Sts) ,XIC(Sts_RunningRev) MOV(3,Wrk_Sts) ,XIC(Sts_StartingFwd) MOV(5,Wrk_Sts) ,XIC(Sts_StartingRev) MOV(6,Wrk_Sts) ,XIC(Sts_JoggingFwd) MOV(8,Wrk_Sts) ,XIC(Sts_JoggingRev) MOV(9,Wrk_Sts) ,[XIC(Sts_StoppingFwd) ,XIC(Sts_StoppingRev) ] MOV(10,Wrk_Sts) ,XIC(Sts_Horn) MOV(14,Wrk_Sts) ,XIC(Nrdy_Fail) MOV(16,Wrk_Fault) ,XIC(Sts_FailToStop) MOV(17,Wrk_Fault) ,XIC(Sts_DriveFault) MOV(18,Wrk_Fault) ,[XIC(Sts_IOFault) ,XIC(Nrdy_IOFault) ] MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed go";
				N: [CLR(Wrk_SrcQ) ,XIC(Cfg_UseSpeedFdbk) MOV(1,Wrk_SrcQ) ,[XIO(Cfg_HasRunFdbk) ,XIO(Cfg_HasSpeedFdbk) ] MOV(2,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,[XIC(Err_FdbkRaw) ,XIC(Err_FdbkEU) ] MOV(35,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration$N"
				    "$N"
				    "If the drive is using run feedback (for state) and has speed feedback, all is live and good.$N"
				    "If the drive is using speed feedback to determine run state, state is assumed good.$N"
				    "If the drive does not have speed feedback, speed is no-feedback assumed good.";
				N: MOV(SrcQ_IO,SrcQ);
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for r";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) ,GRT(FailToStart.Val_Notify,Wrk_Notify) MOV(FailToStart.Val_Notify,Wrk_Notify) ,GRT(FailToStop.Val_Notify,Wrk_Notify) MOV(FailToStop.Val_Notify,Wrk_Notify) ,GRT(IntlkTrip.Val_Notify,Wrk_Notify) MOV(IntlkTrip.Val_Notify,Wrk_Notify) ,GRT(DriveFault.Val_Notify,Wrk_Notify) MOV(DriveFault.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(FailToStart.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(FailToStop.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IntlkTrip.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(DriveFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTE(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_Notify,Val_NotifyAll) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "This rung identifies:$N"
				    "* if a latched Shed condition requires a reset in order to run the motor;$N"
				    "* if that reset or any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(FailToStart.Sts_RdyAck) ,XIC(FailToStop.Sts_RdyAck) ,XIC(IntlkTrip.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ,XIC(DriveFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(FailToStart.Sts_RdyReset) ,XIC(FailToStop.Sts_RdyReset) ,XIC(IntlkTrip.Sts_RdyReset) ,XIC(DriveFault.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ,XIC(Nrdy_Trip) ,XIC(Nrdy_PrioStop) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) XIO(Sts_IOFault) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownership, set drive to STOP, clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, set the Ownership to NO OWNER (0).";
				N: CLR(PSet_Owner)CLR(Val_Owner);
				RC: "============================================================$N"
				    "$QASPECT$Q OWNERSHIP$N"
				    "============================================================$N"
				    "Using the Command Source determined above, and the Cfg_OperKeep, Cfg_ProgKeep and$N"
				    "Cfg_ExtKeep bits, determin";
				N: [[XIC(Cfg_OperKeep.0) XIC(Cfg_ProgKeep.0) ,XIC(Cfg_OperKeep.0) XIC(Cfg_ExtKeep.0) ,XIC(Cfg_ExtKeep.0) XIC(Cfg_ProgKeep.0) ] OTU(Cfg_OperKeep.0) OTU(Cfg_ProgKeep.0) OTU(Cfg_ExtKeep.0) ,[XIC(Cfg_OperKeep.1) XIC(Cfg_ProgKeep.1) ,XIC(Cfg_OperKeep.1) XIC(Cfg_ExtKeep.1) ,XIC(Cfg_ExtKeep.1) XIC(Cfg_ProgKeep.1) ] OTU(Cfg_OperKeep.1) OTU(Cfg_ProgKeep.1) OTU(Cfg_ExtKeep.1) ,[XIC(Cfg_OperKeep.3) XIC(Cfg_ProgKeep.3) ,XIC(Cfg_OperKeep.3) XIC(Cfg_ExtKeep.3) ,XIC(Cfg_ExtKeep.3) XIC(Cfg_ProgKeep.3) ] OTU(Cfg_OperKeep.3) OTU(Cfg_ProgKeep.3) OTU(Cfg_ExtKeep.3) ];
				RC: "$QLurking$Q Commands not handled elsewhere are cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Commands.  #####";
				N: [OTU(OCmd_StartFwd) OTU(OCmd_StartRev) OTU(OCmd_Stop) ,OTU(OCmd_JogFwd) OTU(OCmd_JogRev) ,OTU(XCmd_StartFwd) OTU(XCmd_StartRev) OTU(XCmd_Stop) ,OTU(XCmd_JogFwd) OTU(XCmd_JogRev) ,OTU(PCmd_StartFwd) OTU(PCmd_StartRev) OTU(PCmd_Stop) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,CLR(Inp_OvrdCmd) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_StartFwd) OTU(ORdy_StartRev) OTU(ORdy_Stop) ,OTU(ORdy_JogFwd) OTU(ORdy_JogRev) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) OTU(Sts_RdyAck) OTU(ORdy_SpeedRef) ];
				RC: "On powerup (prescan), set drive to stop.";
				N: OTU(Wrk_Run)OTU(Wrk_Jog);
				RC: "Reset the fault condition Shed latches.";
				N: OTU(Nrdy_PrioStop)OTU(Nrdy_Fail)OTU(Nrdy_IOFault);
				RC: "Outputs are cleared on Prescan.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-13:  Added Autible Alert on start.  #####";
				N: [OTU(Out_Start) OTU(Out_Stop) OTU(Out_Run) OTU(Out_Jog) ,OTU(Out_Fwd) OTU(Out_Rev) OTU(Out_ClearFault) OTU(Out_Horn) ,CLR(Out_SpeedRef) CLR(Out_Datalink) ];
				RC: "Show the enumerated drive command as NONE.$N"
				    "Show the enumerated drive feedback as NONE.$N"
				    "Show the enumerated drive status as POWERUP / UNKNOWN.";
				N: CLR(Val_Cmd)CLR(Val_Fdbk)CLR(Val_Sts);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_ValveC (Revision := "4.10",
	                                        RevisionExtension := ".01 Release",
	                                        RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                        Vendor := "Rockwell Automation",
	                                        ExecutePrescan := Yes,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := Yes,
	                                        CreatedDate := "2008-03-27T19:50:50.098Z",
	                                        CreatedBy := "Not Available",
	                                        EditedDate := "2023-03-15T17:10:09.883Z",
	                                        EditedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                        SoftwareRevision := "v32.03",
	                                        AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction controls an Analog or Pulse Output Valve with$Nanalog or simulated position feedback and provides:$N$N*  Program and Operator entry of target position in Percent Open$N*  Ramping of position to target at specified Rate of Change (%/sec)$N*  Scaling of Position Feedback input from Raw (I/O card) Units to percent$N*  Monitoring of Interlock conditions which cause output to shed$N*  Configurable shed to HOLD or to configured position$N*  Monitoring of I/O communication faults$N*  Alarms for Interlock Trip, Actuator Fault, I/O Fault$N*  Operation in Hand, Maintenance, Override, Program and Operator Modes$N*  $QAvailable$Q status for use by automation logic to know whether valve$N      can be controlled by other objects.$N$NCommand Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$NAlarms are provided by P_Alarm Add-On Instruction instances.$NCommand Sources: Operator, Program, External, Override, Maintenance, Out of Service, Hand$N$NConfiguration notes:$N   If Max ON Time is less than 0 or greater than the Cycle Time$N        it is set to the Cycle Time.$N   If Min ON Time is less than 0 or greater than the Max ON Time$N        it is set to zero.$N   If Deadtime is less than 0 or greater than the Cycle Time,$N        it is set to zero.$N   Bump Time must be within the Min ON Time and Max ON Time.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* No changes, uprevved because P_CmdSrc 4.10.01 is used.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Added option to clamp to a full/empty range when we have limit switches.$N* Changed availability to use input availability from interlocks.$N* Updated to P_CmdSrc V4.10.00.$N* Corrected parameter External Access.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-11)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for associated object(s).$N* Changed $QMode$Q to $QCommand Source$Q using P_CmdSrc 4.00.00.$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* Added unacked alarm count.$N* Added  configurable decimal places for display on HMI.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N* Added option for no position feedback (simulated with hysteresis).$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_PosFdbk : REAL (Description := "Position Feedback from Valve (in Raw Input units)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0.00000000e+000);
			Inp_OpenLS : BOOL (Description := "Valve Open Limit Switch 1=confirmed fully open",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 0);
			Inp_ClosedLS : BOOL (Description := "Valve Closed Limit Switch 1=confirmed fully closed",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := 0);
			Inp_ActuatorFault : BOOL (Description := "Valve Actuator Fault (overload, etc.), 0=OK, 1=Fault)",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := Yes,
			                             DefaultData := 0);
			Inp_IntlkOK : BOOL (Description := "1=Interlocks OK, Pulse Output Valve can be moved",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBIntlkOK : BOOL (Description := "1=Non-Bypassable Interlocks OK, Pulse Output Valve can be moved",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkAvail : BOOL (Description := "1 = Interlock Availibility OK",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Inp_IOFault : BOOL (Description := "Input / Output Communication Status 0=OK, 1=fail",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=I/O are being simulated, set output CV to 0.0, ignore I/O Fault",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Hand OF CmdSrc.Inp_Hand (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_Ovrd OF CmdSrc.Inp_Ovrd (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_OvrdCV : REAL (Description := "CV target in Override Mode$N(CV EU)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0.00000000e+000);
			Inp_ExtInh OF CmdSrc.Inp_ExtInh (Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_Reset : BOOL (Description := "1=Reset shed latches and cleared alarms",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_ShedHold : BOOL (Description := "1=Hold Output on Interlock or bad PV, 0=Go to Cfg_IntlkCV",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_ShedOnIOFault : BOOL (Description := "1=Take shed action (hold or interlock CV) on I/O Fault",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_SkipRoCLim : BOOL (Description := "1=Skip RoC Limiting in Intlk, Maint, Ovrd modes",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_SetTrack : BOOL (Description := "1=PSets track OSets in Oper, OSets track PSets in Prog, 0=no tracking",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1);
			Cfg_SetTrackOvrdHand : BOOL (Description := "1=Prog/Oper Settings track Override/Hand CV",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                DefaultData := 0);
			Cfg_HasPosFdbk : BOOL (Description := "1=Valve provides an analog position feedback, 0=simulate feedback",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 1);
			Cfg_HasOpenLS : BOOL (Description := "1=Valve provides an Open Limit Switch signal",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_HasClosedLS : BOOL (Description := "1=Valve provides a Closed Limit Switch signal",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_UseOpenLS : BOOL (Description := "1=Valve Open LS should be used for open/closed status",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_UseClosedLS : BOOL (Description := "1=Valve Closed LS should be used for open/closed status",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_LSFail : BOOL (Description := "1=both switches ON=fail, 0=both switches OFF=fail",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1);
			Cfg_ClampPosToLS : BOOL (Description := "1=Clamps Val_Pos to EUMin/Max when on a Limit Switch",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Cfg_HasIntlkObj : BOOL (Description := "1=Tells HMI a P_Intlk is connected to Inp_Intlk",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasCVNav : BOOL (Description := "1=Tells HMI to enable navigation to a connected CV object",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_OvrdIntlk : BOOL (Description := "1=Override ignores Bypassable Intlk; 0=always use Intlk",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_DecPlcs : DINT (Description := "Number of decimal places for CV display (0..6)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Cfg_HasIntlkTripAlm OF IntlkTrip.Cfg_Exists (Description := "1=Interlock Trip Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasActuatorFaultAlm OF ActuatorFault.Cfg_Exists (Description := "1=Actuator Fault Alarm exists and will be checked",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=I/O Fault Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_IntlkTripResetReqd OF IntlkTrip.Cfg_ResetReqd (Description := "1=Reset required to clear Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_ActuatorFaultResetReqd OF ActuatorFault.Cfg_ResetReqd (Description := "1=Reset required to clear Actuator Fault Alarm",
			                                      Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Reset required to clear I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IntlkTripAckReqd OF IntlkTrip.Cfg_AckReqd (Description := "1=Acknowledge required for Interlock Trip Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_ActuatorFaultAckReqd OF ActuatorFault.Cfg_AckReqd (Description := "1=Acknowledge required for Actuator Fault Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Acknowledge required for I/O Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_IntlkTripSeverity OF IntlkTrip.Cfg_Severity (Description := "Interlock Trip Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_ActuatorFaultSeverity OF ActuatorFault.Cfg_Severity (Description := "Actuator Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                     Usage := Input,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "I/O Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_MinCV : REAL (Description := "Minimum CV (in CV EU, for limiting)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0.00000000e+000);
			Cfg_MaxCV : REAL (Description := "Maximum CV (in CV EU, for limiting)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 1.00000000e+002);
			Cfg_CVRoCLimInc : REAL (Description := "CV Rate of Change Limit, Increasing, (EU/sec, 0=unlimited)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0.00000000e+000);
			Cfg_CVRoCLimDec : REAL (Description := "CV Rate of Change Limit, Decreasing, (EU/sec, 0=unlimited)",
			                           Usage := Input,
			                           RADIX := Float,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0.00000000e+000);
			Cfg_IntlkCV : REAL (Description := "CV (target in EU) when interlocked (if not Cfg_ShedHold)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_CVEUMin : REAL (Description := "CV Minimum in Engineering Units (for scaling)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0.00000000e+000);
			Cfg_CVEUMax : REAL (Description := "CV Maximum in Engineering Units (for scaling)",
			                       Usage := Input,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1.00000000e+002);
			Cfg_CVRawMin : REAL (Description := "CV Minimum in I/O (raw) Units (for scaling)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Cfg_CVRawMax : REAL (Description := "CV Maximum in I/O (raw) Units (for scaling)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+002);
			Cfg_FdbkRawMin : REAL (Description := "Position Feedback Minimum in raw input units (for scaling)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			Cfg_FdbkRawMax : REAL (Description := "Position Feedback Maximum in raw input units (for scaling)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 1.00000000e+002);
			Cfg_CycleT : REAL (Description := "Open and Close Pulse Output overall period (s)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1.00000000e+001);
			Cfg_OpenRate : REAL (Description := "Rate at which valve moves when opening (CV EU/sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 1.00000000e+000);
			Cfg_CloseRate : REAL (Description := "Rate at which valve moves when closing (CV EU/sec)",
			                         Usage := Input,
			                         RADIX := Float,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 1.00000000e+000);
			Cfg_MaxOnT : REAL (Description := "Open and Close Pulse Output maximum ON time (s)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 5.00000000e+000);
			Cfg_MinOnT : REAL (Description := "Open and Close Pulse Output minimum ON time (s)",
			                      Usage := Input,
			                      RADIX := Float,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1.00000000e+000);
			Cfg_BumpT : REAL (Description := "Time to bump valve open or closed (by Oper) when Fdbk Bad (sec)",
			                     Usage := Input,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0.00000000e+000);
			Cfg_Deadtime : REAL (Description := "Additional time on first pulse after stop or direction change",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0.00000000e+000);
			Cfg_MaxClosedPos : REAL (Description := "Position above which valve is assumed open if limit switches not used",
			                            Usage := Input,
			                            RADIX := Float,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0.00000000e+000);
			PSet_CV : REAL (Description := "Program Setting of Controlled Variable (output) (CV EU)",
			                   Usage := Input,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0.00000000e+000);
			PSet_Owner : DINT (Description := "Program Owner Request ID (non-zero) or Release (zero)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			XSet_CV : REAL (Description := "External Setting of Controlled Variable (output) (CV EU)",
			                   Usage := Input,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0.00000000e+000);
			PCmd_Prog OF CmdSrc.PCmd_Prog (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Oper OF CmdSrc.PCmd_Oper (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Lock OF CmdSrc.PCmd_Lock (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Unlock OF CmdSrc.PCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Normal OF CmdSrc.PCmd_Normal (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Reset : BOOL (Description := "Program Command to reset shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_IntlkTripAck OF IntlkTrip.PCmd_Ack (Description := "Program Command to Acknowledge Interlock Trip Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_IntlkTripSuppress OF IntlkTrip.PCmd_Suppress (Description := "Program Command to Suppress Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IntlkTripUnsuppress OF IntlkTrip.PCmd_Unsuppress (Description := "Program Command to Unsuppress Interlock Trip Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripUnshelve OF IntlkTrip.PCmd_Unshelve (Description := "Program Command to Unshelve Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_ActuatorFaultAck OF ActuatorFault.PCmd_Ack (Description := "Program Command to Acknowledge Actuator Fault Alarm",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			PCmd_ActuatorFaultSuppress OF ActuatorFault.PCmd_Suppress (Description := "Program Command to Suppress Actuator Fault Alarm",
			                                      Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No);
			PCmd_ActuatorFaultUnsuppress OF ActuatorFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress Actuator Fault Alarm",
			                                        Usage := Input,
			                                        RADIX := Decimal,
			                                        Required := No,
			                                        Visible := No);
			PCmd_ActuatorFaultUnshelve OF ActuatorFault.PCmd_Unshelve (Description := "Program Command to Unshelve Actuator Fault Alarm",
			                                      Usage := Input,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			MCmd_Rel OF CmdSrc.MCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			OCmd_Unlock OF CmdSrc.OCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			XCmd_Acq OF CmdSrc.XCmd_Acq (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Rel OF CmdSrc.XCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Reset : BOOL (Description := "External Command to reset shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Out_CV : REAL (Description := "CV Output in Raw (I/O Card) Units",
			                  Usage := Output,
			                  RADIX := Float,
			                  Required := No,
			                  Visible := Yes,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0.00000000e+000);
			Out_Open : BOOL (Description := "Pulse Output to drive valve Open",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Out_Close : BOOL (Description := "Pulse Output to drive valve closed",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_Pos : REAL (Description := "Valve actual position from feedback (CV EU)",
			                   Usage := Output,
			                   RADIX := Float,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0.00000000e+000);
			Val_CVSet : REAL (Description := "Value of selected CV Setting (before rate limiting, CV EU)",
			                     Usage := Output,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0.00000000e+000);
			Val_CVOut : REAL (Description := "Value of CV output (after clamping and ramping) (CV EU)",
			                     Usage := Output,
			                     RADIX := Float,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0.00000000e+000);
			Val_CVEUMin : REAL (Description := "Minimum of scaled range = MIN (Cfg_CVEUMin, Cfg_CVEUMax)",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0.00000000e+000);
			Val_CVEUMax : REAL (Description := "Maximum of scaled range = MAX (Cfg_CVEUMin, Cfg_CVEUMax)",
			                       Usage := Output,
			                       RADIX := Float,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 1.00000000e+002);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Fdbk : DINT (Description := "Device Feedback 0=Moving, 1=Closed, 2=Opened, 3=Limit Switch Failure",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Val_Sts : DINT (Description := "0=AtTarget, 1=RampClose, 2=RampOpen, 3=Clamp@Min, 4=Clamp@Max, 5=BumpClose, 6=BumpOpen",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=none, 32=I/OFault, 34=CfgErr",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + channel (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_Owner : DINT (Description := "Current Object Owner ID (0=not owned)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_CVInfNaN : BOOL (Description := "1=Selected CV is Infinite or Not A Number (1.$$, 1.#NaN)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_PosInfNaN : BOOL (Description := "1=Inp_PosFdbk is Infinite or Not A Number (1.$$, 1.#NaN)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_BumpOpen : BOOL (Description := "1=Bump Open Requested or Active",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_BumpClose : BOOL (Description := "1=Bump Close Requested or Active",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Ramping : BOOL (Description := "1=CV is ramping to target",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_Clamped : BOOL (Description := "1=CV Set is clamped at CVMin or CVMax",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_SkipRoCLim : BOOL (Description := "1=Rate of Change Limiting was skipped this scan (Maint, Ovrd, Intlk, Hand)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_Active : BOOL (Description := "1=CV is greater than Cfg_MaxClosedPos, show valve symbol as $Qopened$Q",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Available : BOOL (Description := "1=Pulse Output Valve available for control by automation (Prog)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Bypass : BOOL (Description := "1=Bypassable Interlocks are Bypassed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_BypActive : BOOL (Description := "1=Bypassing Active (Bypassed or Maintenance)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_LSFail : BOOL (Description := "1=Limit Switch Overlap Failure",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_NotRdy : BOOL (Description := "1=Device Not Ready, see detail bits for reason",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_CfgErr : BOOL (Description := "1=Device Not Ready: Configuration Error",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Nrdy_Intlk : BOOL (Description := "1=Device Not Ready: Interlock Not OK",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_IOFault : BOOL (Description := "1=Device Not Ready: I/O Fault (Shed Requires Reset)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_OoS : BOOL (Description := "1=Device Not Ready: Device is Out of Service",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=Device has a Maintenance Bypass function active",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=One or more Alarms Shelved, Disabled or Suppressed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Limit : BOOL (Description := "1=Error in Config: CV Limits swapped",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_EU : BOOL (Description := "1=Error in Config: Scaled CV EU Min = Max",
			                  Usage := Output,
			                  RADIX := Decimal,
			                  Required := No,
			                  Visible := No,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			Err_Raw : BOOL (Description := "1=Error in Config: Raw Output Scaling Min = Max",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Fdbk : BOOL (Description := "1=Error in Config: Raw Feedback Scaling Min = Max",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Invalid Timer Preset (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Hand OF CmdSrc.Sts_Hand (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OoS OF CmdSrc.Sts_OoS (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Maint OF CmdSrc.Sts_Maint (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only);
			Sts_Ovrd OF CmdSrc.Sts_Ovrd (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_Ext OF CmdSrc.Sts_Ext (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Prog OF CmdSrc.Sts_Prog (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_ProgLocked OF CmdSrc.Sts_ProgLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Oper OF CmdSrc.Sts_Oper (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OperLocked OF CmdSrc.Sts_OperLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Normal OF CmdSrc.Sts_Normal (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_ExtReqInh OF CmdSrc.Sts_ExtReqInh (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_ProgReqInh OF CmdSrc.Sts_ProgReqInh (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_MAcqRcvd OF CmdSrc.Sts_MAcqRcvd (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_IntlkTrip OF IntlkTrip.Inp (Description := "1=Status: CV held or forced by interlock NOT OK (1-shot)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_IntlkTrip OF IntlkTrip.Alm (Description := "1=Alarm: CV held or forced by interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_IntlkTrip OF IntlkTrip.Ack (Description := "1=Interlock Trip Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_IntlkTripDisabled OF IntlkTrip.Disabled (Description := "1=Interlock Trip Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTripShelved OF IntlkTrip.Shelved (Description := "1=Interlock Trip Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_IntlkTripSuppressed OF IntlkTrip.Suppressed (Description := "1=Interlock Trip Alarm has been Suppressed by Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_ActuatorFault OF ActuatorFault.Inp (Description := "1=Actuator Fault detected (input)",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Alm_ActuatorFault OF ActuatorFault.Alm (Description := "1=Alarm: Actuator Fault Detected",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Ack_ActuatorFault OF ActuatorFault.Ack (Description := "1=Actuator Fault Alarm has been acknowledged",
			                             Usage := Output,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             ExternalAccess := Read/Write);
			Sts_ActuatorFaultDisabled OF ActuatorFault.Disabled (Description := "1=Actuator Fault Alarm has been Disabled by Maintenance",
			                                     Usage := Output,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No,
			                                     ExternalAccess := Read/Write);
			Sts_ActuatorFaultShelved OF ActuatorFault.Shelved (Description := "1=Actuator Fault Alarm has been Shelved by Operator",
			                                    Usage := Output,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No,
			                                    ExternalAccess := Read/Write);
			Sts_ActuatorFaultSuppressed OF ActuatorFault.Suppressed (Description := "1=Actuator Fault Alarm has been Suppressed by Program",
			                                       Usage := Output,
			                                       RADIX := Decimal,
			                                       Required := No,
			                                       Visible := No,
			                                       ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "1=I/O Fault Status (0=OK, 1=Bad)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=I/O Fault Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			MRdy_Rel OF CmdSrc.MRdy_Rel (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			ORdy_Unlock OF CmdSrc.ORdy_Unlock (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only);
			P_ValveC : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			CmdSrc : P_CmdSrc (Description := "Control / Command Source Selection",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[7649,0,0,1,0,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']]");
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			IntlkTrip : P_Alarm (Description := "Interlock Trip Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[8,'P_ValveC$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[13,'Control Valve$00$00$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[13,'Control Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Bypass : BOOL (Description := "Internal Bypassable Interlocks are Bypassed flag",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Cfg_EU : STRING_8 (Description := "Engineering Units for display on HMI",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[6,'% Open$00$00']");
			Wrk_CV : REAL (Description := "Working copy of Speed Reference (for limiting)",
			                 RADIX := Float,
			                 ExternalAccess := None,
			                 DefaultData := 0.00000000e+000);
			Wrk_CVSet : REAL (Description := "Final selected CV to feed to RoC Limiter",
			                    RADIX := Float,
			                    ExternalAccess := None,
			                    DefaultData := 0.00000000e+000);
			Wrk_CVOut : REAL (Description := "Working value of CV after Rate Limiting",
			                    RADIX := Float,
			                    ExternalAccess := None,
			                    DefaultData := 0.00000000e+000);
			Wrk_IntlkTripONS : BOOL (Description := "Interlock Tripped This Scan",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_ScanTime : REAL (Description := "Seconds since previous scan",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_StepInc : REAL (Description := "Amount to increase CV (to valve pulse logic) this scan for rate limiting",
			                      RADIX := Float,
			                      ExternalAccess := None,
			                      DefaultData := 0.00000000e+000);
			Wrk_ScanT : TIMER (Description := "Scan Timer (milliseconds, always runs)",
			                    ExternalAccess := None,
			                    DefaultData := "[0,2147483647,0]");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_Sts : DINT (Description := "Buffer for building Val_Sts",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			ActuatorFault : P_Alarm (Description := "Actuator Fault Alarm (based on Actuator Fault Input)",
			                        ExternalAccess := Read/Write,
			                        DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Actuator Fault$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0]");
			Wrk_RealChkDINT : DINT (Description := "REAL tag bit pattern as a DINT to check for Inf / NaN",
			                          RADIX := Hex,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_Close : BOOL (Description := "Internal Close output -- before Sim",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_Open : BOOL (Description := "Internal Open output -- before Sim",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_CycleT : TIMER (Description := "Overall Cycle Timer for pulsed outputs",
			                     ExternalAccess := None,
			                     DefaultData := "[0,2147483647,0]");
			Wrk_OKtoOpen : BOOL (Description := "OK to pulse$NOut_Open",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_OKtoClose : BOOL (Description := "OK to pulse Out_Close",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_OpenTime : REAL (Description := "Time to pulse Out_Open",
			                       RADIX := Float,
			                       ExternalAccess := None,
			                       DefaultData := 0.00000000e+000);
			Wrk_CycleT_ms : DINT (Description := "Cycle Time in milliseconds (preset)",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_OpenTimePrev : DINT (Description := "Wrk_OpenTime from previous cycle",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_CloseTime : REAL (Description := "Time to pulse Out_Close",
			                        RADIX := Float,
			                        ExternalAccess := None,
			                        DefaultData := 0.00000000e+000);
			Wrk_CloseTimePrev : REAL (Description := "Wrk_CloseTime from previous cycle",
			                            RADIX := Float,
			                            ExternalAccess := None,
			                            DefaultData := 0.00000000e+000);
			HMI_Type : STRING_16 (Description := "Must contain AOI name, used for HMI and Information S/W",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[8,'P_ValveC$00$00$00$00$00$00$00$00']");
			Wrk_OpenFdbk : BOOL (Description := "1=LS Feedback shows valve confirmed open",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_ClosedFdbk : BOOL (Description := "1=LS Feedback shows valve confirmed closed",
			                         RADIX := Decimal,
			                         ExternalAccess := None,
			                         DefaultData := 0);
			Wrk_StepDec : REAL (Description := "Amount to decrease CV (to valve pulse logic) this scan for rate limiting",
			                      RADIX := Float,
			                      ExternalAccess := None,
			                      DefaultData := 0.00000000e+000);
			Wrk_BumpClose : BOOL (Description := "Operator Bump Close requested",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_BumpOpen : BOOL (Description := "Operator Bump Open requested",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_BumpingOpen : BOOL (Description := "Operator Bump Open actively pulsing Out_Open",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_BumpingClose : BOOL (Description := "Operator Bump Close actively pulsing Out_Close",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_CycleActive : BOOL (Description := "Outputs are cycling; wait for cycle to complete",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Cfg_CVNavTag : STRING_NavTag (Description := "Tagname for destination of CV Navigation button",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_ShedIntlkCV : BOOL (Description := "Output CV being held at Interlock value",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_ShedHold : BOOL (Description := "Output CV being held at last good value",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			OSet_CV : REAL (Description := "Operator Setting of Controlled Variable (output) (CV EU)",
			                  RADIX := Float,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0.00000000e+000);
			OCmd_ResetAckAll : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms and acknowledge all alarms",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Check : BOOL (Description := "Maintenance Command to Check (not bypass) all Interlocks",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Bypass : BOOL (Description := "Maintenance Command to Bypass all Bypassable Interlocks",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			OCmd_BumpClose : BOOL (Description := "Operator Command to bump valve closed (avail. if Fdbk Bad)",
			                         RADIX := Decimal,
			                         ExternalAccess := Read/Write,
			                         DefaultData := 0);
			OCmd_BumpOpen : BOOL (Description := "Operator Command to bump valve open (avail. if Fdbk Bad)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read/Write,
			                        DefaultData := 0);
			ORdy_CV : BOOL (Description := "1=Ready for OSet_CV (enables data entry field)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read Only,
			                  DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Check : BOOL (Description := "1=Ready for MCmd_Check (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Bypass : BOOL (Description := "1=Ready for MCmd_Bypass (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			ORdy_BumpClose : BOOL (Description := "1=Ready for OCmd_BumpClose (enables HMI button)",
			                         RADIX := Decimal,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			ORdy_BumpOpen : BOOL (Description := "1=Ready for OCmd_BumpOpen (enables HMI button)",
			                        RADIX := Decimal,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Val_Notify : DINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wrk_DeadtimeT : TIMER (Description := "Timer for valve hysteresis (deadtime)",
			                        ExternalAccess := None,
			                        DefaultData := "[0,0,0]");
			Wrk_LastMove : BOOL (Description := "1=Last move was to open, 0=Last move was to close",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_WaitDeadtime : BOOL (Description := "1=Need to wait deadtime before simulated move",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Out of Service is asserted, Output OFF (zero), Alarms inhibited")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "Handle $QProgrammed Out of Servie$Q Selection using the standard$N"
				    "P_CmdSrc AOI (EnableInFalse";
				N: XIC(EnableIn)P_CmdSrc(CmdSrc);
				RC: "First-Come First-Served Ownership Arbitration still needs to happen, even when device is disabled.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "This rung publishes the Values for the scaled range.$N"
				    "If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$N"
				    "the values are swapped so the the EUMax Value is always greater than the EUMin Value.$N"
				    "This makes the HMI bargraph and trend coding easier, and provides values$N"
				    "that can be pinned to the CV EU configuration of a PID, so the AOut and PID ranges are in lockstep.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added configurable decimal places for display on HMI.  #####";
				N: [GEQ(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMin) MOV(Cfg_CVEUMax,Val_CVEUMax) ,LES(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMax) MOV(Cfg_CVEUMax,Val_CVEUMin) ,LIM(7,Cfg_DecPlcs,-1) MOV(2,Cfg_DecPlcs) ];
				RC: "Restrict the configured Rate of Change Limits to be non-negative.$N"
				    "NOTE:  A $Qzero$Q value of a limit means $Qunlimited$Q (immediate).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [LES(Cfg_CVRoCLimInc,0.0) CLR(Cfg_CVRoCLimInc) ,LES(Cfg_CVRoCLimDec,0.0) CLR(Cfg_CVRoCLimDec) ];
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Crossed CV Limits or Invalid Rate of Change Limit$N"
				    "Bad Engineering Units Scaling configs (Max = Min)$N"
				    "Bad Raw Scaling configs (Max = Min)$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [LES(Cfg_MaxCV,Cfg_MinCV) OTE(Err_Limit) ,EQU(Cfg_CVEUMax,Cfg_CVEUMin) OTE(Err_EU) ,EQU(Cfg_CVRawMax,Cfg_CVRawMin) OTE(Err_Raw) ,EQU(Cfg_FdbkRawMax,Cfg_FdbkRawMin) OTE(Err_Fdbk) ];
				RC: "Check for a valid Cycle Time.  If it results in a negative value, clear it and flag it.$N"
				    "$N"
				    "The other times must be set relative to the Cycle Time.  If any is invalid, just make it valid:$N"
				    "* If Max ON Time < 0 or > Cycle Time, set it to Cycle Time.$N"
				    "*  If Min ON Time < 0 or > Max ON Time, set it to zero.$N"
				    "* If Deadtime < 0 or > Cycle Time, set it to zero.";
				N: [MUL(Cfg_CycleT,1000,Wrk_CycleT_ms) LES(Wrk_CycleT_ms,0) CLR(Wrk_CycleT_ms) CLR(Cfg_CycleT) OTE(Err_Timer) ,[LES(Cfg_MaxOnT,0.0) ,GRT(Cfg_MaxOnT,Cfg_CycleT) ] MOV(Cfg_CycleT,Cfg_MaxOnT) ,[LES(Cfg_MinOnT,0.0) ,GRT(Cfg_MinOnT,Cfg_CycleT) ] CLR(Cfg_MinOnT) ,[LES(Cfg_Deadtime,0.0) ,GRT(Cfg_Deadtime,Cfg_MaxOnT) ] CLR(Cfg_Deadtime) ];
				RC: "Clamp other configuration parameters to ensure they are valid.$N"
				    "$N"
				    "* If the Open Rate < 0, set it to zero.$N"
				    "* If the Close Rate < 0, set it to zero.$N"
				    "* Clamp the Closed/Opened status threshold to be within the$N"
				    "scaled range CVEUMin to CVEUMax.";
				N: [LES(Cfg_OpenRate,0.0) CLR(Cfg_OpenRate) ,LES(Cfg_CloseRate,0.0) CLR(Cfg_CloseRate) ,LES(Cfg_MaxClosedPos,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Cfg_MaxClosedPos) ,GRT(Cfg_MaxClosedPos,Cfg_CVEUMax) MOV(Cfg_CVEUMax,Cfg_MaxClosedPos) ];
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Crossed CV Limits or Invalid Rate of Change Limit$N"
				    "Bad Cycle Time configuration$N"
				    "Bad Raw Scaling configs (Max = Min)$N"
				    "Bad Alarm configs$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.";
				N: [XIC(Err_Limit) ,XIC(Err_EU) ,XIC(Err_Raw) ,XIC(Err_Fdbk) ,XIC(Err_Timer) ,[XIC(IntlkTrip.Sts_Err) ,XIC(ActuatorFault.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err)OTE(Nrdy_CfgErr);
				RC: "If this Analog Output is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then show the alarms as $QParent object out of service$Q.$N"
				    "Show the overall acknowledgement status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc, added Out of Service.  #####";
				N: [OTL(IntlkTrip.Inp_OoS) P_Alarm(IntlkTrip) ,OTL(ActuatorFault.Inp_OoS) P_Alarm(ActuatorFault) ,OTL(IOFault.Inp_OoS) P_Alarm(IOFault) ,CLR(Val_Notify) CLR(Val_NotifyAll) ,[XIC(IntlkTrip.Val_Notify.0) ,XIC(ActuatorFault.Val_Notify.0) ,XIC(IOFault.Val_Notify.0) ] OTL(Val_Notify.0) OTL(Val_NotifyAll.0) ,[XIC(IntlkTrip.Sts_AlmInh) ,XIC(ActuatorFault.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ] OTE(Sts_AlmInh) ];
				RC: "If this Control Valve is OFF-SCAN (rung is false or EnableIn is false in FBD), then:$N"
				    "$N"
				    "Clear the pulse outputs.$N"
				    "Clear the Alarms$N"
				    "Show the Valve as $QDisabled$Q, not $QAvailable$Q and $QNot Ready$Q.$N"
				    "Set the target position to the configured ($Qsafe$Q) Interlock CV value.$N"
				    "$N"
				    "Other data are left in Last State!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [OTU(Out_Open) OTU(Out_Close) ,OTL(Sts_NotRdy) OTU(Sts_Available) OTU(Sts_MaintByp) ,OTL(Nrdy_OoS) OTU(Nrdy_Intlk) OTU(Nrdy_IOFault) ,MOV(Cfg_IntlkCV,Wrk_CVSet) MOV(Cfg_IntlkCV,Wrk_CVOut) ];
				RC: "============================================================$N"
				    "FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "Always show the actual position from the Position Feedback input.$N"
				    "If the input is a valid REAL number, conver";
				N: [COP(Inp_PosFdbk,Wrk_RealChkDINT,1) MEQ(Wrk_RealChkDINT,16#7F80_0000,16#7F80_0000) OTE(Sts_PosInfNaN) ,XIC(Sts_PosInfNaN) COP(Inp_PosFdbk,Val_Pos,1) ,XIO(Sts_PosInfNaN) CPT(Val_Pos,(Inp_PosFdbk-Cfg_FdbkRawMin)*(Cfg_CVEUMax-Cfg_CVEUMin)/(Cfg_FdbkRawMax-Cfg_FdbkRawMin)+Cfg_CVEUMin) ];
				RC: "============================================================$N"
				    "DEVICE FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "If the Valve is NOT being simulated and it HAS and IS USING limit switch feedback,$N"
				    "use the state of th";
				N: [XIO(Inp_Sim) [XIC(Cfg_UseOpenLS) XIC(Inp_OpenLS) ,XIO(Cfg_UseOpenLS) XIC(Cfg_UseClosedLS) XIO(Inp_ClosedLS) ] ,[XIC(Inp_Sim) ,XIO(Cfg_UseOpenLS) XIO(Cfg_UseClosedLS) ] GRT(Val_Pos,Cfg_MaxClosedPos) ]OTE(Wrk_OpenFdbk);
				RC: "If the Valve is NOT being simulated and it HAS and IS USING limit switch feedback,$N"
				    "use the state of the limit switch feedback inputs as the Valve position.$N"
				    "$N"
				    "If the Valve is being simulated or has no limit switch feedback, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to Open and time to Close.";
				N: [XIO(Inp_Sim) [XIC(Cfg_UseClosedLS) XIC(Inp_ClosedLS) ,XIO(Cfg_UseClosedLS) XIC(Cfg_UseOpenLS) XIO(Inp_OpenLS) ] ,[XIC(Inp_Sim) ,XIO(Cfg_UseClosedLS) XIO(Cfg_UseOpenLS) ] LEQ(Val_Pos,Cfg_MaxClosedPos) ]OTE(Wrk_ClosedFdbk);
				RC: "============================================================$N"
				    "VALVE FEEDBACK STATUS$N"
				    "============================================================$N"
				    "This rung generates the Valve Feedback Status bits and Enumeration Value:$N"
				    "Limit Switch Fail, if the Limit S";
				N: [[XIC(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ] OTE(Sts_LSFail) MOV(3,Val_Fdbk) ,XIC(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) MOV(2,Val_Fdbk) ,XIC(Wrk_ClosedFdbk) XIO(Wrk_OpenFdbk) OTE(Sts_Active) MOV(1,Val_Fdbk) ,[XIC(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ] CLR(Val_Fdbk) ];
				RC: "The rate limiter$'s scan timer must run and clear every scan, whether the Instruction$N"
				    "is true or not.  Doing so here avoids a bump in the Value on transition to EnableIn TRUE.";
				N: TON(Wrk_ScanT,?,?)CLR(Wrk_ScanT.ACC);
				RC: "$QLurking$Q Operator Commands are cleared, as well as a Program Reset.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  Added External Command Source and Commands/Settings.  #####";
				N: [OTU(MCmd_Bypass) OTU(MCmd_Check) OTU(OCmd_BumpOpen) OTU(OCmd_BumpClose) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####$N"
				    "#####  Aligned ready bit naming with command bit names.  #####";
				N: [OTU(MRdy_Bypass) OTU(MRdy_Check) OTU(ORdy_BumpOpen) OTU(ORdy_BumpClose) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) OTU(Sts_RdyAck) OTU(ORdy_CV) ];
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = At Target$N"
				    "1 = Ramping Down$N"
				    "2 = Ramping Up$N"
				    "3 = Clamped at CVMin$N"
				    "4 = Clamped at CVMax$N"
				    "$N"
				    "And this rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "32 = I/O Fault$N"
				    "34 = Configuration Error";
				N: [CLR(Val_Sts) ,XIO(Sts_Err) CLR(Val_Fault) ,XIC(Sts_Err) MOV(34,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed go";
				N: [CLR(Wrk_SrcQ) ,[XIO(Cfg_HasOpenLS) ,XIO(Cfg_HasClosedLS) ] MOV(1,Wrk_SrcQ) ,XIO(Cfg_HasOpenLS) XIO(Cfg_HasClosedLS) MOV(2,Wrk_SrcQ) ,XIC(Inp_ActuatorFault) MOV(32,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(20,SrcQ);
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan: manipulate Control Valve with position feedback")
				RC: "Copyright ? Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_ValveC :  PROCESS -- CONTROL VALVE$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-17:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-07-16:  Changed Inf_ items to HMI_, and added Cfg_Area for security.$N"
				    "Added notify and unack count rollup for associated object(s).$N"
				    "Changed $QMode$Q to $QCommand Source$Q using P_CmdSrc 4.00.00.$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "Added unacked alarm count.$N"
				    "Added configurable decimal places for display on HMI.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N"
				    "Added option for no position feedback (simulated with hysteresis).$N"
				    "V4.10.00  2019-03-08:  Added option to clamp to a full/empty range when we have$N"
				    "limit switches. Changed availability to use input availability from interlocks.$N"
				    "Updated to P_CmdSrc V4.10.00. Corrected parameter External Access.$N"
				    "Added Cfg_HasMoreObj.$N"
				    "V4.10.01  2019-10-17:  No changes, uprevved because P_CmdSrc 4.10.01 is used.$N"
				    "============================================================$N"
				    "This Instruction controls an Analog or Pulse Output Valve with$N"
				    "analog or simulated position feedback and provides:$N"
				    "$N"
				    "*  Program and Operator entry of target position in Percent Open$N"
				    "*  Ramping of position to target at specified Rate of Change (%/sec)$N"
				    "*  Scaling of Position Feedback input from Raw (I/O card) Units to percent$N"
				    "*  Monitoring of Interlock conditions which cause output to shed$N"
				    "*  Configurable shed to HOLD or to configured position$N"
				    "*  Monitoring of I/O communication faults$N"
				    "*  Alarms for Interlock Trip, Actuator Fault, I/O Fault$N"
				    "*  Opened, Closed status based on limit switches (if provided),$N"
				    "or based on Position Feedback and a configured threshold.$N"
				    "*  $QAvailable$Q status for use by automation logic to know whether valve$N"
				    "      can be controlled by other objects.$N"
				    "$N"
				    "Command Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$N"
				    "Command Sources: Operator, Program, External, Override, Maintenance, Out of Service, Hand.$N"
				    "Alarms are provided by P_Alarm Add-On Instruction instances.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)CONCAT(Cfg_Desc,Cfg_Label,Cfg_Tag)CONCAT(Cfg_Area,Cfg_EU,Cfg_CVNavTag)LOWER(HMI_Lib,HMI_Type);
				RC: "============================================================$N"
				    "COMMAND SOURCE PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Command Source selection Inputs and Commands:$N"
				    "$N"
				    "NOTE:  All Commands for Comm";
				N: LBL(SkipText)P_CmdSrc(CmdSrc);
				RC: "This rung handles simple First-Come First-Served Ownership Arbitration.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "These rungs get Configuration data (such as timer presets) and distribute as needed.$N"
				    "Note that some Configuration d";
				N: [GEQ(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMin) MOV(Cfg_CVEUMax,Val_CVEUMax) ,LES(Cfg_CVEUMax,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_CVEUMax) MOV(Cfg_CVEUMax,Val_CVEUMin) ,LIM(7,Cfg_DecPlcs,-1) MOV(2,Cfg_DecPlcs) ];
				RC: "Restrict the configured Rate of Change Limits to be non-negative.$N"
				    "NOTE:  A $Qzero$Q value of a limit means $Qunlimited$Q (immediate).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [LES(Cfg_CVRoCLimInc,0.0) CLR(Cfg_CVRoCLimInc) ,LES(Cfg_CVRoCLimDec,0.0) CLR(Cfg_CVRoCLimDec) ];
				RC: "If the Valve does not have an Open Limit Switch input,$N"
				    "it cannot be used for Valve feedback checking.";
				N: XIO(Cfg_HasOpenLS)OTU(Cfg_UseOpenLS);
				RC: "If the Valve does not have a Closed Limit Switch input,$N"
				    "it cannot be used for Valve feedback checking.";
				N: XIO(Cfg_HasClosedLS)OTU(Cfg_UseClosedLS);
				RC: "Flag a Configuration Error if the CV scaled range, or the CV output or$N"
				    "position feedback input range maximum and minimum are set the same (invalid range).";
				N: [EQU(Cfg_CVEUMax,Cfg_CVEUMin) OTE(Err_EU) ,EQU(Cfg_CVRawMax,Cfg_CVRawMin) OTE(Err_Raw) ,EQU(Cfg_FdbkRawMax,Cfg_FdbkRawMin) OTE(Err_Fdbk) ];
				RC: "Check for a valid Cycle Time.  If it results in a negative value, clear it and flag it.$N"
				    "$N"
				    "The other times must be set relative to the Cycle Time.  If any is invalid, just make it valid:$N"
				    "* If Max ON Time < 0 or > Cycle Time, set it to Cycle Time.$N"
				    "*  If Min ON Time < 0 or > Max ON Time, set it to zero.$N"
				    "* If Deadtime < 0 or > Cycle Time, set it to zero.$N"
				    "* Bump Time must be within the Min ON Time and Max ON Time.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added option for simulated position feedback, with deadtime timer.  #####";
				N: [MUL(Cfg_CycleT,1000.0,Wrk_CycleT_ms) LES(Wrk_CycleT_ms,0) CLR(Wrk_CycleT_ms) CLR(Cfg_CycleT) OTE(Err_Timer) ,[LES(Cfg_MaxOnT,0.0) ,GRT(Cfg_MaxOnT,Cfg_CycleT) ] MOV(Cfg_CycleT,Cfg_MaxOnT) ,[LES(Cfg_MinOnT,0.0) ,GRT(Cfg_MinOnT,Cfg_CycleT) ] CLR(Cfg_MinOnT) ,[LES(Cfg_Deadtime,0.0) ,GRT(Cfg_Deadtime,Cfg_MaxOnT) ] CLR(Cfg_Deadtime) ,MUL(Cfg_Deadtime,1000,Wrk_DeadtimeT.PRE) ,LES(Cfg_BumpT,Cfg_MinOnT) NEQ(Cfg_BumpT,0.0) MOV(Cfg_MinOnT,Cfg_BumpT) ,GRT(Cfg_BumpT,Cfg_MaxOnT) MOV(Cfg_MaxOnT,Cfg_BumpT) ];
				RC: "Clamp other configuration parameters to ensure they are valid.$N"
				    "$N"
				    "* If the Open Rate < 0, set it to zero.$N"
				    "* If the Close Rate < 0, set it to zero.$N"
				    "* Clamp the Closed/Opened status threshold to be within the$N"
				    "scaled range CVEUMin to CVEUMax.";
				N: [LES(Cfg_OpenRate,0.0) CLR(Cfg_OpenRate) ,LES(Cfg_CloseRate,0.0) CLR(Cfg_CloseRate) ,LES(Cfg_MaxClosedPos,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Cfg_MaxClosedPos) ,GRT(Cfg_MaxClosedPos,Cfg_CVEUMax) MOV(Cfg_CVEUMax,Cfg_MaxClosedPos) ];
				RC: "This rung handles the reports of all Bad Configuration Status.$N"
				    "Individual bits are provided for various status:$N"
				    "Crossed CV Limits or Invalid Rate of Change Limit$N"
				    "Bad Cycle Time configuration$N"
				    "Bad Raw Scaling configs (Max = Min)$N"
				    "Bad Alarm configs$N"
				    "$N"
				    "Then a summary Bad Config status is provided, simply an OR of the individual bits.";
				N: [LES(Cfg_MaxCV,Cfg_MinCV) OTE(Err_Limit) ,XIC(Err_EU) ,XIC(Err_Raw) ,XIC(Err_Fdbk) ,XIC(Err_Timer) ]OTE(Nrdy_CfgErr);
				RC: "============================================================$N"
				    "FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "If the Position Feedback exists and we$'re not in Simulation, process it.$N"
				    "If the input is a valid REAL number";
				N: XIO(Inp_Sim)XIC(Cfg_HasPosFdbk)[COP(Inp_PosFdbk,Wrk_RealChkDINT,1) MEQ(Wrk_RealChkDINT,16#7F80_0000,16#7F80_0000) OTE(Sts_PosInfNaN) ,[XIC(Sts_PosInfNaN) ,XIC(Err_Fdbk) ] COP(Inp_PosFdbk,Val_Pos,1) ,XIO(Sts_PosInfNaN) XIO(Err_Fdbk) CPT(Val_Pos,(Inp_PosFdbk-Cfg_FdbkRawMin)*(Cfg_CVEUMax-Cfg_CVEUMin)/(Cfg_FdbkRawMax-Cfg_FdbkRawMin)+Cfg_CVEUMin) ];
				RC: "In preparation for rate limiting and ramping, this rung$N"
				    "determines the time since the previous scan, using a non-stop TON timer.$N"
				    "When we get here, we read the accumulator (in milliseconds, so$N"
				    "divide by 1000.0 to get seconds), then clear the accumulator.  Next scan the accumulator will have$N"
				    "incremented up to the number of milliseconds since last scan.  (Works for scan times up to 2 million seconds.....)";
				N: MOV(2147483647,Wrk_ScanT.PRE)TON(Wrk_ScanT,?,?)DIV(Wrk_ScanT.ACC,1000.0,Wrk_ScanTime)CLR(Wrk_ScanT.ACC);
				RC: "In Simulation, or if the Position Feedback does not exist, the simulated position$N"
				    "ramps at the configured valve Open Rate or Close Rate, after waiting the deadtime$N"
				    "on a change in direction, when the logic is requesting the valve to open or close.$N"
				    "(Note Wrk_ bits, not Out_ bits, which are cleared in Simulation.)$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added option for simulated position feedback, with deadtime timer.  #####";
				N: [XIC(Inp_Sim) ,XIO(Cfg_HasPosFdbk) ][[XIC(Wrk_Open) XIO(Wrk_LastMove) OTL(Wrk_LastMove) ,XIC(Wrk_Close) XIC(Wrk_LastMove) OTU(Wrk_LastMove) ] OTL(Wrk_WaitDeadtime) ,XIC(Wrk_WaitDeadtime) TON(Wrk_DeadtimeT,?,?) TON(Wrk_DeadtimeT,?,?) ,XIC(Wrk_DeadtimeT.DN) OTU(Wrk_WaitDeadtime) ,XIO(Wrk_WaitDeadtime) [XIC(Wrk_Open) CPT(Val_Pos,Val_Pos+(Wrk_ScanTime*Cfg_OpenRate)) ,XIC(Wrk_Close) CPT(Val_Pos,Val_Pos-(Wrk_ScanTime*Cfg_CloseRate)) ] ,GRT(Val_Pos,Cfg_CVEUMax) MOV(Cfg_CVEUMax,Val_Pos) ,LES(Val_Pos,Cfg_CVEUMin) MOV(Cfg_CVEUMin,Val_Pos) ];
				RC: "If the valve is NOT simulated, and if the valve does NOT have position feedback,$N"
				    "if the valve contacts the open or closed limit switch, set the simulated position$N"
				    "feedback to the full open (MaxCV) or full closed (MinCV) position.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added option for simulated position feedback, with deadtime timer.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Added option to clamp to a full/empty range when we have limit switches.   #####";
				N: XIO(Inp_Sim)[XIO(Cfg_HasPosFdbk) ,XIC(Cfg_ClampPosToLS) ][XIC(Inp_OpenLS) XIC(Cfg_UseOpenLS) [XIO(Inp_ClosedLS) ,XIO(Cfg_UseClosedLS) ] MOV(Cfg_CVEUMax,Val_Pos) ,XIC(Inp_ClosedLS) XIC(Cfg_UseClosedLS) [XIO(Inp_OpenLS) ,XIO(Cfg_UseOpenLS) ] MOV(Cfg_CVEUMin,Val_Pos) ];
				RC: "============================================================$N"
				    "SETTINGS PROCESSING$N"
				    "============================================================$N"
				    "This rung handles received Settings:$N"
				    "$N"
				    "Limit the Program and Operator CV Settings to the hard limits, regardl";
				N: [[[GRT(PSet_CV,Cfg_MaxCV) MOV(Cfg_MaxCV,PSet_CV) ,LES(PSet_CV,Cfg_MinCV) MOV(Cfg_MinCV,PSet_CV) ] XIC(Sts_Prog) ,[GRT(XSet_CV,Cfg_MaxCV) MOV(Cfg_MaxCV,XSet_CV) ,LES(XSet_CV,Cfg_MinCV) MOV(Cfg_MinCV,XSet_CV) ] XIC(Sts_Ext) ,XIO(Sts_Maint) XIO(Sts_Hand) [GRT(OSet_CV,Cfg_MaxCV) MOV(Cfg_MaxCV,OSet_CV) ,LES(OSet_CV,Cfg_MinCV) MOV(Cfg_MinCV,OSet_CV) ] ] OTE(Sts_Clamped) ,XIC(Sts_Prog) MOV(PSet_CV,Wrk_CV) ,[XIC(Sts_Oper) ,XIC(Sts_Maint) ] MOV(OSet_CV,Wrk_CV) ,XIC(Sts_Ext) MOV(XSet_CV,Wrk_CV) ,XIC(Sts_Ovrd) MOV(Inp_OvrdCV,Wrk_CV) ];
				RC: "============================================================$N"
				    "INTERLOCK / PERMISSIVE BYPASS / CHECK COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Bypass Command bypasses the Bypassable Permissives and Interlocks.";
				N: XIC(MCmd_Bypass)OTU(MCmd_Bypass)OTL(Wrk_Bypass);
				RC: "The Check Command enables checking of ALL$N"
				    "Permissives and Interlocks (cancels the bypass).";
				N: XIC(MCmd_Check)OTU(MCmd_Check)OTU(Wrk_Bypass);
				RC: "If the internal Bypass flag is set, Bypassable Interlocks ARE BYPASSED.$N"
				    "Bypassing is ACTIVE if Bypass selected OR in Maintenance Mode,$N"
				    "or in Override Mode if Override Bypassing is configured.";
				N: [XIC(Wrk_Bypass) OTE(Sts_Bypass) ,XIC(Sts_Maint) ,XIC(Sts_Ovrd) XIC(Cfg_OvrdIntlk) ]OTE(Sts_BypActive);
				RC: "If a Maintenance Bypass function is active, display the Maintenance Bypass$N"
				    "Indicator (triangle symbol) on the graphic symbol.  Bypass functions are:$N"
				    "*  Interlock Bypass function is enabled.";
				N: [XIC(Sts_Bypass) ,XIC(Cfg_HasOpenLS) XIO(Cfg_UseOpenLS) ,XIC(Cfg_HasClosedLS) XIO(Cfg_UseClosedLS) ]OTE(Sts_MaintByp);
				RC: "Ready for Interlock Bypass if not bypassed.$N"
				    "Ready to cancel Bypass (resume checking) if bypassed.";
				N: [XIO(Wrk_Bypass) OTE(MRdy_Bypass) ,XIC(Wrk_Bypass) OTE(MRdy_Check) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(XCmd_Reset) OTU(XCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(IntlkTrip.PCmd_Ack) ,OTL(IOFault.PCmd_Ack) ] ][OTL(IntlkTrip.PCmd_Reset) OTL(ActuatorFault.PCmd_Reset) OTL(IOFault.PCmd_Reset) ,[XIO(Inp_IOFault) ,XIC(Inp_Sim) ] OTU(Nrdy_IOFault) ];
				RC: "The Pulse Output Valve is NOT READY to be controlled (by the owner specified by Mode) if it is$N"
				    "Disabled, if interlocks are not OK (accounting for bypassing), I/O Communication is faulted$N"
				    "or there is a configuration error.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_CfgErr) ,XIC(Sts_OoS) OTE(Nrdy_OoS) ,[XIO(Inp_IntlkOK) XIO(Sts_BypActive) ,XIO(Inp_NBIntlkOK) ] [[ONS(Wrk_IntlkTripONS) XIC(Cfg_ShedHold) [NEQ(Wrk_OpenTime,0.0) ,NEQ(Wrk_CloseTime,0.0) ] ,XIO(Cfg_ShedHold) NEQ(Wrk_CVSet,Cfg_IntlkCV) ] OTE(Sts_IntlkTrip) ,OTE(Nrdy_Intlk) ] ,XIC(Inp_IOFault) XIO(Inp_Sim) OTE(Sts_IOFault) XIC(Cfg_ShedOnIOFault) OTL(Nrdy_IOFault) ,XIC(Nrdy_IOFault) ]OTE(Sts_NotRdy);
				RC: "The device is AVAILABLE to be controlled by other objects$N"
				    "if it IS in Program Mode and it IS NOT $QNot Ready$Q.$N"
				    "#####  V4.10.00  2019-03-08:  Changed availability to use input availability from interlocks.  #####";
				N: XIC(Sts_Prog)XIO(Nrdy_CfgErr)XIO(Nrdy_OoS)XIO(Nrdy_IOFault)[[XIC(Inp_IntlkOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBIntlkOK) ,XIC(Inp_IntlkAvail) ]OTE(Sts_Available);
				RC: "Ready to receive a new OSet_CV if tracking is NOT enabled,$N"
				    "or we$'re in Operator or Maintenance Mode, or,$N"
				    "if we$'re in Hand or Ovrd, tracking is NOT configured for Ovrd and Hand.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####";
				N: [XIO(Cfg_SetTrack) ,XIC(Sts_Oper) ,XIC(Sts_Maint) ,[XIC(Sts_Hand) ,XIC(Sts_Ovrd) ] XIO(Cfg_SetTrackOvrdHand) ]OTE(ORdy_CV);
				RC: "============================================================$N"
				    "DEVICE FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "If the Valve is NOT being simulated and it HAS and IS USING limit switch feedback,$N"
				    "use the state of th";
				N: [XIO(Inp_Sim) [XIC(Cfg_UseOpenLS) XIC(Inp_OpenLS) ,XIO(Cfg_UseOpenLS) XIC(Cfg_UseClosedLS) XIO(Inp_ClosedLS) ] ,[XIC(Inp_Sim) ,XIO(Cfg_UseOpenLS) XIO(Cfg_UseClosedLS) ] XIO(Sts_PosInfNaN) GRT(Val_Pos,Cfg_MaxClosedPos) ]OTE(Wrk_OpenFdbk);
				RC: "If the Valve is NOT being simulated and it HAS and IS USING limit switch feedback,$N"
				    "use the state of the limit switch feedback inputs as the Valve position.$N"
				    "$N"
				    "If the Valve is being simulated or has no limit switch feedback, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to Open and time to Close.";
				N: [XIO(Inp_Sim) [XIC(Cfg_UseClosedLS) XIC(Inp_ClosedLS) ,XIO(Cfg_UseClosedLS) XIC(Cfg_UseOpenLS) XIO(Inp_OpenLS) ] ,[XIC(Inp_Sim) ,XIO(Cfg_UseClosedLS) XIO(Cfg_UseOpenLS) ] XIO(Sts_PosInfNaN) LEQ(Val_Pos,Cfg_MaxClosedPos) ]OTE(Wrk_ClosedFdbk);
				RC: "============================================================$N"
				    "VALVE FEEDBACK STATUS$N"
				    "============================================================$N"
				    "This rung generates the Valve Feedback Status bits and Enumeration Value:$N"
				    "Limit Switch Fail, if the Limit S";
				N: [[XIC(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ] OTE(Sts_LSFail) MOV(3,Val_Fdbk) ,XIC(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) MOV(2,Val_Fdbk) ,XIC(Wrk_ClosedFdbk) XIO(Wrk_OpenFdbk) MOV(1,Val_Fdbk) ,[XIC(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ] CLR(Val_Fdbk) ,NEQ(Val_Fdbk,1) OTE(Sts_Active) ];
				RC: "============================================================$N"
				    "BUMP OPEN, BUMP CLOSE COMMAND HANDLING$N"
				    "============================================================$N"
				    "Ready to receive Bump Open / Bump Close Commands when:$N"
				    "*  Bump Timer preset is greater tha";
				N: [XIC(Sts_PosInfNaN) ,XIC(Sts_IOFault) ,XIC(Sts_ActuatorFault) ][XIC(Sts_Oper) ,XIC(Sts_Maint) ]XIO(Wrk_BumpOpen)XIO(Wrk_BumpClose)XIO(Wrk_BumpingOpen)XIO(Wrk_BumpingClose)[[XIO(Wrk_OpenFdbk) ,XIO(Cfg_UseClosedLS) ,XIO(Cfg_UseOpenLS) ] OTE(ORdy_BumpOpen) ,[XIO(Wrk_ClosedFdbk) ,XIO(Cfg_UseClosedLS) ,XIO(Cfg_UseOpenLS) ] OTE(ORdy_BumpClose) ];
				RC: "The Bump Open Command is used to pulse the Open Output$N"
				    "when the valve position feedback is not available (Inf, NaN, I/O Fault).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####";
				N: XIC(OCmd_BumpOpen)OTU(OCmd_BumpOpen)XIC(ORdy_BumpOpen)OTL(Wrk_BumpOpen);
				RC: "The Bump Close Command is used to pulse the Close Output$N"
				    "when the valve position feedback is not available (Inf, NaN, I/O Fault).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####";
				N: XIC(OCmd_BumpClose)OTU(OCmd_BumpClose)XIC(ORdy_BumpClose)OTL(Wrk_BumpClose);
				RC: "============================================================$N"
				    "VALVE ACTUATOR FAULT DETECTION$N"
				    "============================================================$N"
				    "If the Actuator Fault Input is true and we$'re not in simulation.$N"
				    "raise an ACTUATOR FAULT Status.";
				N: XIC(Inp_ActuatorFault)XIO(Inp_Sim)OTE(Sts_ActuatorFault);
				RC: "Clear flags for capturing exception conditions.";
				N: OTU(Wrk_ShedHold)OTU(Wrk_ShedIntlkCV);
				RC: "If Interlocks are not OK (non-bypassable always checked, bypassable checked if not bypassed$N"
				    "(bypassables not checked in Maintenance Mode, or in Override Mode if Override ignores bypassable interlocks...),$N"
				    "or if there is an I/O Fault, either HOLD the valve position or SHED it to the configured Interlock CV,$N"
				    "depending on the state of the Shed/Hold configuration.$N"
				    "$N"
				    "We don$'t want the Interlock Trip alarm occuring if Hand or Out of Service is going to win down below....$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_Intlk) ,XIC(Nrdy_IOFault) ]XIO(Sts_Hand)XIO(Sts_OoS)XIO(Nrdy_CfgErr)[XIO(Cfg_ShedHold) OTL(Wrk_ShedIntlkCV) MOV(Cfg_IntlkCV,Wrk_CV) ,XIC(Cfg_ShedHold) XIO(Sts_PosInfNaN) OTL(Wrk_ShedHold) MOV(Val_Pos,Wrk_CV) ];
				RC: "If the Pulse Output Valve is Out of Service or in Hand, or the Configuration is not valid,$N"
				    "set the CV to the feedback position (and do not energize pulse outputs -- handled elsewhere).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Sts_Hand) ,XIC(Sts_OoS) ,XIC(Nrdy_CfgErr) ]XIO(Sts_PosInfNaN)MOV(Val_Pos,Wrk_CV);
				RC: "After all that selecting, copy the final result to a holding register.  (We needed it above to do$N"
				    "the HOLD function on Interlock!)$N"
				    "$N"
				    "This is where the CV will be when ramping (if any) is done.";
				N: MOV(Wrk_CV,Wrk_CVSet);
				RC: "This rung determines whether the selected Position CV is +/- Infinity or +/- NotANumber.$N"
				    "In either case, the value cannot be passed into the rate limiter calculation or to the final output.$N"
				    "Instead, perform the designated SHED action: hold last output or shed to the Interlock CV.";
				N: COP(Wrk_CVSet,Wrk_RealChkDINT,1)MEQ(Wrk_RealChkDINT,16#7F80_0000,16#7F80_0000)[XIO(Cfg_ShedHold) OTL(Wrk_ShedIntlkCV) MOV(Cfg_IntlkCV,Wrk_CVSet) ,XIC(Cfg_ShedHold) OTL(Wrk_ShedHold) MOV(Wrk_CVOut,Wrk_CVSet) ];
				RC: "Under these conditions, SKIP the output ramping:$N"
				    "$N"
				    "* The vlave is disabled$N"
				    "* The valve is in Hand$N"
				    "* Rate of Change Skip is configures TRUE and, either, the Mode is Maintenance,$N"
				    "the Mode is Override, or an Interlock holds us out.$N"
				    "* The CV Rate of Change Limit for the direction the CV is moving is ZERO.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: [XIC(Sts_OoS) ,XIC(Nrdy_CfgErr) ,XIC(Sts_Hand) ,XIC(Cfg_SkipRoCLim) [XIC(Sts_Maint) ,XIC(Sts_Ovrd) ,XIC(Nrdy_Intlk) ] ,GRT(Wrk_CVSet,Wrk_CVOut) EQU(Cfg_CVRoCLimInc,0.0) ,LES(Wrk_CVSet,Wrk_CVOut) EQU(Cfg_CVRoCLimDec,0.0) ]OTE(Sts_SkipRoCLim)MOV(Wrk_CVSet,Wrk_CVOut);
				RC: "If the conditions above are NOT TRUE, do the rate limiting:$N"
				    "$N"
				    "If the time since the previous scan is not ZERO:$N"
				    "$N"
				    "* Calculate the amount to step this scan toward the final CV$N"
				    "* If we$'re within a single setp, go to the final CV$N"
				    "* If we$'re not within a single step, step one step closer (up or down, whichever way we need to go)$N"
				    "and show the $QRamping$Q status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####";
				N: XIO(Sts_SkipRoCLim)NEQ(Wrk_CVSet,Wrk_CVOut)NEQ(Wrk_ScanTime,0.0)[MUL(Cfg_CVRoCLimInc,Wrk_ScanTime,Wrk_StepInc) MUL(Cfg_CVRoCLimDec,Wrk_ScanTime,Wrk_StepDec) ,GRT(Wrk_CVSet,Wrk_CVOut) [CMP(Wrk_CVOut>=(Wrk_CVSet-Wrk_StepInc)) ,EQU(Cfg_CVRoCLimInc,0.0) ] MOV(Wrk_CVSet,Wrk_CVOut) ,LES(Wrk_CVSet,Wrk_CVOut) [CMP(Wrk_CVOut<=(Wrk_CVSet+Wrk_StepDec)) ,EQU(Cfg_CVRoCLimDec,0.0) ] MOV(Wrk_CVSet,Wrk_CVOut) ,[CMP(Wrk_CVOut>(Wrk_CVSet+Wrk_StepDec)) SUB(Wrk_CVOut,Wrk_StepDec,Wrk_CVOut) ,CMP(Wrk_CVOut<=(Wrk_CVSet-Wrk_StepInc)) ADD(Wrk_CVOut,Wrk_StepInc,Wrk_CVOut) ] OTE(Sts_Ramping) ];
				RC: "============================================================$N"
				    "OUTPUT GENERATION$N"
				    "============================================================$N"
				    "The following rungs generate the instruction$'s outputs, $N"
				    "on this rung the CV analog output (Out_CV)$N"
				    "$N"
				    "If not";
				N: [XIO(Inp_Sim) [XIO(Err_EU) XIO(Err_Raw) CPT(Out_CV,(Wrk_CVOut-Cfg_CVEUMin)*(Cfg_CVRawMax-Cfg_CVRawMin)/(Cfg_CVEUMax-Cfg_CVEUMin)+Cfg_CVRawMin) ,[XIC(Err_EU) ,XIC(Err_Raw) ] OTL(Wrk_ShedIntlkCV) MOV(Cfg_IntlkCV,Out_CV) ] ,XIC(Inp_Sim) CLR(Out_CV) ];
				RC: "The following rungs generate the instruction$'s Open and Close pulse outputs.$N"
				    "$N"
				    "If the Cycle Time is > 0, and the position and CV are valid real numbers, then:$N"
				    "$N"
				    "* the open output can be energized if the valve CV > Position, we$'re not$N"
				    "up against the open limit switch, the position is less than the Max CV,$N"
				    "and the valve has an Open Rate > 0.$N"
				    "$N"
				    "* the close output can be energized if the valve Position > CV, we$'re not$N"
				    "up against the closed limit switch, the position is more than the Min CV,$N"
				    "and the valve has a Close Rate > 0.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: GRT(Cfg_CycleT,0.0)XIO(Sts_PosInfNaN)XIO(Sts_CVInfNaN)XIO(Sts_OoS)XIO(Nrdy_CfgErr)XIO(Nrdy_IOFault)[GRT(Val_CVOut,Val_Pos) [XIO(Inp_OpenLS) ,XIO(Cfg_UseOpenLS) ,XIC(Inp_Sim) ] LES(Val_Pos,Cfg_MaxCV) GRT(Cfg_OpenRate,0.0) OTE(Wrk_OKtoOpen) ,LES(Val_CVOut,Val_Pos) [XIO(Inp_ClosedLS) ,XIO(Cfg_UseClosedLS) ,XIC(Inp_Sim) ] GRT(Val_Pos,Cfg_MinCV) GRT(Cfg_CloseRate,0.0) OTE(Wrk_OKtoClose) ];
				RC: "This is just a continuously-running Cycle Timer.  By not using the Cycle$N"
				    "Timer $Q.DN$Q (done) bit on the rung, we avoid losing the one scan of$N"
				    "time when the timer is not running in an XIO / TON rung.";
				N: TON(Wrk_CycleT,?,?);
				RC: "When the Cycle completes, calculate a new Open Time (time to pulse the$N"
				    "Open output) and Close Time (time to pulse the Close output).$N"
				    "$N"
				    "Details of this calculation are in the Instruction Help for the POSP built-in$N"
				    "instruction, from which this logic is derived.";
				N: [GEQ(Wrk_CycleT.ACC,Wrk_CycleT_ms) ,XIO(Wrk_CycleActive) ][OTU(Wrk_CycleActive) OTU(Wrk_BumpingOpen) OTU(Wrk_BumpingClose) CLR(Wrk_CycleT.ACC) ,XIC(Wrk_OKtoOpen) [CPT(Wrk_OpenTime,(Val_CVOut-Val_Pos)/Cfg_OpenRate) ,LES(Wrk_OpenTimePrev,Cfg_CycleT) ADD(Wrk_OpenTime,Cfg_Deadtime,Wrk_OpenTime) ,GRT(Wrk_OpenTime,Cfg_MaxOnT) MOV(Cfg_MaxOnT,Wrk_OpenTime) ,LES(Wrk_OpenTime,Cfg_MinOnT) CLR(Wrk_OpenTime) ] ,XIO(Wrk_OKtoOpen) XIO(Wrk_BumpOpen) CLR(Wrk_OpenTime) ,XIC(Wrk_BumpOpen) OTU(Wrk_BumpOpen) OTL(Wrk_BumpingOpen) MOV(Cfg_BumpT,Wrk_OpenTime) ,XIC(Wrk_OKtoClose) [CPT(Wrk_CloseTime,(Val_Pos-Val_CVOut)/Cfg_CloseRate) ,LES(Wrk_CloseTimePrev,Cfg_CycleT) ADD(Wrk_CloseTime,Cfg_Deadtime,Wrk_CloseTime) ,GRT(Wrk_CloseTime,Cfg_MaxOnT) MOV(Cfg_MaxOnT,Wrk_CloseTime) ,LES(Wrk_CloseTime,Cfg_MinOnT) CLR(Wrk_CloseTime) ] ,XIO(Wrk_OKtoClose) XIO(Wrk_BumpClose) CLR(Wrk_CloseTime) ,XIC(Wrk_BumpClose) OTU(Wrk_BumpClose) OTL(Wrk_BumpingClose) MOV(Cfg_BumpT,Wrk_CloseTime) ,[NEQ(Wrk_OpenTime,0.0) ,NEQ(Wrk_CloseTime,0.0) ] OTL(Wrk_CycleActive) ,MOV(Wrk_OpenTime,Wrk_OpenTimePrev) ,MOV(Wrk_CloseTime,Wrk_CloseTimePrev) ];
				RC: "If the Open output should be energized and the timer accumulator hasn$'t reached the Open time yet$N"
				    "(could be less than the cycle time, even zero), energize the Open request.$N"
				    "(We use a Work bit so we can send this to the position simulation logic above.)";
				N: [XIC(Wrk_OKtoOpen) XIO(Inp_ActuatorFault) ,XIC(Wrk_BumpingOpen) ]CMP(Wrk_CycleT.ACC<(Wrk_OpenTime*1000.0))OTE(Wrk_Open);
				RC: "If the Close output should be energized and the timer accumulator hasn$'t reached the Close time yet$N"
				    "(could be less than the cycle time, even zero), energize the Close request.$N"
				    "(We use a Work bit so we can send this to the position simulation logic above.)";
				N: [XIC(Wrk_OKtoClose) XIO(Inp_ActuatorFault) ,XIC(Wrk_BumpingClose) ]CMP(Wrk_CycleT.ACC<(Wrk_CloseTime*1000.0))OTE(Wrk_Close);
				RC: "If were not in simulation and the actuator is not faulted, go ahead and energize the real outputs$N"
				    "as determined by the logic above.";
				N: XIO(Inp_Sim)[XIC(Wrk_Open) OTE(Out_Open) ,XIC(Wrk_Close) OTE(Out_Close) ];
				RC: "============================================================$N"
				    "VALUES PROCESSING$N"
				    "============================================================$N"
				    "$N"
				    "Copy the working CV values to their $QVal_$Q output parameters, and based on Mode$N"
				    "and the Tracking configs, a";
				N: [MOV(Wrk_CVSet,Val_CVSet) MOV(Wrk_CVOut,Val_CVOut) ,XIC(Cfg_SetTrack) [XIO(Sts_Ovrd) XIO(Sts_Hand) ,XIC(Cfg_SetTrackOvrdHand) ] MOV(Val_CVSet,PSet_CV) MOV(Val_CVSet,XSet_CV) MOV(Val_CVSet,OSet_CV) ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Delet";
				N: OTL(IntlkTrip.PCfg_AllowExist)OTL(ActuatorFault.PCfg_AllowExist)OTL(IOFault.PCfg_AllowExist);
				RC: "Let the Alarm instance know if this object is taken Out of Service$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Now using P_CmdSrc, including Out of Service.  #####";
				N: XIC(CmdSrc.Sts_OoS)OTE(IntlkTrip.Inp_OoS)OTE(ActuatorFault.Inp_OoS)OTE(IOFault.Inp_OoS);
				RC: "Handle Interlock Trip Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IntlkTrip);
				RC: "Handle Device-Reported Actuator Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(ActuatorFault);
				RC: "Handle I/O Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q breadcrumb on the graphic symbol).";
				N: [XIC(IntlkTrip.Sts_AlmInh) ,XIC(ActuatorFault.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "A summary Bad Config status is provided, simply an OR of the individual bits.";
				N: [XIC(Nrdy_CfgErr) ,[XIC(IntlkTrip.Sts_Err) ,XIC(ActuatorFault.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "This rung generates the enumerated Device Status:$N"
				    "0 = At Target$N"
				    "1 = Ramping Down$N"
				    "2 = Ramping Up$N"
				    "3 = Clamped at CVMin$N"
				    "4 = Clamped at CVMax$N"
				    "5 = Bump Close requested or currently pulsing Out_Close$N"
				    "6 = Bump Open requested or currently pulsing Out_Open$N"
				    "$N"
				    "And this rung generates the enumerated Device Fault Status:$N"
				    "0 = none$N"
				    "32 = I/O Fault$N"
				    "34 = Configuration Error$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [CLR(Wrk_Sts) CLR(Wrk_Fault) ,[GRT(Wrk_OpenTime,0.0) XIO(Inp_ActuatorFault) ,XIC(Sts_Ramping) LES(Wrk_CVOut,Wrk_CVSet) ] MOV(2,Wrk_Sts) ,[GRT(Wrk_CloseTime,0.0) XIO(Inp_ActuatorFault) ,XIC(Sts_Ramping) GRT(Wrk_CVOut,Wrk_CVSet) ] MOV(1,Wrk_Sts) ,XIC(Sts_Clamped) [EQU(Wrk_CVOut,Cfg_MinCV) MOV(3,Wrk_Sts) ,EQU(Wrk_CVOut,Cfg_MaxCV) MOV(4,Wrk_Sts) ] ,[XIC(Wrk_BumpClose) ,XIC(Wrk_BumpingClose) ] OTE(Sts_BumpClose) MOV(5,Wrk_Sts) ,[XIC(Wrk_BumpOpen) ,XIC(Wrk_BumpingOpen) ] OTE(Sts_BumpOpen) MOV(6,Wrk_Sts) ,[XIC(Sts_IOFault) ,XIC(Nrdy_IOFault) ] MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed go";
				N: [CLR(Wrk_SrcQ) ,[XIO(Cfg_HasOpenLS) ,XIO(Cfg_HasClosedLS) ] MOV(1,Wrk_SrcQ) ,XIO(Cfg_HasOpenLS) XIO(Cfg_HasClosedLS) MOV(2,Wrk_SrcQ) ,XIC(Inp_ActuatorFault) MOV(32,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(SrcQ_IO,Wrk_SrcQ) ,[XIC(Cfg_HasOpenLS) XIO(Cfg_UseOpenLS) ,XIC(Cfg_HasClosedLS) XIO(Cfg_UseClosedLS) ] MOV(18,Wrk_SrcQ) ,XIC(Wrk_ShedHold) MOV(19,Wrk_SrcQ) ,XIC(Wrk_ShedIntlkCV) MOV(20,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ) ];
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for r";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) ,GRT(IntlkTrip.Val_Notify,Wrk_Notify) MOV(IntlkTrip.Val_Notify,Wrk_Notify) ,GRT(ActuatorFault.Val_Notify,Wrk_Notify) MOV(ActuatorFault.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(IntlkTrip.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(ActuatorFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTE(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_Notify,Val_NotifyAll) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(IntlkTrip.Sts_RdyAck) ,XIC(ActuatorFault.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(IntlkTrip.Sts_RdyReset) ,XIC(ActuatorFault.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ,XIC(Nrdy_IOFault) XIO(Sts_IOFault) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownership. clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, set the Ownership to NO OWNER (0).";
				N: CLR(PSet_Owner)CLR(Val_Owner);
				RC: "$QLurking$Q Operator Commands are cleared, as well as a Program Reset.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  Added External Command Source and Commands/Settings.  #####";
				N: [OTU(MCmd_Bypass) OTU(MCmd_Check) OTU(OCmd_BumpOpen) OTU(OCmd_BumpClose) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(XCmd_Reset) OTU(PCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####$N"
				    "#####  OSet_s and PSet_s for Rate of Change Limits replaced with Configs (Cfg_s).  #####$N"
				    "#####  Aligned ready bit naming with command bit names.  #####";
				N: [OTU(MRdy_Bypass) OTU(MRdy_Check) OTU(ORdy_BumpOpen) OTU(ORdy_BumpClose) ,OTU(ORdy_Reset) OTU(ORdy_ResetAckAll) OTU(Sts_RdyAck) OTU(ORdy_CV) ];
				RC: "Clear latched Shed (Not Ready) bits.";
				N: OTU(Nrdy_IOFault);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_ValveSO (Description := "Solenoid Operated Valve",
	                                         Revision := "4.10",
	                                         RevisionExtension := ".01 Release",
	                                         RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                         Vendor := "Rockwell Automation",
	                                         ExecutePrescan := Yes,
	                                         ExecutePostscan := No,
	                                         ExecuteEnableInFalse := Yes,
	                                         CreatedDate := "2008-03-27T19:50:50.098Z",
	                                         CreatedBy := "Not Available",
	                                         EditedDate := "2019-10-17T17:51:02.331Z",
	                                         EditedBy := "PROCESS\Library",
	                                         SoftwareRevision := "v18.02",
	                                         AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction controls and monitors a single solenoid operated$Nvalve (two position: opened, closed) and provides:$N$N*  Support for fail open (energize to close) and fail closed (energize to open, default) valves$N*  Monitoring of limit switch feedback, display of actual valve status$N*  Detection of Failure to Open, Failure to Close$N*  Monitoring of Permissive conditions to allow energizing$N*  Monitoring of Interlock conditions to de-energize$N*  Simulation, providing feedback of a working valve while disabling outputs$N*  Monitoring of I/O communication faults$N*  Alarms for Full Stall (didn$'t move), Transit Stall (didn$'t reach target position), Interlock Trip, I/O Fault$N*  Operation in Hand, Maintenance, Override, Program and Operator Modes$N*  $QAvailable$Q status for use by automation logic to know whether valve$N      can be controlled by other objects.$N$NCommand Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$NCommand Sources: Operator, External, Program, Override, Maintenance, Out of$NService, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* No changes, uprevved because P_CmdSrc 4.10.01 is used.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.02)$NSee 4.10 Release Notes for details.$N* Added audible alert on commanded energize.$N* Added Horn Status, Horn Inhibit.$N* Updated to P_CmdSrc V4.10.00.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.01)$NSee 4.00 Release Notes for details.$N* Modified handling of simultaneous open and close commands.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.00 Release Notes for details.$N* Corrected Reset Command logic.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-11)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added notify and unack count rollup for Channel object.$N* Changed $QMode$Q to $QCommand Source$Q using P_CmdSrc 4.00.00.$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* Aligned ready bit naming with command bit names.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyAck and Sts_RdyReset for use by external objects.$N* Changed delay / time configuration items to REAL seconds.$N")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_OpenLS : BOOL (Description := "Valve Open Limit Switch 1=confirmed OPEN",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 0);
			Inp_ClosedLS : BOOL (Description := "Valve Closed Limit Switch 1=confirmed CLOSED",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := 0);
			Inp_PermOK : BOOL (Description := "1=Permissives OK, Valve can energize",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      DefaultData := 1);
			Inp_NBPermOK : BOOL (Description := "1=Non-Bypassable Permissives OK, valve can energize",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        DefaultData := 1);
			Inp_IntlkOK : BOOL (Description := "1=Interlocks OK, valve can energize",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 1);
			Inp_NBIntlkOK : BOOL (Description := "1=Non-Bypassable Interlocks OK, valve can energize",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 1);
			Inp_IntlkAvail : BOOL (Description := "1 = Interlock Availibility OK",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Inp_IOFault : BOOL (Description := "Input Communication Status 0=OK, 1=fail",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Sim : BOOL (Description := "1=Simulate working valve; 0=Open/Close/ Monitor actual valve",
			                   Usage := Input,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   DefaultData := 0);
			Inp_Hand OF CmdSrc.Inp_Hand (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_Ovrd OF CmdSrc.Inp_Ovrd (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			Inp_OvrdCmd : DINT (Description := "Override Mode Command: 0=None, 1=Close, 2=Open",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_ExtInh OF CmdSrc.Inp_ExtInh (Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No);
			Inp_HornInh : BOOL (Description := "1 = Inhibit audible alert, 0 = Alllow audible alert",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Inp_Reset : BOOL (Description := "1=Reset all fault conditions and latched Alarms",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			Cfg_FailOpen : BOOL (Description := "1=Fail Open (energize to close), 0=Fail Closed (energize to open)",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_HasOpenLS : BOOL (Description := "1=Valve provides an Open Limit Switch signal",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_HasClosedLS : BOOL (Description := "1=Valve provides a Closed Limit Switch signal",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_UseOpenLS : BOOL (Description := "1=Valve Open LS should be used for failure checking",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         DefaultData := 0);
			Cfg_UseClosedLS : BOOL (Description := "1=Valve Closed LS should be used for failure checking",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_LSFail : BOOL (Description := "1=both switches ON=fail, 0=both switches OFF=fail",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 1);
			Cfg_HasPermObj : BOOL (Description := "1=Tells HMI a P_Perm is connected to Inp_Perm",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasIntlkObj : BOOL (Description := "1=Tells HMI a P_Intlk is connected to Inp_Intlk",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasStatsObj : BOOL (Description := "1=Tells HMI a P_ValveStats is monitoring this valve",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OCmdResets : BOOL (Description := "1=New valve OCmd resets shed latches and cleared alarms, 0=OCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_XCmdResets : BOOL (Description := "1=New valve XCmd resets shed latches and cleared alarms, 0=OCmdReset req$'d.",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_OvrdPermIntlk : BOOL (Description := "1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 0);
			Cfg_ShedOnFullStall : BOOL (Description := "1=Stop Valve and Alarm on Full Stall; 0=Alarm only on Full Stall",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               DefaultData := 1);
			Cfg_ShedOnTransitStall : BOOL (Description := "1=Stop Valve and Alarm on Transit Stall; 0=Alarm only on Transit Stall",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No,
			                                  DefaultData := 1);
			Cfg_ShedOnIOFault : BOOL (Description := "1=Stop Valve and Alarm on I/O Fault; 0=Alarm only on I/O Fault",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1);
			Cfg_HasFullStallAlm OF FullStall.Cfg_Exists (Description := "1=Full Stall Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasTransitStallAlm OF TransitStall.Cfg_Exists (Description := "1=Transit Stall Alarm exists and will be checked",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_HasIntlkTripAlm OF IntlkTrip.Cfg_Exists (Description := "1=Interlock Trip Alarm exists and will be checked",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_HasIOFaultAlm OF IOFault.Cfg_Exists (Description := "1=I/O Fault Alarm exists and will be checked",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			Cfg_FullStallResetReqd OF FullStall.Cfg_ResetReqd (Description := "1=Reset requied to clear Full Stall Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_TransitStallResetReqd OF TransitStall.Cfg_ResetReqd (Description := "1=Reset required to clear Transit Stall Alarm",
			                                     Usage := Input,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No);
			Cfg_IntlkTripResetReqd OF IntlkTrip.Cfg_ResetReqd (Description := "1=Reset required to clear Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			Cfg_IOFaultResetReqd OF IOFault.Cfg_ResetReqd (Description := "1=Reset required to clear I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_FullStallAckReqd OF FullStall.Cfg_AckReqd (Description := "1=Acknowledge required for Full Stall Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_TransitStallAckReqd OF TransitStall.Cfg_AckReqd (Description := "1=Acknowledge required for Transit Stall Alarm",
			                                   Usage := Input,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No);
			Cfg_IntlkTripAckReqd OF IntlkTrip.Cfg_AckReqd (Description := "1=Acknowledge required for Interlock Trip Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			Cfg_IOFaultAckReqd OF IOFault.Cfg_AckReqd (Description := "1=Acknowledge required for I/O Fault Alarm",
			                              Usage := Input,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No);
			Cfg_FullStallSeverity OF FullStall.Cfg_Severity (Description := "Full Stall Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_TransitStallSeverity OF TransitStall.Cfg_Severity (Description := "Transit Stall Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			Cfg_IntlkTripSeverity OF IntlkTrip.Cfg_Severity (Description := "Interlock Trip Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                                 Usage := Input,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No);
			Cfg_IOFaultSeverity OF IOFault.Cfg_Severity (Description := "I/O Fault Alarm Severity: 1..250=Low, 251..500=Medium, 501..750=High, 751..1000=Urgent",
			                               Usage := Input,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No);
			Cfg_SimFdbkT : REAL (Description := "Delay to echo back of Open/Closed status when in Simulation (sec)",
			                        Usage := Input,
			                        RADIX := Float,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 2.00000000e+000);
			Cfg_FullStallT : REAL (Description := "After command, time with no motion before Fault (sec)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 5.00000000e+000);
			Cfg_TransitStallT : REAL (Description := "After command, time to reach position before fault (sec)",
			                             Usage := Input,
			                             RADIX := Float,
			                             Required := No,
			                             Visible := No,
			                             DefaultData := 1.00000000e+001);
			Cfg_StartHornT : REAL (Description := "Time to sound audible on commanded start (sec) (0=disabled)",
			                          Usage := Input,
			                          RADIX := Float,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0.00000000e+000);
			PSet_Owner : DINT (Description := "Program Owner Request ID (non-zero) or Release (zero)",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_Open : BOOL (Description := "Program Command to Open Valve",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			PCmd_Close : BOOL (Description := "Program Command to Close Valve",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_Prog OF CmdSrc.PCmd_Prog (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Oper OF CmdSrc.PCmd_Oper (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Lock OF CmdSrc.PCmd_Lock (Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No);
			PCmd_Unlock OF CmdSrc.PCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Normal OF CmdSrc.PCmd_Normal (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			PCmd_Reset : BOOL (Description := "Program Command to ResetShed Latches and Cleared Alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			PCmd_FullStallAck OF FullStall.PCmd_Ack (Description := "Program Command to Acknowledge Full Stall Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_FullStallSuppress OF FullStall.PCmd_Suppress (Description := "Program Command to Suppress Full Stall Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_FullStallUnsuppress OF FullStall.PCmd_Unsuppress (Description := "Program Command to Unsuppress Full Stall Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_FullStallUnshelve OF FullStall.PCmd_Unshelve (Description := "Program Command to Unshelve Full Stall Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_TransitStallAck OF TransitStall.PCmd_Ack (Description := "Program Command to Acknowledge Transit Stall Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_TransitStallSuppress OF TransitStall.PCmd_Suppress (Description := "Program Command to Suppress Transit Stall Alarm",
			                                     Usage := Input,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No);
			PCmd_TransitStallUnsuppress OF TransitStall.PCmd_Unsuppress (Description := "Program Command to Unsuppress Transit Stall Alarm",
			                                       Usage := Input,
			                                       RADIX := Decimal,
			                                       Required := No,
			                                       Visible := No);
			PCmd_TransitStallUnshelve OF TransitStall.PCmd_Unshelve (Description := "Program Command to Unshelve Transit Stall Alarm",
			                                     Usage := Input,
			                                     RADIX := Decimal,
			                                     Required := No,
			                                     Visible := No);
			PCmd_IntlkTripAck OF IntlkTrip.PCmd_Ack (Description := "Program Command to Acknowledge Interlock Trip Alarm",
			                             Usage := Input,
			                             RADIX := Decimal,
			                             Required := No,
			                             Visible := No);
			PCmd_IntlkTripSuppress OF IntlkTrip.PCmd_Suppress (Description := "Program Command to Suppress Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IntlkTripUnsuppress OF IntlkTrip.PCmd_Unsuppress (Description := "Program Command to Unsuppress Interlock Trip Alarm",
			                                    Usage := Input,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No);
			PCmd_IntlkTripUnshelve OF IntlkTrip.PCmd_Unshelve (Description := "Program Command to Unshelve Interlock Trip Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultAck OF IOFault.PCmd_Ack (Description := "Program Command to Acknowledge I/O Fault Alarm",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No);
			PCmd_IOFaultSuppress OF IOFault.PCmd_Suppress (Description := "Program Command to Suppress I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			PCmd_IOFaultUnsuppress OF IOFault.PCmd_Unsuppress (Description := "Program Command to Unsuppress I/O Fault Alarm",
			                                  Usage := Input,
			                                  RADIX := Decimal,
			                                  Required := No,
			                                  Visible := No);
			PCmd_IOFaultUnshelve OF IOFault.PCmd_Unshelve (Description := "Program Command to Unshelve I/O Fault Alarm",
			                                Usage := Input,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No);
			MCmd_Rel OF CmdSrc.MCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			OCmd_Unlock OF CmdSrc.OCmd_Unlock (Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			XCmd_Open : BOOL (Description := "External Command to Open Valve",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     DefaultData := 0);
			XCmd_Close : BOOL (Description := "External Command to Close Valve",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			XCmd_Acq OF CmdSrc.XCmd_Acq (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Rel OF CmdSrc.XCmd_Rel (Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No);
			XCmd_Reset : BOOL (Description := "Ext Cmd to clear shed latches and cleared alarms",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Out : BOOL (Description := "1=Energize Valve Solenoid",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0);
			Out_Horn : BOOL (Description := "1=Sound audible prior to commanded motor start",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			SrcQ_IO : DINT (Description := "Source and Quality of primary I/O (enumeration)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			SrcQ : DINT (Description := "Source and Quality of primary Val/Sts (enumeration)",
			                Usage := Output,
			                RADIX := Decimal,
			                Required := No,
			                Visible := No,
			                ExternalAccess := Read Only,
			                DefaultData := 0);
			Val_Cmd : DINT (Description := "Device Command 0=None, 1=Close, 2=Open",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fdbk : DINT (Description := "Device Feedback 0=Moving, 1=Closed, 2=Opened, 3=Limit Switch Failure",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Val_Sts : DINT (Description := "Device Confirmed Sts 0=? 1=Closed 2=Open 5=Closing, 6=Opening",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Val_Fault : DINT (Description := "Device Fault Status 0=None, 16=Transit Stall, 17 = Full Stall, 32=I/O Fault, 34=Config Error",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Val_NotifyAll : DINT (Description := "Highest Alarm prio and ack status this object + channel (enum)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_UnackAlmC : DINT (Description := "Count of Unacknowledged Alarms",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Val_Owner : DINT (Description := "Current Object Owner ID (0=not owned)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Closed : BOOL (Description := "1=Valve requested to Close and is confirmed Closed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Opening : BOOL (Description := "1=Valve requested to open and awaiting open feedback",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_Opened : BOOL (Description := "1=Valve requested to open and is confirmed Opened",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := Yes,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Closing : BOOL (Description := "1=Valve requested to Close and awaiting Closed feedback",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_Horn : BOOL (Description := "1=Valve Horn Active",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Sts_Available : BOOL (Description := "1=Valve available for control by automation (Prog)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_Bypass : BOOL (Description := "1=Bypassable Interlocks and Permissives are Bypassed",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_BypActive : BOOL (Description := "1=Bypassing Active (Bypassed or Maintenance)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_LSFail : BOOL (Description := "1=Limit Switch Overlap Failure",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_NotRdy : BOOL (Description := "1=Device Not Ready, see detail bits for reason",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_CfgErr : BOOL (Description := "1=Device Not Ready: Configuration Error",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Nrdy_Fail : BOOL (Description := "1=Device Not Ready: Device Failure (Shed Requires Reset)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Nrdy_Intlk : BOOL (Description := "1=Device Not Ready: Interlock Not OK",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Nrdy_IOFault : BOOL (Description := "1=Device Not Ready: I/O Fault (Shed Requires Reset)",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Nrdy_OoS : BOOL (Description := "1=Device Not Ready: Device is Out of Service",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Nrdy_Perm : BOOL (Description := "1=Device Not Ready: Permissive Not OK",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_MaintByp : BOOL (Description := "1=A Maintenance Bypass is Active, display icon",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Sts_AlmInh : BOOL (Description := "1=An Alarm is Shelved, Disabled or Suppressed, display icon",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_Err : BOOL (Description := "1=Error in Config: see detail bits for reason",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Timer : BOOL (Description := "1=Error in Config: Invalid Check Time (use 0 to 2147483)",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Err_Sim : BOOL (Description := "1=Error in Config: Invalid Simulation Time (use 0 to 2147483)",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read Only,
			                   DefaultData := 0);
			Err_Alarm : BOOL (Description := "1=Error in Config: Alarm Min On Time, Shelf Time, Severity",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_Hand OF CmdSrc.Sts_Hand (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OoS OF CmdSrc.Sts_OoS (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Maint OF CmdSrc.Sts_Maint (Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only);
			Sts_Ovrd OF CmdSrc.Sts_Ovrd (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_Ext OF CmdSrc.Sts_Ext (Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := Yes,
			                   ExternalAccess := Read Only);
			Sts_Prog OF CmdSrc.Sts_Prog (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_ProgLocked OF CmdSrc.Sts_ProgLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Oper OF CmdSrc.Sts_Oper (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only);
			Sts_OperLocked OF CmdSrc.Sts_OperLocked (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_Normal OF CmdSrc.Sts_Normal (Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only);
			Sts_ExtReqInh OF CmdSrc.Sts_ExtReqInh (Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only);
			Sts_ProgReqInh OF CmdSrc.Sts_ProgReqInh (Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only);
			Sts_MAcqRcvd OF CmdSrc.Sts_MAcqRcvd (Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched alarm or shed condition is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_RdyAck : BOOL (Description := "1=An alarm is ready to be acknowledged",
			                      Usage := Output,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			Sts_FullStall OF FullStall.Inp (Description := "1=Valve Full Stall (failed to move at all)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_FullStall OF FullStall.Alm (Description := "1=Valve Full Stall (failed to move at all) Alarm",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_FullStall OF FullStall.Ack (Description := "1=Full Stall Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_FullStallDisabled OF FullStall.Disabled (Description := "1=Full Stall Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_FullStallShelved OF FullStall.Shelved (Description := "1=Full Stall Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_FullStallSuppressed OF FullStall.Suppressed (Description := "1=Full Stall Alarm has been Suppressed by Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_TransitStall OF TransitStall.Inp (Description := "1=Valve Transit Stall (did not reach target position)",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Alm_TransitStall OF TransitStall.Alm (Description := "1=Valve Transit Stall (did not reach target pos.) Alarm",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Ack_TransitStall OF TransitStall.Ack (Description := "1=Transit Stall Alarm has been acknowledged",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            ExternalAccess := Read/Write);
			Sts_TransitStallDisabled OF TransitStall.Disabled (Description := "1=Transit Stall Alarm has been Disabled by Maintenance",
			                                    Usage := Output,
			                                    RADIX := Decimal,
			                                    Required := No,
			                                    Visible := No,
			                                    ExternalAccess := Read/Write);
			Sts_TransitStallShelved OF TransitStall.Shelved (Description := "1=Transit Stall Alarm has been Shelved by Operator",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_TransitStallSuppressed OF TransitStall.Suppressed (Description := "1=Transit Stall Alarm has been Suppressed by Program",
			                                      Usage := Output,
			                                      RADIX := Decimal,
			                                      Required := No,
			                                      Visible := No,
			                                      ExternalAccess := Read/Write);
			Sts_IntlkTrip OF IntlkTrip.Inp (Description := "1=Valve de-energized by an Interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Alm_IntlkTrip OF IntlkTrip.Alm (Description := "1=Alarm: Valve de-energized by an Interlock NOT OK",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Ack_IntlkTrip OF IntlkTrip.Ack (Description := "1=Interlock Trip Alarm has been acknowledged",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read/Write);
			Sts_IntlkTripDisabled OF IntlkTrip.Disabled (Description := "1=Interlock Trip Alarm has been Disabled by Maintenance",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			Sts_IntlkTripShelved OF IntlkTrip.Shelved (Description := "1=Interlock Trip Alarm has been Shelved by Operator",
			                                Usage := Output,
			                                RADIX := Decimal,
			                                Required := No,
			                                Visible := No,
			                                ExternalAccess := Read/Write);
			Sts_IntlkTripSuppressed OF IntlkTrip.Suppressed (Description := "1=Interlock Trip Alarm has been Suppressed Program",
			                                   Usage := Output,
			                                   RADIX := Decimal,
			                                   Required := No,
			                                   Visible := No,
			                                   ExternalAccess := Read/Write);
			Sts_IOFault OF IOFault.Inp (Description := "I/O Comm Fault Status (0=OK, 1=Bad)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Alm_IOFault OF IOFault.Alm (Description := "1=I/O Fault Alarm",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Ack_IOFault OF IOFault.Ack (Description := "1=I/O Fault Alarm has been acknowledged",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read/Write);
			Sts_IOFaultDisabled OF IOFault.Disabled (Description := "1=I/O Fault Alarm has been Disabled by Maintenance",
			                               Usage := Output,
			                               RADIX := Decimal,
			                               Required := No,
			                               Visible := No,
			                               ExternalAccess := Read/Write);
			Sts_IOFaultShelved OF IOFault.Shelved (Description := "1=I/O Fault Alarm has been Shelved by Operator",
			                              Usage := Output,
			                              RADIX := Decimal,
			                              Required := No,
			                              Visible := No,
			                              ExternalAccess := Read/Write);
			Sts_IOFaultSuppressed OF IOFault.Suppressed (Description := "1=I/O Fault Alarm has been Suppressed by Program",
			                                 Usage := Output,
			                                 RADIX := Decimal,
			                                 Required := No,
			                                 Visible := No,
			                                 ExternalAccess := Read/Write);
			MRdy_Rel OF CmdSrc.MRdy_Rel (Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			ORdy_Unlock OF CmdSrc.ORdy_Unlock (Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only);
			P_ValveSO : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			CmdSrc : P_CmdSrc (Description := "Valve Mode Selection",
			                 ExternalAccess := Read/Write,
			                 DefaultData := "[7649,0,0,1,0,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']]");
			IOFault : P_Alarm (Description := "I/O Fault Alarm",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			IntlkTrip : P_Alarm (Description := "Interlock Trip Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			TransitStall : P_Alarm (Description := "Valve Transit Stall (moved but did not reach target) Alarm",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			FullStall : P_Alarm (Description := "Valve Full Stall (did not move) Alarm",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[961,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,2,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0]");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[9,'P_ValveSO$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[13,'Valve Control$00$00$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_Open : BOOL (Description := "1=Requested to OPEN Valve, 0=Requested to CLOSE Valve",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Wrk_SimOpenT : TIMER (Description := "Simulation Delay until Opened",
			                       ExternalAccess := None,
			                       DefaultData := "[0,0,0]");
			Wrk_SimCloseT : TIMER (Description := "Simulation Delay until Closed",
			                        ExternalAccess := None,
			                        DefaultData := "[0,0,0]");
			Wrk_OpenFdbk : BOOL (Description := "1=LS Feedback shows valve confirmed open",
			                       RADIX := Decimal,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_Notify : DINT (Description := "Buffer for building Val_Notify",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_Bypass : BOOL (Description := "Internal Bypassable Permissives and Interlocks are Bypassed flag",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_ClosedFdbk : BOOL (Description := "1=LS Feedback shows valve confirmed closed",
			                         RADIX := Decimal,
			                         ExternalAccess := None,
			                         DefaultData := 0);
			Wrk_TransitStallT : TIMER (Description := "Timer for Transit Stall Check",
			                            ExternalAccess := Read Only,
			                            DefaultData := "[0,0,0]");
			Wrk_FullStallT : TIMER (Description := "Timer for Full Stall Check",
			                         ExternalAccess := Read Only,
			                         DefaultData := "[0,0,0]");
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_Cmd : DINT (Description := "Buffer for building Val_Cmd",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Sts : DINT (Description := "Buffer for building Val_Sts",
			                  RADIX := Decimal,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_Fault : DINT (Description := "Buffer for building Val_Fault",
			                    RADIX := Decimal,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			HMI_Type : STRING_16 (Description := "Type identifier for HMI navigation",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[9,'P_ValveSO$00$00$00$00$00$00$00']");
			Wrk_SimOpenLS : BOOL (Description := "Simulated valve Open Limit Switch",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_SimClosedLS : BOOL (Description := "Simulated valve Closed Limit Switch",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			Wrk_SrcQ : DINT (Description := "Register for building Source / Quality enumeration",
			                   RADIX := Decimal,
			                   ExternalAccess := None,
			                   DefaultData := 0);
			Val_Notify : DINT (Description := "Current Alarm Level and Acknowledgement (enumeration)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Wrk_NotRdy : BOOL (Description := "Device Not Ready conditions excluding shed latches",
			                     RADIX := Decimal,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			Wrk_NoLongerSim : BOOL (Description := "Switched from Simulated to Real Valve this scan",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			OCmd_Close : BOOL (Description := "Operator Command to Close Valve",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			OCmd_Open : BOOL (Description := "Operator Command to Open Valve",
			                    RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
			ORdy_ResetAckAll : BOOL (Description := "1=Ready for OCmd_ResetAckAll (enables HMI button)",
			                           RADIX := Decimal,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Check : BOOL (Description := "1=Ready for MCmd_Check (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			MRdy_Bypass : BOOL (Description := "1=Ready for MCmd_Bypass (enables HMI button)",
			                      RADIX := Decimal,
			                      ExternalAccess := Read Only,
			                      DefaultData := 0);
			ORdy_Close : BOOL (Description := "1=Ready for OCmd_Close (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			ORdy_Open : BOOL (Description := "1=Ready for OCmd_Open (enables HMI button)",
			                    RADIX := Decimal,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			MCmd_Check : BOOL (Description := "Maintenance Command to Check (not bypass) all Interlocks and Permissives",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			MCmd_Bypass : BOOL (Description := "Maintenance Command to Bypass all Bypassable Interlocks and Permissives",
			                      RADIX := Decimal,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			OCmd_ResetAckAll : BOOL (Description := "Oper Cmd to reset shed latches and cleared alarms, plus  Acknowledge alarms",
			                           RADIX := Decimal,
			                           ExternalAccess := Read/Write,
			                           DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Oper Cmd to clear shed latches and cleared alarms",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
			Wrk_UnackAlmC : DINT (Description := "Buffer for building Val_UnackAlmC",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
			Wrk_CloseCmdRcvd : BOOL (Description := "1=Received a Close command this scan",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_OpenCmdRcvd : BOOL (Description := "1=Received an Open command this scan",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			Wrk_StartHornT : TIMER (Description := "Timer for audible alert on start",
			                         ExternalAccess := None,
			                         DefaultData := "[0,0,0]");
			Wrk_StartHorn : BOOL (Description := "1=Sound audible prior to commanded motor start",
			                        RADIX := Decimal,
			                        ExternalAccess := None,
			                        DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Out of Service is asserted; Outputs OFF; Valve Status shown but Alarms inhibited.")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    "Handle $QProgrammed Out of Servie$Q Selection using the standard$N"
				    "P_CmdSrc AOI (EnableInFalse Routine, false scan required!).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc.  #####";
				N: XIC(EnableIn)P_CmdSrc(CmdSrc);
				RC: "First-Come First-Served Ownership Arbitration still needs to happen, even when device is disabled.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "$QLurking$Q Commands not handled elsewhere are cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [OTU(PCmd_Open) OTU(PCmd_Close) ,OTU(OCmd_Open) OTU(OCmd_Close) ,OTU(XCmd_Open) OTU(XCmd_Close) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,CLR(Inp_OvrdCmd) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(PCmd_Reset) OTU(XCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_Open) OTU(ORdy_Close) OTU(ORdy_Reset) OTU(Sts_RdyAck) OTU(ORdy_ResetAckAll) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ];
				RC: "============================================================$N"
				    "LIMIT SWITCH FEEDBACK DETERMINATION$N"
				    "============================================================$N"
				    "This first $QOpen$Q feedback is a copy of the Open Limit Switch, if it is being$N"
				    "used, or a copy of the OPPOSITE of the Closed Limit Switch, if ONLY the$N"
				    "Closed Limit Switch is being used.";
				N: [XIC(Cfg_UseOpenLS) XIC(Inp_OpenLS) ,XIO(Cfg_UseOpenLS) XIC(Cfg_UseClosedLS) XIO(Inp_ClosedLS) ]OTE(Wrk_OpenFdbk);
				RC: "This first $QClosed$Q feedback is a copy of the Closed Limit Switch, if it is being$N"
				    "used, or a copy of the OPPOSITE of the Open Limit Switch, if ONLY the$N"
				    "Open Limit Switch is being used.";
				N: [XIC(Cfg_UseClosedLS) XIC(Inp_ClosedLS) ,XIO(Cfg_UseClosedLS) XIC(Cfg_UseOpenLS) XIO(Inp_OpenLS) ]OTE(Wrk_ClosedFdbk);
				RC: "============================================================$N"
				    "VALVE FEEDBACK STATUS$N"
				    "============================================================$N"
				    "This rung generates the Valve Feedback Status bits and Enumeration Value:$N"
				    "Limit Switch Fail, if the Limit Switches are in the fail position (won$'t be seen in Simulation)$N"
				    "Opened, if the valve is confirmed opened$N"
				    "Closed, if the valve is confirmed closed$N"
				    "Moving, if the Limit Switches show travel";
				N: [XIO(Inp_Sim) [[XIC(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ] OTE(Sts_LSFail) MOV(3,Val_Fdbk) ,XIC(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) OTE(Sts_Opened) MOV(2,Val_Fdbk) ,XIC(Wrk_ClosedFdbk) XIO(Wrk_OpenFdbk) OTE(Sts_Closed) MOV(1,Val_Fdbk) ] ,[[XIC(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ] ,XIC(Inp_Sim) ] [XIO(Cfg_FailOpen) OTE(Sts_Closing) ,XIC(Cfg_FailOpen) OTE(Sts_Opening) ] CLR(Val_Fdbk) ];
				RC: "Reset the fault condition and simulation timers.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [RES(Wrk_FullStallT) RES(Wrk_TransitStallT) RES(Wrk_SimOpenT) RES(Wrk_SimCloseT) ,[XIO(Cfg_FailOpen) OTU(Wrk_Open) ,XIC(Cfg_FailOpen) OTL(Wrk_Open) ] ,OTU(Wrk_SimOpenLS) OTU(Wrk_SimClosedLS) ,OTU(Wrk_StartHorn) ];
				RC: "Outputs are cleared when Disabled (EnableInFalse).$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [OTU(Out) ,OTU(Out_Horn) ];
				RC: "Show the current state of the valve.";
				N: [XIC(Wrk_ClosedFdbk) MOV(1,Val_Sts) ,XIC(Wrk_OpenFdbk) MOV(2,Val_Sts) ,XIO(Wrk_ClosedFdbk) XIO(Wrk_OpenFdbk) [XIC(Cfg_FailOpen) MOV(6,Val_Sts) ,XIO(Cfg_FailOpen) MOV(5,Val_Sts) ] ];
				RC: "Show the motor as Disabled and Not Ready, not Available, and with no$N"
				    "Maintenance Bypass breadcrumb.$N"
				    "Clear remaining Status bits.$N"
				    "Show the enumerated valve command as NONE.$N"
				    "Show the enumerated valve fault status as NONE.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable and NoMode replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [OTL(Sts_NotRdy) OTU(Sts_Available) OTU(Sts_MaintByp) ,OTU(Nrdy_CfgErr) OTU(Nrdy_Fail) OTU(Nrdy_Intlk) ,OTL(Nrdy_OoS) OTU(Nrdy_IOFault) OTU(Nrdy_Perm) ,CLR(Val_Cmd) CLR(Val_Fault) ];
				RC: "If this Analog Output is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then show the alarms as $QParent object out of service$Q.$N"
				    "Show the overall acknowledgement status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc, added Out of Service.  #####";
				N: [OTL(FullStall.Inp_OoS) P_Alarm(FullStall) ,OTL(TransitStall.Inp_OoS) P_Alarm(TransitStall) ,OTL(IntlkTrip.Inp_OoS) P_Alarm(IntlkTrip) ,OTL(IOFault.Inp_OoS) P_Alarm(IOFault) ,CLR(Val_Notify) CLR(Val_NotifyAll) ,[XIC(FullStall.Val_Notify.0) ,XIC(TransitStall.Val_Notify.0) ,XIC(IntlkTrip.Val_Notify.0) ,XIC(IOFault.Val_Notify.0) ] OTL(Val_Notify.0) OTL(Val_NotifyAll.0) ,[XIC(FullStall.Sts_AlmInh) ,XIC(TransitStall.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ] OTE(Sts_AlmInh) ];
				RC: "============================================================$N"
				    "ENUMERATED STATUS VALUES$N"
				    "============================================================$N"
				    "Source and Quality (Srcq) for Val_InpPV$N"
				    "Start with the Srcq from the Input Channel object if it$'s available.$N"
				    "Otherwise, start based on bad/uncertain input bits.$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [CLR(Wrk_SrcQ) ,[XIO(Cfg_HasOpenLS) ,XIO(Cfg_HasClosedLS) ] MOV(1,Wrk_SrcQ) ,XIO(Cfg_HasOpenLS) XIO(Cfg_HasClosedLS) MOV(2,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: MOV(20,SrcQ);
		END_ROUTINE

		ROUTINE Logic (Description := "Normal Scan: control / monitor solenoid-operated valve")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_ValveSO:  PROCESS -- SOLENOID OPERATED VALVE$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-17:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, V3.x Revision History archived.$N"
				    "V4.00.00  2018-07-16:  Changed $QMode$Q to $QCommand Source$Q. Changed Inf_ items$N"
				    "to HMI_, and added Cfg_Area for security. Added unacked alarm count.$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "Aligned ready bit naming with command bit names.$N"
				    "Changed delay / time configuration items to REAL seconds.$N"
				    "V4.00.01  2018-08-24:  Corrected Reset Command logic.$N"
				    "V4.00.02  2018-11-02:  Modified handling of simultaneous open and close commands.$N"
				    "V4.10.00  2019-03-25:  Added audible alert on commanded energize. Added Horn$N"
				    "Status, Horn Inhibit. Updated to P_CmdSrc V4.10.00. Added Cfg_HasMoreObj.$N"
				    "V4.10.01  2019-10-17:  No changes, uprevved because P_CmdSrc 4.10.01 is used.$N"
				    "============================================================$N"
				    "This Instruction controls and monitors a single solenoid operated$N"
				    "valve (typ. two position: opened, closed) and provides:$N"
				    "$N"
				    "*  Support for fail open (energize to close) and fail closed (energize to open, default) valves$N"
				    "*  Monitoring of limit switch feedback, display of actual valve status$N"
				    "*  Detection of failure to move (full stall), failure to reach position (transit stall)$N"
				    "*  Monitoring of Permissive conditions to allow energizing$N"
				    "*  Monitoring of Interlock conditions to de-energize$N"
				    "*  Simulation, providing feedback of a working valve while disabling outputs$N"
				    "*  Monitoring of I/O communication faults$N"
				    "*  Alarms for Full Stall, Transit Stall, Interlock Trip, I/O Fault$N"
				    "*  $QAvailable$Q status for use by automation logic to know whether valve$N"
				    "can be controlled by other objects.$N"
				    "$N"
				    "Command Sources are arbitrated by a P_CmdSrc Add-On Instruction instance.$N"
				    "Command Sources: Operator, External, Program, External, Override, Maintenance,$N"
				    "Out of Service, Hand.  Alarms are provided by P_Alarm Add-On Instruction instances.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added string for Cfg_Area, renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)LOWER(Cfg_Desc,Cfg_Label)LOWER(Cfg_Tag,Cfg_Area)LOWER(HMI_Lib,HMI_Type);
				RC: "This rung handles received Command Source selection Inputs and Commands:$N"
				    "$N"
				    "NOTE:  All Commands for Command Source and Alarm are aliased directly to the$N"
				    "corresponding Commands in the contained P_CmdSrc and P_Alarm AOIs.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc.  #####";
				N: LBL(SkipText)P_CmdSrc(CmdSrc);
				RC: "This rung handles simple First-Come First-Served Ownership Arbitration.$N"
				    "If a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$N"
				    "Ownership is assigned to the requesting ID.  When that requestor sets the Owner ID back$N"
				    "to zero, Ownership is relinquished back to NONE.";
				N: [EQU(PSet_Owner,0) ,EQU(Val_Owner,0) ]MOV(PSet_Owner,Val_Owner);
				RC: "============================================================$N"
				    "CONFIGURATION$N"
				    "============================================================$N"
				    "If the Valve does not have an Open Limit Switch input,$N"
				    "it cannot be used for Valve feedback checking.";
				N: XIO(Cfg_HasOpenLS)OTU(Cfg_UseOpenLS);
				RC: "If the Valve does not have a Closed Limit Switch input,$N"
				    "it cannot be used for Valve feedback checking.";
				N: XIO(Cfg_HasClosedLS)OTU(Cfg_UseClosedLS);
				RC: "Enter the time (in seconds) for the Valve to successfully move from its starting position before declaring a fault.$N"
				    "Enter the time (in seconds) for the Valve to successfully reach its target position before declaring a fault.$N"
				    "Enter the time (in seconds) to pulse the valve outputs (Out_Open, Out_Close and Out_Stop)$N"
				    "(zero - held on continuously)$N"
				    "$N"
				    "If the timer preset calcuated wraps negative (more than 2.14... million seconds), then max out the$N"
				    "Timer Preset.  Note that a negative timer preset will fault the controller!!!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed delay / time configuration items to REAL seconds.  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####$N"
				    "#####  Added Inp_HornInh to disable Horn operation.  #####";
				N: [[MUL(Cfg_FullStallT,1000.0,Wrk_FullStallT.PRE) XIC(Wrk_FullStallT.PRE.31) MOV(2147483647,Wrk_FullStallT.PRE) ,MUL(Cfg_TransitStallT,1000.0,Wrk_TransitStallT.PRE) XIC(Wrk_TransitStallT.PRE.31) MOV(2147483647,Wrk_TransitStallT.PRE) ,MUL(Cfg_StartHornT,1000.0,Wrk_StartHornT.PRE) XIC(Wrk_StartHornT.PRE.31) CLR(Wrk_StartHornT.PRE) ] OTE(Err_Timer) ,[XIC(Inp_HornInh) ,GRT(Cfg_StartHornT,1000.0) CLR(Cfg_StartHornT) ] CLR(Wrk_StartHornT.PRE) ];
				RC: "Enter the time (in seconds) to echo back the desired state when Opened or Closed in simulation$N"
				    "$N"
				    "Handle timer preset invalid values as above.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed delay / time configuration items to REAL seconds.  #####";
				N: [MUL(Cfg_SimFdbkT,1000.0,Wrk_SimOpenT.PRE) XIC(Wrk_SimOpenT.PRE.31) CLR(Wrk_SimOpenT.PRE) OTE(Err_Sim) ,MOV(Wrk_SimOpenT.PRE,Wrk_SimCloseT.PRE) ];
				RC: "This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N"
				    "(in the Configuration handling section).";
				N: [XIC(Err_Timer) ,XIC(Err_Sim) ]OTE(Nrdy_CfgErr);
				RC: "============================================================$N"
				    "SIMULATION TIMERS$N"
				    "============================================================$N"
				    "If the Valve SHOULD BE Opened, run an Open Simulation Timer.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: XIC(Wrk_Open)XIO(Wrk_StartHorn)TON(Wrk_SimOpenT,?,?);
				RC: "If the valve SHOULD BE CLosed, run a Close Simulation Timer.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: XIO(Wrk_Open)XIO(Wrk_StartHorn)TON(Wrk_SimCloseT,?,?);
				RC: "When 1/4 of the valve simulation open time has expired, move off the simulated closed limit switch.";
				N: CMP(Wrk_SimOpenT.ACC>(Wrk_SimOpenT.PRE/4))[XIC(Cfg_LSFail) OTU(Wrk_SimClosedLS) ,XIO(Cfg_LSFail) OTL(Wrk_SimOpenLS) ];
				RC: "When 1/4 of the valve simulation close time has expired, move off the simulated open limit switch.";
				N: CMP(Wrk_SimCloseT.ACC>(Wrk_SimCloseT.PRE/4))[XIC(Cfg_LSFail) OTU(Wrk_SimOpenLS) ,XIO(Cfg_LSFail) OTL(Wrk_SimClosedLS) ];
				RC: "When the valve simulation open time has expired, move onto the simulated open limit switch.";
				N: XIC(Wrk_SimOpenT.DN)OTL(Wrk_SimOpenLS)OTU(Wrk_SimClosedLS);
				RC: "When the valve simulation close time has expired, move onto the simulated closed limit switch.";
				N: XIC(Wrk_SimCloseT.DN)OTL(Wrk_SimClosedLS)OTU(Wrk_SimOpenLS);
				RC: "============================================================$N"
				    "DEVICE FEEDBACK PROCESSING$N"
				    "============================================================$N"
				    "If the Valve is NOT being simulated and it HAS and IS USING limit switch feedback,$N"
				    "use the state of the limit switch feedback inputs as the Valve position.$N"
				    "$N"
				    "If the Valve is being simulated or has no limit switch feedback, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to Open and time to Close.";
				N: [XIO(Inp_Sim) [XIC(Cfg_UseOpenLS) XIC(Inp_OpenLS) ,XIO(Cfg_UseOpenLS) XIC(Cfg_UseClosedLS) XIO(Inp_ClosedLS) ] ,[XIC(Inp_Sim) ,XIO(Cfg_UseOpenLS) XIO(Cfg_UseClosedLS) ] XIC(Wrk_SimOpenLS) ]OTE(Wrk_OpenFdbk);
				RC: "If the Valve is NOT being simulated and it HAS and IS USING limit switch feedback,$N"
				    "use the state of the limit switch feedback inputs as the Valve position.$N"
				    "$N"
				    "If the Valve is being simulated or has no limit switch feedback, use the Sim Timers to provide$N"
				    "$Qfake$Q feedback signals based on the simulation time to Open and time to Close.";
				N: [XIO(Inp_Sim) [XIC(Cfg_UseClosedLS) XIC(Inp_ClosedLS) ,XIO(Cfg_UseClosedLS) XIC(Cfg_UseOpenLS) XIO(Inp_OpenLS) ] ,[XIC(Inp_Sim) ,XIO(Cfg_UseClosedLS) XIO(Cfg_UseOpenLS) ] XIC(Wrk_SimClosedLS) ]OTE(Wrk_ClosedFdbk);
				RC: "This rung generates the Valve Feedback Status bits and Enumeration Value:$N"
				    "Limit Switch Fail, if the Limit Switches are in the fail position (won$'t be seen in Simulation)$N"
				    "Opened, if the valve is confirmed opened$N"
				    "Closed, if the valve is confirmed closed$N"
				    "Moving, if the Limit Switches show travel";
				N: [[XIC(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ] OTE(Sts_LSFail) MOV(3,Val_Fdbk) ,XIC(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) MOV(2,Val_Fdbk) ,XIC(Wrk_ClosedFdbk) XIO(Wrk_OpenFdbk) MOV(1,Val_Fdbk) ,[XIC(Cfg_LSFail) XIO(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) ,XIO(Cfg_LSFail) XIC(Wrk_OpenFdbk) XIC(Wrk_ClosedFdbk) ] CLR(Val_Fdbk) ];
				RC: "============================================================$N"
				    "INTERLOCK / PERMISSIVE BYPASS / CHECK COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Bypass Command bypasses the Bypassable Permissives and Interlocks.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc. Bypass now a Maintenance function.  #####";
				N: XIC(MCmd_Bypass)OTU(MCmd_Bypass)OTL(Wrk_Bypass);
				RC: "The Check Command enables checking of ALL$N"
				    "Permissives and Interlocks (cancels the bypass).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc. Bypass now a Maintenance function.  #####";
				N: XIC(MCmd_Check)OTU(MCmd_Check)OTU(Wrk_Bypass);
				RC: "If the internal Bypass flag is set, Bypassable Interlocks and Permissives ARE BYPASSED.$N"
				    "Bypassing is ACTIVE if Bypass selected OR in Maintenance Mode,$N"
				    "or in Override Mode if Override Bypassing is configured.";
				N: [XIC(Wrk_Bypass) OTE(Sts_Bypass) ,XIC(Sts_Maint) ,XIC(Sts_Ovrd) XIC(Cfg_OvrdPermIntlk) ]OTE(Sts_BypActive);
				RC: "If a Maintenance Bypass function is active, display the Maintenance Bypass$N"
				    "Indicator (triangle symbol) on the graphic symbol.  Bypass functions are:$N"
				    "*  Interlock / Permissive Bypass function is enabled$N"
				    "*  Valve HAS opened position feedback designated by engineer, but$N"
				    "maintenance has selected to NOT USE opened position feedback$N"
				    "*  Valve HAS closed position feedback designated by engineer, but$N"
				    "maintenance has selected to NOT USE closed position feedback";
				N: [XIC(Sts_Bypass) ,XIC(Cfg_HasOpenLS) XIO(Cfg_UseOpenLS) ,XIC(Cfg_HasClosedLS) XIO(Cfg_UseClosedLS) ]OTE(Sts_MaintByp);
				RC: "Ready for Interlock / Permissive Bypass if not bypassed.$N"
				    "Ready to cancel Bypass (resume checking) if bypassed.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Changed P_Mode to P_CmdSrc. Bypass now a Maintenance function.  #####";
				N: [XIO(Wrk_Bypass) OTE(MRdy_Bypass) ,XIC(Wrk_Bypass) OTE(MRdy_Check) ];
				RC: "============================================================$N"
				    "ALARM RESET COMMAND HANDLING$N"
				    "============================================================$N"
				    "This rung handles the Alarm Reset Input and Commands$N"
				    "and the $QReset and Ack All$Q Operator Command.$N"
				    "$N"
				    "This rung processes received Reset Commands from:$N"
				    "$N"
				    "1.  The Operator via HMI Operator Command, or$N"
				    "2.  Higher-level strategies via Program Command$N"
				    "3.  Pushbuttons or other block via Input$N"
				    "4.  Resets initiated by other device Operator Commands (if configured to do so)$N"
				    "and forwards the Reset to ALL Alarms and latched Shed conditions.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####$N"
				    "#####  V4.00.01  2018-08-24:  Corrected Reset Command logic.  #####";
				N: [XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(XCmd_Reset) OTU(XCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ,XIC(Cfg_OCmdResets) [XIC(OCmd_Open) ,XIC(OCmd_Close) ] [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(Cfg_XCmdResets) [XIC(XCmd_Open) ,XIC(XCmd_Close) ] XIC(Sts_Ext) ,XIC(OCmd_ResetAckAll) OTU(OCmd_ResetAckAll) [OTL(PCmd_FullStallAck) ,OTL(PCmd_TransitStallAck) ,OTL(PCmd_IntlkTripAck) ,OTL(PCmd_IOFaultAck) ] ][OTL(FullStall.PCmd_Reset) OTL(TransitStall.PCmd_Reset) OTL(IntlkTrip.PCmd_Reset) OTL(IOFault.PCmd_Reset) ,XIC(Sts_FullStall) RES(Wrk_FullStallT) ,XIC(Sts_TransitStall) RES(Wrk_TransitStallT) ,OTU(Nrdy_Fail) ,[XIO(Inp_IOFault) ,XIC(Inp_Sim) ] OTU(Nrdy_IOFault) ];
				RC: "============================================================$N"
				    "VALVE FULL STALL DETECTION$N"
				    "============================================================$N"
				    "If the Valve was told to Open and it hasn$'t moved off the Fully Closed position,$N"
				    "or if it was told to Close and it hasn$'t moved off the Fully Open position,$N"
				    "run the Full Stall Timer.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIC(Wrk_Open) EQU(Val_Fdbk,1) ,XIO(Wrk_Open) EQU(Val_Fdbk,2) ]XIO(Sts_Maint)XIO(Wrk_TransitStallT.DN)XIO(Wrk_StartHorn)TON(Wrk_FullStallT,?,?);
				RC: "If the Full Stall timer times out, the valve never moved when it was commanded.$N"
				    "If we$'re not in Maintenance mode, issue a Full Stall Status.";
				N: XIC(Wrk_FullStallT.DN)OTE(Sts_FullStall);
				RC: "============================================================$N"
				    "VALVE TRANSIT STALL DETECTION$N"
				    "============================================================$N"
				    "If the Valve was told to Open and it hasn$'t reached fully Open,$N"
				    "or if it was told to Close and it hasn$'t reached fully Closed,$N"
				    "run the Transit Stall Timer.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIC(Wrk_Open) NEQ(Val_Fdbk,2) ,XIO(Wrk_Open) NEQ(Val_Fdbk,1) ]XIO(Sts_Maint)XIO(Wrk_FullStallT.DN)XIO(Wrk_StartHorn)TON(Wrk_TransitStallT,?,?);
				RC: "If the Transit Stall timer times out and we$'re not in Maintenance Mode,$N"
				    "raise the Transit Stall Status (valve moved but did not reach target).";
				N: XIC(Wrk_TransitStallT.DN)OTE(Sts_TransitStall);
				RC: "============================================================$N"
				    "SHED ON FAULT LOGIC$N"
				    "============================================================$N"
				    "This rung handles latching in of conditions which are configured to cause$N"
				    "the valve to shed (de-energize).";
				N: [XIC(Sts_FullStall) XIC(Cfg_ShedOnFullStall) ,XIC(Sts_TransitStall) XIC(Cfg_ShedOnTransitStall) ]OTL(Nrdy_Fail);
				RC: "============================================================$N"
				    "VALVE COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Valve is NOT READY if Interlocks are not OK, Permissives do not allow$N"
				    "the valve to move, there is a latched Fault, the valve is disabled, or$N"
				    "there is a configuration error.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIC(Nrdy_CfgErr) ,XIC(Sts_OoS) OTE(Nrdy_OoS) ,[XIO(Inp_IntlkOK) XIO(Sts_BypActive) ,XIO(Inp_NBIntlkOK) ] [[XIC(Cfg_FailOpen) XIO(Wrk_Open) ,XIO(Cfg_FailOpen) XIC(Wrk_Open) ] OTE(Sts_IntlkTrip) ,OTE(Nrdy_Intlk) ] ,[XIO(Inp_PermOK) XIO(Sts_BypActive) ,XIO(Inp_NBPermOK) ] [XIO(Wrk_Open) XIO(Cfg_FailOpen) ,XIC(Wrk_Open) XIC(Cfg_FailOpen) ] OTE(Nrdy_Perm) ,XIC(Inp_IOFault) XIO(Inp_Sim) OTE(Sts_IOFault) XIC(Cfg_ShedOnIOFault) OTL(Nrdy_IOFault) ]OTE(Wrk_NotRdy);
				RC: "============================================================$N"
				    "VALVE COMMAND HANDLING$N"
				    "============================================================$N"
				    "The Valve is NOT READY if Interlocks are not OK, Permissives do not allow$N"
				    "the valve to move, there is a latched Fault, the valve is disabled, or$N"
				    "there is a configuration error.";
				N: [XIC(Wrk_NotRdy) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) ]OTE(Sts_NotRdy);
				RC: "The motor is AVAILABLE to be run by automation if it is in PROGRAM$N"
				    "Mode and the $QNot Ready$Q status is cleared.$N"
				    "#####  V4.10.00  2019-03-25:  Changed availability to use input availability from interlocks.  #####";
				N: XIC(Sts_Prog)XIO(Nrdy_Fail)XIO(Nrdy_IOFault)XIO(Nrdy_Perm)XIO(Nrdy_CfgErr)XIO(Nrdy_OoS)[[XIC(Inp_IntlkOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBIntlkOK) ,XIC(Inp_IntlkAvail) ]OTE(Sts_Available);
				RC: "If a Valve CLOSE command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is CLOSE, mark the valve TO CLOSE.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####$N"
				    "#####  V4.00.02  2018-11-02:  Modified handling of simultaneous Commands.  #####";
				N: [XIC(OCmd_Close) OTU(OCmd_Close) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_Close) OTU(XCmd_Close) XIC(Sts_Ext) ,XIC(PCmd_Close) OTU(PCmd_Close) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,1) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]OTE(Wrk_CloseCmdRcvd);
				RC: "If a Valve OPEN command is received in Operator, Program or Maintenance,$N"
				    "or if in Override and the Override State is OPEN, mark the valve TO OPEN.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####$N"
				    "#####  Added External Command Source and Commands.  #####$N"
				    "#####  V4.00.02  2018-11-02:  Modified handling of simultaneous Commands.  #####";
				N: [XIC(OCmd_Open) OTU(OCmd_Open) [XIC(Sts_Oper) ,XIC(Sts_Maint) ] ,XIC(XCmd_Open) OTU(XCmd_Open) XIC(Sts_Ext) ,XIC(PCmd_Open) OTU(PCmd_Open) XIC(Sts_Prog) ,EQU(Inp_OvrdCmd,2) CLR(Inp_OvrdCmd) XIC(Sts_Ovrd) ]OTE(Wrk_OpenCmdRcvd);
				RC: "If a Valve CLOSE command is received and there$'s no OPEN command (or closed is the fail state),$N"
				    "then check permissives -- if OK, close the valve.$N"
				    "#####  V4.00.02  2018-11-02:  Modified handling of simultaneous Commands.  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: XIC(Wrk_CloseCmdRcvd)[XIO(Wrk_OpenCmdRcvd) ,XIO(Cfg_FailOpen) ][[XIC(Inp_PermOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBPermOK) ,XIO(Cfg_FailOpen) ][XIC(Sts_Opened) ,XIC(Sts_Opening) [XIO(Cfg_FailOpen) ,XIC(Sts_Maint) ,XIC(Sts_TransitStall) ,XIC(Sts_FullStall) ] ]XIO(Sts_Closed)[OTU(Wrk_Open) ,XIC(Cfg_FailOpen) OTL(Wrk_StartHorn) ,XIO(Cfg_FailOpen) OTU(Wrk_StartHorn) ];
				RC: "If a Valve OPEN command is received and there$'s no CLOSE command (or opened is the fail state),$N"
				    "then check permissives -- if OK, open the valve.$N"
				    "#####  V4.00.02  2018-11-02:  Modified handling of simultaneous Commands.  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: XIC(Wrk_OpenCmdRcvd)[XIO(Wrk_CloseCmdRcvd) ,XIC(Cfg_FailOpen) ][[XIC(Inp_PermOK) ,XIC(Sts_BypActive) ] XIC(Inp_NBPermOK) ,XIC(Cfg_FailOpen) ][XIC(Sts_Closed) ,XIC(Sts_Closing) [XIC(Cfg_FailOpen) ,XIC(Sts_Maint) ,XIC(Sts_TransitStall) ,XIC(Sts_FullStall) ] ]XIO(Sts_Opened)[OTL(Wrk_Open) ,XIO(Cfg_FailOpen) OTL(Wrk_StartHorn) ,XIC(Cfg_FailOpen) OTU(Wrk_StartHorn) ];
				RC: "Higher Priority: HAND always wins over other sources:$N"
				    "If in Hand, have the Valve follow the position feedback.$N"
				    "If the valve is Fail Open, have it set to Open if NOT confirmed FULLY CLOSED.$N"
				    "If the valve is Fail Close, have it set to Close if NOT confirmed FULLY OPEN.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIC(Sts_Hand) ,XIO(Inp_Sim) ONS(Wrk_NoLongerSim) ,XIC(S:FS) ][[EQU(Val_Fdbk,2) ,NEQ(Val_Fdbk,1) XIC(Cfg_FailOpen) ] OTL(Wrk_Open) ,[EQU(Val_Fdbk,1) XIC(Wrk_ClosedFdbk) ,NEQ(Val_Fdbk,2) XIO(Cfg_FailOpen) ] OTU(Wrk_Open) ,[XIO(Cfg_UseOpenLS) XIO(Cfg_UseClosedLS) ,XIC(Sts_NotRdy) ] [XIC(Cfg_FailOpen) OTL(Wrk_Open) ,XIO(Cfg_FailOpen) OTU(Wrk_Open) ] ,OTU(Wrk_StartHorn) ];
				RC: "Sound the horn when energising$N"
				    "$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIC(Wrk_Open) XIO(Cfg_FailOpen) ,XIO(Wrk_Open) XIC(Cfg_FailOpen) ][XIC(Wrk_StartHorn) TON(Wrk_StartHornT,?,?) TON(Wrk_StartHornT,?,?) ,XIC(Wrk_StartHornT.DN) OTU(Wrk_StartHorn) ];
				RC: "If anything stops opening, also stop the pre-start audible.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIO(Wrk_Open) XIO(Cfg_FailOpen) ,XIC(Wrk_Open) XIC(Cfg_FailOpen) ]OTU(Wrk_StartHorn);
				RC: "If we are sounding the audible start alert (start command accepted) and we lose$N"
				    "the permissive before actually opening or closing the valve, cancel the command$N"
				    "$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: XIC(Wrk_StartHorn)[XIO(Inp_PermOK) XIO(Sts_BypActive) ,XIO(Inp_NBPermOK) ][XIC(Wrk_Open) XIO(Cfg_FailOpen) OTU(Wrk_Open) OTU(Wrk_StartHorn) ,XIO(Wrk_Open) XIC(Cfg_FailOpen) OTL(Wrk_Open) OTU(Wrk_StartHorn) ];
				RC: "Highest Priority:$N"
				    "If the Valve has a Shed Fault OR if the Valve is Disabled or$N"
				    "has a Configuration Error, set it to its FAIL STATE.";
				N: XIC(Sts_NotRdy)[XIC(Cfg_FailOpen) OTL(Wrk_Open) ,XIO(Cfg_FailOpen) OTU(Wrk_Open) ];
				RC: "============================================================$N"
				    "OUTPUT GENERATION$N"
				    "============================================================$N"
				    "If the Valve is NOT SIMULATED, generate the appropriate outputs for the Valve.$N"
				    "If the Valve is not faulted and not disabledm then:$N"
				    "if the valve energizes to open and should be open, or$N"
				    "if the valve energizes to close and should be closed,$N"
				    "then energize the Output (Out)$N"
				    "$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: XIO(Inp_Sim)[XIC(Wrk_Open) XIO(Cfg_FailOpen) ,XIO(Wrk_Open) XIC(Cfg_FailOpen) ][XIO(Wrk_StartHorn) OTE(Out) ,XIC(Wrk_StartHorn) OTE(Out_Horn) ];
				RC: "============================================================$N"
				    "DEVICE STATUS GENERATION$N"
				    "============================================================$N"
				    "Val_Cmd is the currently-executing command:$N"
				    "0 = None$N"
				    "1 = Close$N"
				    "2 = Open$N"
				    "$N"
				    "Val_Sts is the current device status, as determined by this AOI,$N"
				    "based on its knowledge of commands executed and feedback.$N"
				    "(This is the status that should be monitored by, for example, FT Historian.)$N"
				    "0 = Powerup / Unknown$N"
				    "1 = Closed$N"
				    "2 = Opened$N"
				    "5 = Closing$N"
				    "6 = Opening$N"
				    "10 = Horn$N"
				    "33 = Out of Service$N"
				    "$N"
				    "Val_Fault is the current device fault status, as determined by this AOI,$N"
				    "based on its knowledge of commands executed and feedback.$N"
				    "(This is the fault status that should be monitored by, for example, FT Historian.)$N"
				    "0 = None$N"
				    "16 = Full Stall$N"
				    "17 = Transit Stall$N"
				    "32 = I/O Fault (from Input)$N"
				    "34 = Configuration Error$N"
				    "$N"
				    "#####  V4.10.00  2019-03-25:  Added Horn Status.  #####";
				N: CLR(Wrk_Cmd)CLR(Wrk_Sts)CLR(Wrk_Fault);
				RC: "These rungs generate the Opening, Opened, Closeping and Closed Status bits.$N"
				    "$N"
				    "If the Valve is in HAND and HAS NO POSITION FEEDBACK, its state is meaningless;$N"
				    "turn off ALL the Sts_xxx states!!!!!$N"
				    "$N"
				    "If the Valve is commanded to Open and the feedback doesn$'t yet show it Opened,$N"
				    "the Valve is OpenING.$N"
				    "$N"
				    "If the Valve is commanded to Open and the feedback shows it Opened,$N"
				    "the Valve is Opened.$N"
				    "$N"
				    "If the Valve is commanded to Close and the feedback does not show Closed,$N"
				    "the Valve is CloseING.$N"
				    "$N"
				    "If the Valve is commanded to Close and the feedback shows it has Closed,$N"
				    "the Valve is Closed.$N"
				    "$N"
				    "If the audible alert is active, show the Status as HORN.$N"
				    "$N"
				    "#####  V4.10.00  2019-03-25:  Added Horn Status.  #####";
				N: [XIO(Sts_Hand) ,XIC(Cfg_UseOpenLS) ,XIC(Cfg_UseClosedLS) ][XIO(Wrk_StartHorn) XIC(Wrk_Open) [[XIO(Wrk_OpenFdbk) ,XIC(Wrk_ClosedFdbk) ] OTE(Sts_Opening) MOV(6,Wrk_Sts) ,XIC(Wrk_OpenFdbk) XIO(Wrk_ClosedFdbk) OTE(Sts_Opened) MOV(2,Wrk_Sts) ] ,XIO(Wrk_StartHorn) XIO(Wrk_Open) [[XIO(Wrk_ClosedFdbk) ,XIC(Wrk_OpenFdbk) ] OTE(Sts_Closing) MOV(5,Wrk_Sts) ,XIC(Wrk_ClosedFdbk) XIO(Wrk_OpenFdbk) OTE(Sts_Closed) MOV(1,Wrk_Sts) ] ,XIC(Wrk_StartHorn) OTE(Sts_Horn) MOV(10,Wrk_Sts) ];
				RC: "============================================================$N"
				    "OPERATOR COMMAND READIES$N"
				    "============================================================$N"
				    "Ready to Open if in Operator or Maintenance, valve is NOT $'not ready$' and valve is closed,$N"
				    "or valve is closing and energizes to close.$N"
				    "$N"
				    "Ready to Close if in Operator or Maintenance, valve is NOT $'not ready$' and valve is opened,$N"
				    "or valve is opening and energizes to open.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIC(Sts_Oper) ,XIC(Sts_Maint) ]XIO(Wrk_NotRdy)[XIO(Sts_NotRdy) ,XIC(Cfg_OCmdResets) ][[XIC(Sts_Closed) ,XIC(Sts_Closing) [XIC(Cfg_FailOpen) ,XIC(Sts_Maint) ,XIC(Sts_TransitStall) ,XIC(Sts_FullStall) ] ] XIO(Sts_Opened) XIO(Wrk_StartHorn) OTE(ORdy_Open) ,[XIC(Sts_Opened) ,XIC(Sts_Opening) [XIO(Cfg_FailOpen) ,XIC(Sts_Maint) ,XIC(Sts_TransitStall) ,XIC(Sts_FullStall) ] ] XIO(Sts_Closed) XIO(Wrk_StartHorn) OTE(ORdy_Close) ];
				RC: "============================================================$N"
				    "ALARM PROCESSING$N"
				    "============================================================$N"
				    "The various alarms are ALWAYS allowed to Exist (Cfg_HasXxxAlarm can be 1), EXCEPT:$N"
				    "$N"
				    "* If the valve DOES NOT HAVE ANY POSITION FEEDBACK, the Full Stall alarm$N"
				    "will never occur and should not exist.$N"
				    "* If the valve DOES NOT HAVE BOTH POSITION FEEDBACKs, the Transit Stall alarm$N"
				    "will never occur and should not exist.$N"
				    "(If feedback exists, the stall alarms must be allowed to exist.)$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [OTL(IntlkTrip.PCfg_AllowExist) OTL(IOFault.PCfg_AllowExist) ,[XIC(Cfg_HasClosedLS) ,XIC(Cfg_HasOpenLS) ] OTE(FullStall.PCfg_AllowExist) ,XIC(Cfg_HasClosedLS) XIC(Cfg_HasOpenLS) OTE(TransitStall.PCfg_AllowExist) ];
				RC: "Let the Alarm instance know if this object is taken Out of Service$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Now using P_CmdSrc, including Out of Service.  #####";
				N: XIC(CmdSrc.Sts_OoS)OTE(FullStall.Inp_OoS)OTE(TransitStall.Inp_OoS)OTE(IntlkTrip.Inp_OoS)OTE(IOFault.Inp_OoS);
				RC: "Handle Valve Full Stall (never moved) Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(FullStall);
				RC: "Handle Valve Transit Stall (moved but did not complete move)$N"
				    "Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(TransitStall);
				RC: "Handle Interlock Trip Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IntlkTrip);
				RC: "Handle I/O Fault Alarm Processing using the standard P_Alarm AOI.";
				N: P_Alarm(IOFault);
				RC: "If ANY alarm is Disabled, Inhibited or Suppressed, set the Alarm Inhibit$N"
				    "summary status bit (which puts the $QI$Q box on the graphic symbol).";
				N: [XIC(TransitStall.Sts_AlmInh) ,XIC(FullStall.Sts_AlmInh) ,XIC(IntlkTrip.Sts_AlmInh) ,XIC(IOFault.Sts_AlmInh) ]OTE(Sts_AlmInh);
				RC: "This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N"
				    "(in the Configuration handling section).";
				N: [XIC(Nrdy_CfgErr) ,[XIC(FullStall.Sts_Err) ,XIC(TransitStall.Sts_Err) ,XIC(IntlkTrip.Sts_Err) ,XIC(IOFault.Sts_Err) ] OTE(Err_Alarm) ]OTE(Sts_Err);
				RC: "This rung handles the remaining Val_Cmd, Val_Sts and Val_Fault enumerated values.$N"
				    "$N"
				    "#####  V4.00.00 2018-07-16:  Disable/Enable replaced by P_CmdSrc Out of Service (OoS).  #####";
				N: [XIO(Wrk_StartHorn) XIC(Sts_Closing) MOV(1,Wrk_Cmd) ,XIO(Wrk_StartHorn) XIC(Sts_Opening) MOV(2,Wrk_Cmd) ,XIC(Sts_TransitStall) MOV(16,Wrk_Fault) ,XIC(Sts_FullStall) MOV(17,Wrk_Fault) ,[XIC(Sts_IOFault) ,XIC(Nrdy_IOFault) ] MOV(32,Wrk_Fault) ,XIC(Sts_Err) MOV(34,Wrk_Fault) ,MOV(Wrk_Cmd,Val_Cmd) MOV(Wrk_Sts,Val_Sts) MOV(Wrk_Fault,Val_Fault) ];
				RC: "============================================================$N"
				    "ENUMERATED SOURCE / QUALITY VALUES$N"
				    "============================================================$N"
				    "Source and Quality for Input / Output values / status (SrcQ_IO)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [CLR(Wrk_SrcQ) ,[XIO(Cfg_HasOpenLS) ,XIO(Cfg_HasClosedLS) ] MOV(1,Wrk_SrcQ) ,XIO(Cfg_HasOpenLS) XIO(Cfg_HasClosedLS) MOV(2,Wrk_SrcQ) ,XIC(Inp_IOFault) MOV(34,Wrk_SrcQ) ,XIC(Inp_Sim) MOV(9,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ_IO) ];
				RC: "Source and Quality for primary values / status (SrcQ)$N"
				    "$N"
				    "0 = Good: live, confirmed good;   1 = Good: live, assumed good;$N"
				    "2 = Good: no feedback, assumed good;   8 = Test: Simulated;   9 = Test: Loopback;$N"
				    "10 = Test: Manually Entered;   16 = Uncertain: Live, off-spec;$N"
				    "17 = Uncertain, Substituted at Device / Bus;   18 = Uncertain, Substituted at AOI;$N"
				    "19 = Uncertain, using last known good;    20 = Uncertain, using replacement value;$N"
				    "32 = Bad, Signal Failure;   33 = Bad, Channel Fault;$N"
				    "34 = Bad, Module / Comms Fault;   35 = Bad, Invalid Configuration";
				N: [MOV(SrcQ_IO,Wrk_SrcQ) ,[XIC(Cfg_HasOpenLS) XIO(Cfg_UseOpenLS) ,XIC(Cfg_HasClosedLS) XIO(Cfg_UseClosedLS) ] MOV(18,Wrk_SrcQ) ,MOV(Wrk_SrcQ,SrcQ) ];
				RC: "============================================================$N"
				    "NOTIFICATION VALUE$N"
				    "============================================================$N"
				    "Indicate the current alarm notification level as the max of any of the alarms,$N"
				    "and set the low-order bit for reset or ack required:$N"
				    "0 = Not in alarm, acknowledged$N"
				    "1 = Not in alarm, unacknowledged or reset required$N"
				    "2 = Low severity alarm, acknowledged$N"
				    "3 = Low severity alarm, unacknowledged$N"
				    "4 = Medium severity alarm, acknowledged$N"
				    "5 = Medium severity alarm, unacknowledged$N"
				    "6 = High severity alarm, acknowledged$N"
				    "7 = High severity alarm, unacknowledged$N"
				    "8 = Urgent severity alarm, acknowledged$N"
				    "9 = Urgent severity alarm, unacknowledged$N"
				    "#####  V4.00.00  2018-07-16:  Added Val_NotifyAll and Val_UnackAlmC to roll up alarm  #####$N"
				    "#####  priority / ack status and unack. alarm count.  #####";
				N: [CLR(Wrk_Notify) CLR(Wrk_UnackAlmC) ,GRT(FullStall.Val_Notify,Wrk_Notify) MOV(FullStall.Val_Notify,Wrk_Notify) ,GRT(TransitStall.Val_Notify,Wrk_Notify) MOV(TransitStall.Val_Notify,Wrk_Notify) ,GRT(IntlkTrip.Val_Notify,Wrk_Notify) MOV(IntlkTrip.Val_Notify,Wrk_Notify) ,GRT(IOFault.Val_Notify,Wrk_Notify) MOV(IOFault.Val_Notify,Wrk_Notify) ,[XIC(FullStall.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(TransitStall.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IntlkTrip.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ,XIC(IOFault.Val_Notify.0) ADD(Wrk_UnackAlmC,1,Wrk_UnackAlmC) ] OTE(Wrk_Notify.0) ,MOV(Wrk_Notify,Val_Notify) MOV(Wrk_Notify,Val_NotifyAll) MOV(Wrk_UnackAlmC,Val_UnackAlmC) ];
				RC: "This rung identifies:$N"
				    "* if any alarm reset or other reset is required; and$N"
				    "* if any reset or acknowledge from the operator is required.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Aligned ready bit naming with command bit names.  #####$N"
				    "#####  All OCmds/MCmds and ORdys/MRdys are now Local Tags.  #####$N"
				    "#####  Added Sts_RdyAck and Sts_ResetReqd for use by external objects.  #####";
				N: [[XIC(FullStall.Sts_RdyAck) ,XIC(TransitStall.Sts_RdyAck) ,XIC(IntlkTrip.Sts_RdyAck) ,XIC(IOFault.Sts_RdyAck) ] OTE(Sts_RdyAck) ,[XIC(FullStall.Sts_RdyReset) ,XIC(TransitStall.Sts_RdyReset) ,XIC(IntlkTrip.Sts_RdyReset) ,XIC(IOFault.Sts_RdyReset) ,XIC(Nrdy_Fail) ,XIC(Nrdy_IOFault) XIO(Sts_IOFault) ] OTE(ORdy_Reset) ]OTE(ORdy_ResetAckAll);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear Ownership, set to De-Energized state, clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, set the Ownership to NO OWNER (0).";
				N: CLR(PSet_Owner)CLR(Val_Owner);
				RC: "$QLurking$Q Commands not handled elsewhere are cleared.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####$N"
				    "#####  Added External Command Source and Commands.  #####";
				N: [OTU(PCmd_Open) OTU(PCmd_Close) ,OTU(OCmd_Open) OTU(OCmd_Close) ,OTU(XCmd_Open) OTU(XCmd_Close) ,OTU(MCmd_Bypass) OTU(MCmd_Check) ,CLR(Inp_OvrdCmd) ,OTU(OCmd_Reset) OTU(OCmd_ResetAckAll) OTU(PCmd_Reset) OTU(XCmd_Reset) ];
				RC: "Since we$'re not processing Operator Commands or Settings, we$'re not READY for any of them either!$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Removed Disable, Enable; now handled by P_CmdSrc as OoS, IS.  #####";
				N: [OTU(ORdy_Open) OTU(ORdy_Close) OTU(ORdy_Reset) OTU(Sts_RdyAck) OTU(ORdy_ResetAckAll) ,OTU(MRdy_Bypass) OTU(MRdy_Check) ];
				RC: "On Prescan, set the valve to its DE-ENERGIZED STATE$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [XIO(Cfg_FailOpen) OTU(Wrk_Open) ,XIC(Cfg_FailOpen) OTL(Wrk_Open) ,OTU(Wrk_SimOpenLS) OTU(Wrk_SimClosedLS) ,OTU(Wrk_StartHorn) ];
				RC: "Clear the latched Run Command, latched Shed faults,$N"
				    "and reset the fault condition and command retrigger timers.";
				N: [OTU(Nrdy_Fail) OTU(Nrdy_IOFault) ,RES(Wrk_FullStallT) RES(Wrk_TransitStallT) RES(Wrk_SimOpenT) RES(Wrk_SimCloseT) ];
				RC: "All Outputs are de-energized on Prescan.$N"
				    "#####  V4.10.00  2019-03-25:  Added audible alert on commanded energize.  #####";
				N: [OTU(Out) ,OTU(Out_Horn) ];
				RC: "On Prescan, clear the following:$N"
				    "Val_Cmd (no command active)$N"
				    "Val_Fdbk (device position not determined)$N"
				    "Val_Sts (device status powerup / unknown)";
				N: CLR(Val_Cmd)CLR(Val_Fdbk)CLR(Val_Sts);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION P_Intlk (Description := "Interlocks",
	                                       Revision := "4.10",
	                                       RevisionExtension := ".01 Release",
	                                       RevisionNote := "See Instruction Help for a summary of changes, and see 4.10 Release Notes for details.",
	                                       Vendor := "Rockwell Automation",
	                                       ExecutePrescan := Yes,
	                                       ExecutePostscan := No,
	                                       ExecuteEnableInFalse := Yes,
	                                       CreatedDate := "2008-04-02T16:58:50.551Z",
	                                       CreatedBy := "Not Available",
	                                       EditedDate := "2019-10-16T20:50:58.588Z",
	                                       EditedBy := "PROCESS\Library",
	                                       SoftwareRevision := "v18.02",
	                                       AdditionalHelpText := "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N$NThis Instruction monitors up to 16 Interlock conditions.  It provides these features:$N$N*  The $QOK$Q state of each Interlock Input is configurable.  By default,$N    each Input is 1 to trip, 0 when OK to run.$N*  Interlocks may be configured as Latched.  Latched Interlocks$N    require a Reset Command to clear.  The latching function can be$N    inhibited via a Latch Defeat input, for example, to avoid latching$N    Interlocks for a stopped motor.$N*  Interlocks may be configured as Bypassable; Non-Bypassable$N    Interlocks are reported separately so the destination object can$N    decide whether to bypass (ignore) bypassable interlocks, such$N    as in Maintenance Mode.$N*  First-Out reporting indicates the first condition that caused the$N    running equipment to be tripped.$N*  For each Interlock condition, a Tag may be defined for navigation.$N    Clicking the Interlock description will call up the associated Tag$'s$N    Faceplate.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.10.00)$NSee 4.10 Release Notes for details.$N* Modified conditions for clearing first-out status and text.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (4.00.00)$NSee 4.10 Release Notes for details.$N* Changed type of Val_FirstOutTxt to STRING_Cond.$N* Corrected Scan Mode selection to execute Prescan logic.$N* Added Cfg_HasMoreObj.$N$NSUMMARY OF CHANGES FROM PREVIOUS VERSION (3.5-05)$NSee 4.00 Release Notes for details.$N* Changed Inf_ items to HMI_, and added Cfg_Area for security.$N* Added Val_FirstOutTxt string (Local, read-only) for use in$N   IntlkTrip alarm message  (ref: KnowledgeBase answer ID 672568).$N* Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N* All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N* Added Sts_RdyReset for use by external objects.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Inp_Intlk00 OF Wrk_Inp.0 (Description := "Interlock Cond. 00, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk01 OF Wrk_Inp.1 (Description := "Interlock Cond. 01, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk02 OF Wrk_Inp.2 (Description := "Interlock Cond. 02, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk03 OF Wrk_Inp.3 (Description := "Interlock Cond. 03, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk04 OF Wrk_Inp.4 (Description := "Interlock Cond. 04, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk05 OF Wrk_Inp.5 (Description := "Interlock Cond. 05, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk06 OF Wrk_Inp.6 (Description := "Interlock Cond. 06, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk07 OF Wrk_Inp.7 (Description := "Interlock Cond. 07, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes);
			Inp_Intlk08 OF Wrk_Inp.8 (Description := "Interlock Cond. 08, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk09 OF Wrk_Inp.9 (Description := "Interlock Cond. 09, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk10 OF Wrk_Inp.10 (Description := "Interlock Cond. 10, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk11 OF Wrk_Inp.11 (Description := "Interlock Cond. 11, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk12 OF Wrk_Inp.12 (Description := "Interlock Cond. 12, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk13 OF Wrk_Inp.13 (Description := "Interlock Cond. 13, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk14 OF Wrk_Inp.14 (Description := "Interlock Cond. 14, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_Intlk15 OF Wrk_Inp.15 (Description := "Interlock Cond. 15, Stop if not in configured OK state",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No);
			Inp_BypActive : BOOL (Description := "1=Interlock Bypassing is currently active",
			                         Usage := Input,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         DefaultData := 0);
			Inp_LatchDefeat : BOOL (Description := "Latch Defeat 1=Do$Nnot latch inputs even if configured for latching",
			                           Usage := Input,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           DefaultData := 0);
			Inp_Reset : BOOL (Description := "1=Reset Latched Interlocks and First-Out",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Cfg_OKState : INT (Description := "Bits indicate which state (0 or 1) of each input is OK to run",
			                       Usage := Input,
			                       RADIX := Binary,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Cfg_Latched : INT (Description := "Set bits indicate which conditions are latched (sealed in)",
			                       Usage := Input,
			                       RADIX := Binary,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Cfg_Bypassable : INT (Description := "Set bits indicate which conditions can be bypassed",
			                          Usage := Input,
			                          RADIX := Binary,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			Cfg_HasNav : INT (Description := "Set bits indicate which Navigation buttons are enabled",
			                      Usage := Input,
			                      RADIX := Binary,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Cfg_HasMoreObj : BOOL (Description := "1=Tells HMI an object with more info is available",
			                          Usage := Input,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          DefaultData := 0);
			PCmd_Reset : BOOL (Description := "Program Command to Reset Latched Interlocks",
			                      Usage := Input,
			                      RADIX := Decimal,
			                      Required := No,
			                      Visible := No,
			                      DefaultData := 0);
			Sts_IntlkOK : BOOL (Description := "Overall Interlock Status (1=OK to run, 0=Stop)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 1);
			Sts_NBIntlkOK : BOOL (Description := "Non-Bypassable Interlock Status (1=All NB Interlocks OK to run)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 1);
			Sts_BypActive : BOOL (Description := "1=Interlock Bypassing is Active (ignore bypassable interlocks)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_RdyReset OF ORdy_Reset (Description := "1=A latched interlock (returned to OK) is ready to be reset",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        ExternalAccess := Read Only);
			Sts_Intlk : INT (Description := "Individual Interlock Status (1=Stop, 0=OK)",
			                     Usage := Output,
			                     RADIX := Binary,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Sts_FirstOut : INT (Description := "Interlock First Out Status (bit 1 is First Not-OK condition)",
			                        Usage := Output,
			                        RADIX := Binary,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			P_Intlk : BOOL (Description := "Unique Parameter Name for auto - discovery",
			                   Usage := Output,
			                   RADIX := Decimal,
			                   Required := No,
			                   Visible := No,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Cfg_CondTxt : STRING_Cond[16] (Description := "Short HMI description of Interlock Conditions",
			                      ExternalAccess := Read/Write,
			                      DefaultData := "[[20,'Enter Description #0'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']]");
			Wrk_Inp : INT (Description := "Collection copy of Inp_IntlkXXs",
			                  RADIX := Binary,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_NB : INT (Description := "Working register for Non-Bypassable Interlock ogic",
			                 RADIX := Binary,
			                 ExternalAccess := None,
			                 DefaultData := 0);
			Wrk_Intlk : INT (Description := "Working register for Interlock logic",
			                    RADIX := Binary,
			                    ExternalAccess := None,
			                    DefaultData := 0);
			Wrk_FirstOut : INT (Description := "Working register for First Out logic",
			                       RADIX := Binary,
			                       ExternalAccess := None,
			                       DefaultData := 0);
			Wrk_Sts : INT (Description := "Working register for generating Interlock status",
			                  RADIX := Binary,
			                  ExternalAccess := None,
			                  DefaultData := 0);
			Wrk_PrevSts : INT (Description := "Interlock Status previous scan",
			                      RADIX := Binary,
			                      ExternalAccess := None,
			                      DefaultData := 0);
			Wrk_LatchEnable : BOOL (Description := "1=Latch interlock if configured to latch, 0=don$'t latch",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 1);
			HMI_Tab : SINT (Description := "Tab to display (FTView ME)",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_InpInv : INT (Description := "Input states after inversion based on Cfg_OKState",
			                     RADIX := Binary,
			                     ExternalAccess := None,
			                     DefaultData := 0);
			HMI_Type : STRING_16 (Description := "Type identifier for HMI navigation",
			                   ExternalAccess := Read Only,
			                   DefaultData := "[7,'P_Intlk$00$00$00$00$00$00$00$00$00']");
			Cfg_Label : STRING_20 (Description := "Label for graphic symbol displayed on HMI",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[10,'Interlocks$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Tag : STRING_20 (Description := "Tagname for display on HMI",
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Desc : STRING_40 (Description := "Description for display on HMI",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_NavTag : STRING_NavTag[16] (Description := "Tagnames for destinations of Navigation buttons",
			                     ExternalAccess := Read/Write,
			                     DefaultData := "[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']]");
			HMI_Lib : STRING_12 (Description := "Display Library for Faceplate call-up",
			                  ExternalAccess := Read Only,
			                  DefaultData := "[6,'RA-BAS$00$00$00$00$00$00']");
			MSet_Bypass : INT (Description := "Individual condition Maintenance Bypass toggles",
			                      RADIX := Binary,
			                      ExternalAccess := Read/Write,
			                      DefaultData := 0);
			Cfg_Area : STRING_Area (Description := "Process Area for security",
			                   ExternalAccess := Read/Write,
			                   DefaultData := "[6,'area01$00$00']");
			Val_FirstOutTxt : STRING_Cond (Description := "Text Description of First-Out Condition",
			                          ExternalAccess := Read Only,
			                          DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_NonIntlkStop : BOOL (Description := "One-Shot store: Stop OTHER than Interlock Stop occurred.",
			                           RADIX := Decimal,
			                           ExternalAccess := None,
			                           DefaultData := 0);
			Wrk_SetFirstOut : BOOL (Description := "One-Shot store: First Out update triggered",
			                          RADIX := Decimal,
			                          ExternalAccess := None,
			                          DefaultData := 0);
			ORdy_Reset : BOOL (Description := "1=Ready for OCmd_Reset (enables HMI button)",
			                     RADIX := Decimal,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			OCmd_Reset : BOOL (Description := "Operator Command to Reset Latched Interlocks",
			                     RADIX := Decimal,
			                     ExternalAccess := Read/Write,
			                     DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE EnableInFalse (Description := "Set summary $QOK$Q Status bits to FALSE (0)")
				RC: "============================================================$N"
				    "OFF-SCAN (EnableIn is False) STATUS$N"
				    "============================================================$N"
				    " Clear $QLurking$Q Commands (received while on false rung).$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: OTU(OCmd_Reset)OTU(PCmd_Reset);
				RC: " $N"
				    "Since we$'re not processing Operator Commands, we$'re not READY for them either!";
				N: OTU(ORdy_Reset);
				RC: "If this Interlocks instruction is OFF-SCAN (rung is false or EnableIn is false in FBD),$N"
				    "then set the summary Interlock OK Status bits to FALSE (0).";
				N: OTU(Sts_IntlkOK)OTU(Sts_NBIntlkOK);
				RC: "Individual Interlock Bypasses can only be set for conditions that are$N"
				    "configured as Bypassable.  This AND clears all the MSets for inputs$N"
				    "that are NOT Bypassable.";
				N: AND(MSet_Bypass,Cfg_Bypassable,MSet_Bypass);
		END_ROUTINE

		ROUTINE Logic (Description := "Check Interlock Conditions")
				RC: "Copyright © Rockwell Automation, Inc.  All Rights Reserved.$N"
				    "============================================================$N"
				    "P_Intlk:  PROCESS -- INTERLOCKS$N"
				    "============================================================$N"
				    "Revision 4.10.01 Release  2019-10-16:  See V4.10.xx Release Notes for details.$N"
				    "V1.x, V2.x, and V3.x Revision History archived.$N"
				    "V4.00.00  2018-07-16:  Changed Inf_ items to HMI_, and added Cfg_Area for security.$N"
				    "Added Val_FirstOutTxt string (Local, read-only) for use in$N"
				    "IntlkTrip alarm message  (ref: KnowledgeBase answer ID 672568).$N"
				    "Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.$N"
				    "All OCmds/MCmds and ORdys/MRdys are now Local Tags.$N"
				    "Added Sts_RdyReset for use by external objects.$N"
				    "V4.10.00  2019-03-08:  Changed type of Val_FirstOutTxt to STRING_Cond.$N"
				    "Corrected Scan Mode selection to execute Prescan logic. Added Cfg_HasMoreObj.\$N"
				    "V4.10.01  2019-10-16:  Modified conditions for clearing first-out status and text.$N"
				    "============================================================$N"
				    "This Instruction monitors up to 16 Interlock conditions.  It provides these features:$N"
				    "$N"
				    "*  The $QOK$Q state of each Interlock Input is configurable.$N"
				    "By default, each Input is 1 to trip, 0 when OK to run.$N"
				    "*  Interlocks may be configured as Latched.  Latched Interlocks$N"
				    "require a Reset Command to clear.  The latching function can be inhibited$N"
				    "via a Latch Defeat input, for example, to avoid latching Interlocks for a stopped motor.$N"
				    "*  Interlocks may be configured as Bypassable.  Bypassable Interlocks are reported$N"
				    "separately; the destination object can use this information to bypass these$N"
				    "Interlocks in Maintenance Mode or upon command.$N"
				    "*  First-Out reporting indicates the first condition that$N"
				    "caused the running equipment to be tripped.$N"
				    "* For each Interlock condition, a Tag may be defined for navigation. Clicking$N"
				    "the Interlock description will call up the associated Tag$'s Faceplate.$N"
				    "============================================================$N"
				    "SHOW LOCAL STRINGS$N"
				    "============================================================$N"
				    "The STRINGs containing the text associated with each instance of this$N"
				    "instruction cannot be Input or Output Parameters, because STRINGs are not$N"
				    " $'atomic$' types. (Inputs and Outputs must be SINT, INT, DINT, REAL, or BOOL.)$N"
				    "$N"
				    "In order to make it easier to find and configure these STRINGs, this rung$N"
				    "was added.  THE JMP (and the LBL on the following rung)$N"
				    "MUST NOT BE REMOVED!!!$N"
				    "$N"
				    "To view the STRINGs, go to the instruction instance (in LD or FBD), RIGHT-click$N"
				    "to bring up the context menu and select $QOpen Instruction Logic$Q.$N"
				    "This rung will appear with the STRING values for the selected instance.$N"
				    "You may double-click the STRING values here to modify them as well.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added string for Cfg_Area, Val_FirstOutTxt; renamed Inf_* to HMI_*.  #####";
				N: JMP(SkipText)[LOWER(Cfg_Desc,Cfg_Label) LOWER(Cfg_Tag,Cfg_Area) CONCAT(HMI_Lib,HMI_Type,Val_FirstOutTxt) ,LOWER(Cfg_CondTxt[0],Cfg_CondTxt[1]) LOWER(Cfg_CondTxt[2],Cfg_CondTxt[3]) LOWER(Cfg_CondTxt[4],Cfg_CondTxt[5]) LOWER(Cfg_CondTxt[6],Cfg_CondTxt[7]) ,LOWER(Cfg_CondTxt[8],Cfg_CondTxt[9]) LOWER(Cfg_CondTxt[10],Cfg_CondTxt[11]) LOWER(Cfg_CondTxt[12],Cfg_CondTxt[13]) LOWER(Cfg_CondTxt[14],Cfg_CondTxt[15]) ,LOWER(Cfg_NavTag[0],Cfg_NavTag[1]) LOWER(Cfg_NavTag[2],Cfg_NavTag[3]) LOWER(Cfg_NavTag[4],Cfg_NavTag[5]) LOWER(Cfg_NavTag[6],Cfg_NavTag[7]) ,LOWER(Cfg_NavTag[8],Cfg_NavTag[9]) LOWER(Cfg_NavTag[10],Cfg_NavTag[11]) LOWER(Cfg_NavTag[12],Cfg_NavTag[13]) LOWER(Cfg_NavTag[14],Cfg_NavTag[15]) ];
				RC: "============================================================$N"
				    "INPUT GATHERING$N"
				    "============================================================$N"
				    "This object uses word-wise logic.  The 16 interlock inputs are aliased$N"
				    "to the Wrk_Inp word, so no logic is needed to collect the individual$N"
				    "conditions.  We can immediately start processing the interlock logic.$N"
				    "============================================================$N"
				    "HANDLE $QOK STATE$Q INVERSIONS$N"
				    "============================================================$N"
				    "This rung inverts the Input bits whose $QOK State$Q is 1 (0 to Stop).$N"
				    "The resulting Wrk_Inp word is ZERO if all interlock inputs are $QOK$Q.";
				N: LBL(SkipText)XOR(Wrk_Inp,Cfg_OKState,Wrk_InpInv);
				RC: "============================================================$N"
				    "COMMAND PROCESSING$N"
				    "============================================================$N"
				    "On receipt of a Reset Command, the output$N"
				    "Interlock Status (internal copy, actually) is cleared.$N"
				    "(Later logic may fill this in again if some Interlock conditions are true...)$N"
				    "$N"
				    "NOTE:  This object is $QModeless$Q -- Operator and Program Commands$N"
				    "are accepted at any time.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Deleted Cfg_PCmdClear; all Program Commands are now self-clearing.  #####";
				N: [XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(Inp_Reset) ]CLR(Wrk_Sts);
				RC: "If the Latch Defeat Input is ON (say, motor not running) and the stored interlock$N"
				    "status is clear (typically, after we get a reset in the rung above),$N"
				    "switch to $Qnot latching$Q for all interlock inputs (regardless of Cfg_Latched).$N"
				    "$N"
				    "This has the effect of keeping the Latch Enable work bit ON until a Reset is received.$N"
				    "Hence this is part of the $Qreset command processing$Q logic....";
				N: EQU(Wrk_Sts,0)XIC(Inp_LatchDefeat)OTU(Wrk_LatchEnable);
				RC: "============================================================$N"
				    "INTERLOCK PROCESSING$N"
				    "============================================================$N"
				    "This rung clears any bits in the stored Interlock status for which the$N"
				    "Input bit is OFF and the bit is NOT configured as Latched.$N"
				    "$N"
				    "If the LatchDefeat input in OFF, set the internal Latch Enable work bit.$N"
				    "If this bit is ON, don$'t clear any latched bits with this rung (keep them latched).$N"
				    "If this bit is OFF, clear any bits that are NOT on in the input, whether$N"
				    "configured for latching or not!";
				N: [XIO(Inp_LatchDefeat) OTL(Wrk_LatchEnable) ,XIC(Wrk_LatchEnable) OR(Cfg_Latched,Wrk_InpInv,Wrk_Intlk) ,XIO(Wrk_LatchEnable) MOV(Wrk_InpInv,Wrk_Intlk) ]AND(Wrk_Sts,Wrk_Intlk,Wrk_Sts);
				RC: "This rung SETS Interlock status bits for any Interlock condition Input that is true.";
				N: OR(Wrk_Sts,Wrk_InpInv,Wrk_Sts);
				RC: "Individual Interlock Bypasses can only be set for conditions that are$N"
				    "configured as Bypassable.  This AND clears all the MSets for inputs$N"
				    "that are NOT Bypassable.$N"
				    "$N"
				    "The internal Non-Bypassable Interlocks word has bits set only if the Input is TRUE$N"
				    "AND the bit is configured as a NON-bypassable Interlock OR NOT bypassed..";
				N: AND(MSet_Bypass,Cfg_Bypassable,MSet_Bypass)NOT(MSet_Bypass,Wrk_NB)AND(Wrk_Sts,Wrk_NB,Wrk_NB);
				RC: "Clear the First Out status and text when the Latch Defeat input turns off (One-Shot).$N"
				    "This generally occurs when the downstream device STARTS.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added Val_FirstOutTxt string (Local, read-only) for use in IntlkTrip alarm message.  #####$N"
				    "#####  V4.10.01  2019-10-16:  Modified conditions for clearing first-out status and text.  #####";
				N: XIO(Inp_LatchDefeat)ONS(Wrk_NonIntlkStop)CLR(Wrk_FirstOut)FLL(0,Val_FirstOutTxt,1);
				RC: "If an interlock condition occurs (which interlocks depends on the$N"
				    "bypass status!) and the Latch Defeat input is NOT set,$N"
				    "the equipment is running and will be shut down.$N"
				    "If this happens, record the First Out status.$N"
				    "$N"
				    "#####  V4.00.00  2018-07-16:  Added Val_FirstOutTxt string (Local, read-only) for use in IntlkTrip alarm message.  #####$N"
				    "#####  V4.10.00  2019-03-08:  Changed type of Val_FirstOutTxt to STRING_Cond.  #####";
				N: [XIO(Inp_BypActive) NEQ(Wrk_Sts,0) ,XIC(Inp_BypActive) NEQ(Wrk_NB,0) ]XIO(Inp_LatchDefeat)ONS(Wrk_SetFirstOut)[XIO(Inp_BypActive) CPT(Wrk_FirstOut,(Wrk_Sts)AND(NOT(Wrk_PrevSts))) ,XIC(Inp_BypActive) CPT(Wrk_FirstOut,(Wrk_NB)AND(NOT(Wrk_PrevSts))) ,NEQ(Wrk_FirstOut,0) [XIC(Wrk_FirstOut.15) COP(Cfg_CondTxt[15],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.14) COP(Cfg_CondTxt[14],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.13) COP(Cfg_CondTxt[13],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.12) COP(Cfg_CondTxt[12],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.11) COP(Cfg_CondTxt[11],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.10) COP(Cfg_CondTxt[10],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.9) COP(Cfg_CondTxt[9],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.8) COP(Cfg_CondTxt[8],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.7) COP(Cfg_CondTxt[7],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.6) COP(Cfg_CondTxt[6],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.5) COP(Cfg_CondTxt[5],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.4) COP(Cfg_CondTxt[4],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.3) COP(Cfg_CondTxt[3],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.2) COP(Cfg_CondTxt[2],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.1) COP(Cfg_CondTxt[1],Val_FirstOutTxt,1) ,XIC(Wrk_FirstOut.0) COP(Cfg_CondTxt[0],Val_FirstOutTxt,1) ] ];
				RC: "The value used for $QFirst Out$Q generation this scan is stored$N"
				    "as the $Qprevious$Q value for use in the above logic next scan.";
				N: [XIO(Inp_BypActive) MOV(Wrk_Sts,Wrk_PrevSts) ,XIC(Inp_BypActive) MOV(Wrk_NB,Wrk_PrevSts) ];
				RC: "============================================================$N"
				    "STATUS GENERATION$N"
				    "============================================================$N"
				    "This rung generates the public Status for this object.$N"
				    "If all the Interlock Status bits are zero, there is no condition to$N"
				    "shut down the affected equipment.  In that case, show the Interlock Status as $QOK$Q$N"
				    "$N"
				    "Similar logic applies for the Non-Bypassable Interlocks OK Status.$N"
				    "$N"
				    "Also show the individual Interlock Status bits and the First Out Status bits.$N"
				    "$N"
				    "NOTE:  Working registers are used to prevent outside writes to the Sts_xxx$N"
				    "parameters from affecting the state of this object!";
				N: [[EQU(Wrk_Sts,0) OTE(Sts_IntlkOK) ,EQU(Wrk_NB,0) OTE(Sts_NBIntlkOK) ] ,XIC(Inp_BypActive) OTE(Sts_BypActive) ,MOV(Wrk_Sts,Sts_Intlk) ,MOV(Wrk_FirstOut,Sts_FirstOut) ];
				RC: "============================================================$N"
				    "COMMAND READIES$N"
				    "============================================================$N"
				    "This Interlock ojbect is ready for (needs) a RESET Command$N"
				    "if any Latched Interlocks are SET.";
				N: CMP((NOT(Wrk_InpInv))AND(Wrk_Sts)AND(Cfg_Latched))OTE(ORdy_Reset);
		END_ROUTINE

		ROUTINE Prescan (Description := "Clear $Qlurking$Q Commands")
				RC: "============================================================$N"
				    "PRESCAN (POWERUP) HANDLING$N"
				    "============================================================$N"
				    "On Prescan, clear any $Qlurking$Q Commands.";
				N: OTU(OCmd_Reset)OTU(PCmd_Reset);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION T_Valid (Description := "Is DateTime Valid?",
	                                       Revision := "1.0",
	                                       RevisionExtension := "00 Release",
	                                       RevisionNote := "Initial formal release",
	                                       Vendor := "Rockwell Automation",
	                                       ExecutePrescan := No,
	                                       ExecutePostscan := No,
	                                       ExecuteEnableInFalse := No,
	                                       CreatedDate := "2007-09-07T20:09:49.027Z",
	                                       CreatedBy := "Not Available",
	                                       EditedDate := "2021-01-23T04:38:12.493Z",
	                                       EditedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                       SoftwareRevision := "v32.03",
	                                       AdditionalHelpText := "This instruction tests the given DateTime variable and verifies that it is a valid calendar date and clock time, as follows:$N$N  *  0 <= Microseconds < 1,000,000$N  *  0 <= Seconds < 60    (NOTE: this instruction cannot check leap seconds;  sorry!$N  *  0 <= Minutes < 60$N  *  0 <= Hours < 24$N  *  1 <= Day <= 31 AND Day is Valid for Gregorian Date (28, 29, 30 or 31 days in month, see below)$N  *  1 <= Month <= 12$N  *  Year is within the range of dates that this instruction can calculate a Gregorian day number (about +/- 5.8 million years)$N$N  NOTE:  This instruction does NOT switch to Julian dates for dates before 1582 (or 1753 or whenever your place of interest switched to the Gregorian Calendar (see Wikipedia on Gregorian Calendar for details)!  This instruction assumes the Gregorian Calendar extends $Qindefinitely$Q (at least 5.8 million years) either side of $Qzero$Q!  It DOES handle the Gregorian 4 / 100 / 400 year rules, so Feb. 29, 2000 is a valid date, but Feb. 29, 2100 is not.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Ref_DT : DateTime (Description := "Date and Time to check for validity",
			                  Usage := InOut,
			                  Required := Yes,
			                  Visible := Yes);
			Out : BOOL (Description := "1 = Date/Time is valid (exists)",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0);
			Sts_YrInvalid : BOOL (Description := "1 = Date is invalid because year is out of the range this instruction can check",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_MoInvalid : BOOL (Description := "1 = Month is Invalid (1 to 12)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_DaInvalid : BOOL (Description := "1 = Day is Invalid (not within days for that month/year)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_HrInvalid : BOOL (Description := "1 = Hour is Invalid (0 to 23)",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := No,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Sts_MinInvalid : BOOL (Description := "1 = Minute is invalid (0 to 59)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_SecInvalid : BOOL (Description := "1 = Second is invalid (0 to 59)",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := No,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Sts_uSecInvalid : BOOL (Description := "1 = Microsecond is Invalid (0 to 999,999)",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := No,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_F : DINT (Description := "Used in calculating Gregorian Day Number (function of month)",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Wrk_G : DINT (Description := "Used in calculating Gregorian Day Number (function of Year and F)",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Wrk_GD : DINT (Description := "Gregorian Day Number (calculated for given Y/M/D)",
			                 RADIX := Decimal,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
			Wrk_yyy : DINT (Description := "Intermediate for year calculation",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_ddd : DINT (Description := "Intermediate for day calculation",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_mmm : DINT (Description := "Intermediate for month calculation",
			                  RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := 0);
			Wrk_y : DINT (Description := "Calculated YEAR from Gregorian Day Number",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Wrk_m : DINT (Description := "Calculated MONTH from Gregorian Day Number",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Wrk_d : DINT (Description := "Calculated DAY from Gregorian Day Number",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
		END_LOCAL_TAGS

		ST_ROUTINE Logic (Description := "Checks whether given DateTime is valid (exists on common calendar/clock)")
			'// T_Valid : TIME -- CHECK FOR VALID DATE / TIME
			'// 
			'// This instruction tests the given DateTime variable and verifies that it is a valid calendar date and clock time, as follows:
			'//
			'//  *  0 <= Microseconds < 1,000,000
			'//  *  0 <= Seconds < 60    (NOTE: this instruction cannot check leap seconds;  sorry!
			'//  *  0 <= Minutes < 60
			'//  *  0 <= Hours < 24
			'//  *  1 <= Day <= 31 AND Day is Valid for Gregorian Date (28, 29, 30 or 31 days in month, see below)
			'//  *  1 <= Month <= 12
			'//  *  Year is within the range of dates that this instruction can calculate a Gregorian day number (about +/- 5.8 million years)
			'//
			'//  NOTE:  This instruction does NOT switch to Julian dates for dates before 1582 (or 1753 or whenever your place of interest
			'//  switched to the Gregorian Calendar (see Wikipedia on Gregorian Calendar for details)!  This instruction assumes the Gregorian
			'//  Calendar extends "indefinitely" (at least 5.8 million years) either side of "zero"!  It DOES handle the Gregorian 4 / 100 /
			'//  400 year rules, so Feb. 29, 2000 is a valid date, but Feb. 29, 2100 is not.
			'//
			'//  NOTE:  For algorithms, see http://alcor.concordia.ca/~gpkatch/gdate-algorithm.html
			'//
			'//  Version 1.0-00 Release
			'//	Initial Formal Release
			'//
			'
			'// Check Microseconds
			'IF ((Ref_DT.uSec < 0) OR (Ref_DT.uSec > 999999)) THEN
			'	Sts_uSecInvalid := 1;
			'ELSE
			'	Sts_uSecInvalid := 0;
			'END_IF;
			'
			'// Check Seconds
			'IF ((Ref_DT.Sec < 0) OR (Ref_DT.Sec > 59)) THEN
			'	Sts_SecInvalid := 1;
			'ELSE
			'	Sts_SecInvalid := 0;
			'END_IF;
			'
			'// Check Minutes
			'IF ((Ref_DT.Min < 0) OR (Ref_DT.Min > 59)) THEN
			'	Sts_MinInvalid := 1;
			'ELSE
			'	Sts_MinInvalid := 0;
			'END_IF;
			'
			'// Check Hour
			'IF ((Ref_DT.Hr < 0) OR (Ref_DT.Hr > 23)) THEN
			'	Sts_HrInvalid := 1;
			'ELSE
			'	Sts_HrInvalid := 0;
			'END_IF;
			'
			'// Check Day (basic check, see below for more!)
			'IF ((Ref_DT.Da < 1) OR (Ref_DT.Da > 31)) THEN
			'	Sts_DaInvalid := 1;
			'ELSE
			'	Sts_DaInvalid := 0;
			'END_IF;
			'
			'// Check Month
			'IF ((Ref_DT.Mo < 1) OR (Ref_DT.Mo > 12)) THEN
			'	Sts_MoInvalid := 1;
			'ELSE
			'	Sts_MoInvalid := 0;
			'END_IF;
			'
			'// Check Year is in the range we can test
			'IF ((Ref_DT.Yr < -5879600) OR (Ref_DT.Yr > 5879600)) THEN
			'	Sts_YrInvalid := 1;
			'ELSE
			'	Sts_YrInvalid := 0;
			'END_IF;
			'
			'// If the Year, Month and Day are all valid in the base checks above, check that the Date is a valid Gregorian Date
			'IF (NOT(Sts_DaInvalid) AND NOT(Sts_MoInvalid) AND NOT(Sts_YrInvalid)) THEN
			'//  First, Calculate a "Gregorian Day Number" for the input Yr/Mo/Da:
			'	Wrk_F := (Ref_DT.Mo+9) MOD 12;
			'	Wrk_G := Ref_DT.Yr - Wrk_F/10;
			'	Wrk_GD := 365*Wrk_G+Wrk_G/4-Wrk_G/100+Wrk_G/400+(Wrk_F*306+5)/10+Ref_DT.Da-1;
			'
			'//  Now, given the Gregorian Day Number, calculate the calendar date
			'
			'	Wrk_yyy := TRUNC (Wrk_GD +1.5)/365.2425;
			'	Wrk_ddd := Wrk_GD - (365*Wrk_yyy+Wrk_yyy/4-Wrk_yyy/100+Wrk_yyy/400);
			'	IF (Wrk_ddd < 0) THEN
			'		Wrk_yyy := Wrk_yyy - 1;
			'		Wrk_ddd := Wrk_GD - (365*Wrk_yyy+Wrk_yyy/4-Wrk_yyy/100+Wrk_yyy/400);
			'		IF (Wrk_ddd < 0) THEN
			'			Wrk_yyy := Wrk_yyy - 1;
			'			Wrk_ddd := Wrk_GD - (365*Wrk_yyy+Wrk_yyy/4-Wrk_yyy/100+Wrk_yyy/400);
			'		END_IF;
			'	END_IF;
			'	Wrk_mmm := (100*Wrk_ddd + 52)/3060;
			'	Wrk_y := Wrk_yyy + (Wrk_mmm + 2)/12;
			'	Wrk_m := ((Wrk_mmm + 2) MOD 12) + 1; 
			'	Wrk_d := Wrk_ddd - ((Wrk_mmm * 306) + 5)/10 + 1;
			'
			'//  If the Input Year/Month/Day match the calculated Year/Month/Day, the date (day number) is valid.
			'
			'	IF ((Wrk_m <> Ref_DT.Mo) OR (Wrk_y <> Ref_DT.Yr) OR (Wrk_d <> Ref_DT.Da)) THEN
			'		Sts_DaInvalid := 1;
			'	END_IF;
			'	
			'END_IF;
			'
			'//  If nothing is invalid, set Out to indicate a valid date/time; otherwise, clear Out
			'
			'IF ((NOT(Sts_uSecInvalid)) AND (NOT(Sts_SecInvalid)) AND (NOT(Sts_MinInvalid)) AND (NOT(Sts_HrInvalid)) AND (NOT(Sts_DaInvalid)) AND (NOT(Sts_MoInvalid)) AND (NOT(Sts_YrInvalid))) THEN
			'	Out := 1;
			'ELSE
			'	Out := 0;
			'END_IF;
			'
		END_ST_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION T_DoW (Description := "Day of the Week",
	                                     Revision := "1.0",
	                                     RevisionExtension := "00 Release",
	                                     RevisionNote := "Initial formal release",
	                                     Vendor := "Rockwell Automation",
	                                     ExecutePrescan := No,
	                                     ExecutePostscan := No,
	                                     ExecuteEnableInFalse := No,
	                                     CreatedDate := "2008-04-09T17:38:34.917Z",
	                                     CreatedBy := "Not Available",
	                                     EditedDate := "2021-01-23T04:38:11.581Z",
	                                     EditedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                     SoftwareRevision := "v32.03",
	                                     AdditionalHelpText := "T_DoW : Day of the Week$N$NThis instruction takes a given Date/Time, and, for the Date part, returns the Day of the Week$N  (0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat)$N$NIf the given Date is INVALID, a flag is set (but the calculated Day of the Week is returned anyway...)$N$NNOTE:  The Time part of Input Parameter DT (hours, minutes, seconds, microseconds) is ignored.$N$NNOTE:  This instruction does NOT switch to Julian dates for dates before 1582 (or 1753 or whenever your place of interest switched to the Gregorian Calendar (see Wikipedia on Gregorian Calendar for details)!  This instruction assumes the Gregorian Calendar extends $Qindefinitely$Q (at least 5.8 million years) either side of $Qzero$Q!  It DOES handle the Gregorian 4 / 100 / 400 year rules, so Feb. 29, 2000 is a valid date, but Feb. 29, 2100 is not.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Ref_DT : DateTime (Description := "Date/Time input",
			                  Usage := InOut,
			                  Required := Yes,
			                  Visible := Yes);
			Out : DINT (Description := "Returned Day of the Week (0=Sun, 1=Mon,... 6=Sat)",
			               Usage := Output,
			               RADIX := Decimal,
			               Required := No,
			               Visible := Yes,
			               ExternalAccess := Read Only,
			               DefaultData := 0);
			Sts_InvDate : BOOL (Description := "Cannot compute Day of Week because Date is INVALID",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Wrk_G : DINT (Description := "Intermediate variable, function of Month, Year",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Wrk_F : DINT (Description := "Intermediate variable, function of Month",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
			Wrk_TValid : T_Valid (Description := "AOI Backing Tag for valid Date check",
			                     ExternalAccess := Read/Write,
			                     DefaultData := "[1,0,0,0,0,0,0,0,0,0]");
			Wrk_D : DINT (Description := "Work register for computed day number",
			                RADIX := Decimal,
			                ExternalAccess := Read/Write,
			                DefaultData := 0);
		END_LOCAL_TAGS

		ST_ROUTINE Logic (Description := "Determine Day of the Week for the given Date")
			'// T_DoW : TIME -- DAY OF THE WEEK
			'// 
			'//  This instruction takes a given Date/Time, and, for the Date part, returns the Day of the Week
			'//    (0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat)
			'// 
			'//  If the given Date is INVALID, a flag is set (but the calculated Day of the Week is returned anyway...)
			'//
			'//  NOTE:  The Time parts of Input Parameter DT (hours, minutes, seconds, microseconds) are ignored.
			'//
			'//  NOTE:  This instruction does NOT switch to Julian dates for dates before 1582 (or 1753 or whenever your place of interest
			'//  switched to the Gregorian Calendar (see Wikipedia on Gregorian Calendar for details)!  This instruction assumes the Gregorian
			'//  Calendar extends "indefinitely" (at least 5.8 million years) either side of "zero"!  It DOES handle the Gregorian 4 / 100 /
			'//  400 year rules, so Feb. 29, 2000 is a valid date, but Feb. 29, 2100 is not.
			'//
			'//  NOTE:  For algorithms, see http://alcor.concordia.ca/~gpkatch/gdate-algorithm.html
			'//
			'//  Version 1.0-00 Release
			'//	Initial Formal Release
			'//
			'
			'//  First, check the received date to see if it is valid
			'
			'T_Valid (Wrk_TValid, Ref_DT);
			'
			'//  If the Year, Month or Day is not valid, set the Sts_DateInvalid flag; if all OK, clear the flag
			'
			'IF (Wrk_TValid.Sts_YrInvalid OR Wrk_TValid.Sts_MoInvalid OR Wrk_TValid.Sts_DaInvalid) THEN
			'	Sts_InvDate := 1;
			'ELSE
			'	Sts_InvDate := 0;
			'END_IF;
			'
			'//  We've handled the validity check, now compute a "Day Number" whose remainder after division by 7 gives the day of the week.
			'
			'Wrk_F := (Ref_DT.Mo + 9) MOD 12;
			'Wrk_G := Ref_DT.Yr - Wrk_F/10;
			'
			'Wrk_D := 365*Wrk_G+Wrk_G/4-Wrk_G/100+Wrk_G/400+(Wrk_F*306+5)/10+Ref_DT.Da+2;
			'
			'//  If the day number is negative, the MOD won't work; add the biggest integer divisible by 7 to ensure it's positive!
			'
			'IF (Wrk_D < 0) THEN
			'	Wrk_D := Wrk_D + 2147483646;
			'END_IF;
			'
			'//  Finally, do the Modulo math to get the day of the week (0=Sun, 1=Mon, ..., 6=Sat)
			'
			'Out := Wrk_D MOD 7;
		END_ST_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION T_TtoS (Description := "Date/Time to String",
	                                      Revision := "1.0",
	                                      RevisionExtension := "00 Release",
	                                      RevisionNote := "Initial formal release",
	                                      Vendor := "Rockwell Automation",
	                                      ExecutePrescan := No,
	                                      ExecutePostscan := No,
	                                      ExecuteEnableInFalse := No,
	                                      CreatedDate := "2008-04-30T19:38:42.235Z",
	                                      CreatedBy := "Not Available",
	                                      EditedDate := "2021-01-23T04:38:12.186Z",
	                                      EditedBy := "WIN-2669UBAKA7O\AESRockwell",
	                                      SoftwareRevision := "v32.03",
	                                      AdditionalHelpText := "This instruction takes the given date and formats it as a human-readable STRING.$N$NFor example, for the Date/Time:$N   2008  12  31  23  59  59  999999$Nthe return STRING will be (based on configuration):$N   Wednesady, December 31, 2008  11:59:59.999999 p.m.$N$NOptions are provided for:$N   * 24- or 12-hour time format (with a.m. or p.m. indicator on the 12-hour format)$N   * displaying or not displaying microseconds$N   * displaying or not displaying seconds$N   * displaying or not displaying the Day of the Week$N   * displaying day first (31 July) or month first (July 31)$N   * displaying date in an ISO-format (YYYY-MM-DD)$N$NThis instruction checks for a valid (Gregorian) Date and Time and returns $QInvalid Date$Q and/or $QInvalid Time$Q as appropriate in the output STRING.  Valid dates/times are:$N  *  0 <= Microseconds < 1,000,000$N  *  0 <= Seconds < 60$N  *  0 <= Minutes < 60$N  *  0 <= Hours < 24$N  *  0 <= Days <= 31 and a valid Gregorian Date (Feb = 28 or 29 days, etc.)$N  *  1 <= Month <= 12$N  *  year in the range +/- 5879600$N$NThe names of the days of the week and the months of the year, and the AM and PM indicator text can be changed by using the Local Tags Monitor for the instance.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			Ref_DT : DateTime (Description := "Date/Time as DINTs to convert to STRING",
			                  Usage := InOut,
			                  Required := Yes,
			                  Visible := Yes);
			Ref_Out : STRING (Description := "Date/Time as STRING for display",
			                   Usage := InOut,
			                   Required := Yes,
			                   Visible := Yes);
			Cfg_ISODate : BOOL (Description := "1=use ISO date format YYYY-MM-DD; 0=use pretty date",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 0);
			Cfg_DayFirst : BOOL (Description := "1=use $Q1 January$Q; 0=use $QJanuary 1$Q",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := No,
			                        DefaultData := 0);
			Cfg_InclDoW : BOOL (Description := "Include name of the Day of the Week",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1);
			Cfg_12Hr : BOOL (Description := "1=12-hour with am/pm, 0=24-hour with leading zero",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    DefaultData := 0);
			Cfg_InclSec : BOOL (Description := "1=include seconds in output string",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       DefaultData := 1);
			Cfg_InclMicrosec : BOOL (Description := "1=include microseconds in output string",
			                            Usage := Input,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := No,
			                            DefaultData := 0);
			Sts_InvDate : BOOL (Description := "0=OK, 1=Date supplied is not a valid Date",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Sts_InvTime : BOOL (Description := "0=OK, 1=Time supplied is not a valid Time",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := No,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			Cfg_MonthNames : STRING_20[12] (Description := "Names of the Months of the Year",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[[3,'JAN$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'FEB$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'MAR$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'APR$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'MAY$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'JUN$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'JUL$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'AUG$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'SEP$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'OCT$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'NOV$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'DEC$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']]");
			Cfg_DayNames : STRING_20[7] (Description := "Names of the Days of the Week",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[[6,'Sunday$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'Monday$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[7,'Tuesday$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'Wednesday$00$00$00$00$00$00$00$00$00$00$00'],[8,'Thursday$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'Friday$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[8,'Saturday$00$00$00$00$00$00$00$00$00$00$00$00']]");
			DoW : T_DoW (Description := "AOI to get Day of the Week for given Date",
			              ExternalAccess := Read/Write,
			              DefaultData := "[1,0,0,0,[1,0,0,0,0,0,0,0,0,0],0]");
			Cfg_AMString : STRING_8 (Description := "Morning time string",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[2,'AM$00$00$00$00$00$00']");
			Cfg_PMString : STRING_8 (Description := "Afternoon time string",
			                       ExternalAccess := Read/Write,
			                       DefaultData := "[2,'PM$00$00$00$00$00$00']");
			Cfg_BadDateString : STRING_20 (Description := "Invalid Date String",
			                            ExternalAccess := Read/Write,
			                            DefaultData := "[15,'<Invalid Date!>$00$00$00$00$00']");
			Cfg_BadTimeString : STRING_20 (Description := "Invalid Time String",
			                            ExternalAccess := Read/Write,
			                            DefaultData := "[15,'<Invalid Time!>$00$00$00$00$00']");
			Wrk_DateString : STRING (Description := "Date Building String",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_TimeString : STRING (Description := "Time Building String",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Wrk_NullString : STRING (Description := "Empty String for initialization",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Space : STRING_8 (Description := "String containing one blank space",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[1,' $00$00$00$00$00$00$00']");
			Cfg_Colon : STRING_8 (Description := "String containing a colon ($Q:$Q) character",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[1,':$00$00$00$00$00$00$00']");
			Cfg_CommaSpace : STRING_8 (Description := "String containing a comma and following space",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[2,', $00$00$00$00$00$00']");
			Cfg_Hyphen : STRING_8 (ExternalAccess := Read/Write,
			                     DefaultData := "[1,'-$00$00$00$00$00$00$00']");
			Wrk_Digit : STRING_8 (Description := "Small string for building a single digit only",
			                    ExternalAccess := Read/Write,
			                    DefaultData := "[1,'0$00$00$00$00$00$00$00']");
			Wrk_YearString : STRING_20 (Description := "Year as STRING for display",
			                         ExternalAccess := Read/Write,
			                         DefaultData := "[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']");
			Cfg_Period : STRING_8 (ExternalAccess := Read/Write,
			                     DefaultData := "[1,'.$00$00$00$00$00$00$00']");
			Wrk_Hour : DINT (Description := "Hour 1 to 12 for 12-hour time",
			                   RADIX := Decimal,
			                   ExternalAccess := Read/Write,
			                   DefaultData := 0);
		END_LOCAL_TAGS

		ST_ROUTINE Logic (Description := "Convert given date and time to formatted text string")
			'// T_TtoS : TIME -- DATE/TIME TO A PRINTABLE STRING
			'// 
			'// This instruction takes the given date and formats it as a human-readable STRING.  For example,
			'// for the Date/Time:
			'//		2008  12  31  23  59  59  999999
			'// the return STRING will be:
			'//      Wednesady, December 31, 2008  11:59:59.999999 p.m.
			'//
			'// Options are provided for returning the time in 24- or 12-hour format (with a.m. or p.m. indicator on the 12-hour format)
			'// and for including the microseconds, seconds, Day of the Week, or just an ISO-date format.
			'//
			'// This instruction checks for a valid (Gregorian) Date and Time and returns "Invalid Date" and/or "Invalid Time" as appropriate.
			'//   *  0 <= Microseconds < 1,000,000
			'//   *  0 <= Seconds < 60
			'//   *  0 <= Minutes < 60
			'//   *  0 <= Hours < 24
			'//   *  0 <= Days <= 31 and a valid Gregorian Date (Feb = 28 or 29 days, etc.)
			'//   *  1 <= Month <= 12
			'//   *  year in the range +/- 5879600
			'//
			'//  NOTE:  For algorithms used for Gregorian Date validity checking, see http://alcor.concordia.ca/~gpkatch/gdate-algorithm.html
			'//
			'//  Version 1.0-00 Release
			'//	Initial Formal Release
			'//
			'
			'// INITIALIZE the working strings for building the date and time
			'COP (Wrk_NullString, Wrk_DateString, 1);
			'COP (Wrk_NullString, Wrk_TimeString, 1);
			'
			'// Get the Day of the Week for the given Date.  This also does a validity check on the date!
			'T_DoW (DoW, Ref_DT);
			'
			'// If the Date is invalid, copy the bad date string and flag it
			'If (DoW.Sts_InvDate) Then
			'	CONCAT (Wrk_DateString, Cfg_BadDateString, Wrk_DateString);
			'	Sts_InvDate := 1;
			'Else
			'
			'// Date is valid, do we want ISO-date (YYYY-MM-DD) or pretty date?
			'	Sts_InvDate := 0;
			'	If (Cfg_ISODate) Then
			'		DTOS (Ref_DT.Yr, Wrk_YearString);
			'		CONCAT (Wrk_YearString, Cfg_Hyphen, Wrk_DateString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Mo / 10)+48;
			'		CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Mo MOD 10)+48;
			'		CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'		CONCAT (Wrk_DateString, Cfg_Hyphen, Wrk_DateString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Da / 10)+48;
			'		CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Da MOD 10)+48;
			'		CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'	Else
			'
			'// Pretty date: first, do we include Day (of the week) name?
			'		If (Cfg_InclDoW) Then
			'			If (Cfg_DayFirst) Then
			'				CONCAT (Cfg_DayNames[DoW.Out],Cfg_Space,Wrk_DateString);
			'			Else
			'				CONCAT (Cfg_DayNames[DoW.Out],Cfg_CommaSpace,Wrk_DateString);
			'			End_If;
			'		End_If;
			'
			'// Next, is the day number first or the month name?
			'		If (Cfg_DayFirst) Then
			'			If (Ref_DT.Da > 9) Then
			'				Wrk_Digit.DATA[0] := (Ref_DT.Da / 10)+48;
			'				CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'			End_If;
			'			Wrk_Digit.DATA[0] := (Ref_DT.Da MOD 10)+48;
			'			CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'			CONCAT (Wrk_DateString, Cfg_Space, Wrk_DateString);
			'			CONCAT (Wrk_DateString, Cfg_MonthNames[Ref_DT.Mo-1], Wrk_DateString);
			'			CONCAT (Wrk_DateString, Cfg_Space, Wrk_DateString);
			'		Else
			'			CONCAT (Wrk_DateString, Cfg_MonthNames[Ref_DT.Mo-1], Wrk_DateString);
			'			CONCAT (Wrk_DateString, Cfg_Space, Wrk_DateString);
			'			If (Ref_DT.Da > 9) Then
			'				Wrk_Digit.DATA[0] := (Ref_DT.Da / 10)+48;
			'				CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'			End_If;
			'			Wrk_Digit.DATA[0] := (Ref_DT.Da MOD 10)+48;
			'			CONCAT (Wrk_DateString, Wrk_Digit, Wrk_DateString);
			'			CONCAT (Wrk_DateString, Cfg_CommaSpace, Wrk_DateString);
			'		End_If;
			'
			'// Final part of the pretty date is the year, in whatever number of digits it needs
			'		DTOS (Ref_DT.Yr, Wrk_YearString);
			'		CONCAT (Wrk_DateString, Wrk_YearString, Wrk_DateString);
			'	End_If;
			'End_If;
			'
			'// Check if the time is invalid.  If so, copy the bad time string and flag it
			'If (((Ref_DT.Hr<0) OR (Ref_DT.Hr>23) OR (Ref_DT.Min<0) OR (Ref_DT.Min>59)) OR ((Ref_DT.Sec<0) OR (Ref_DT.Sec>59) OR (Ref_DT.uSec<0)) OR (Ref_DT.uSec>999999)) Then
			'	CONCAT (Wrk_TimeString, Cfg_BadTimeString, Wrk_TimeString);
			'	Sts_InvTime := 1;
			'Else
			'
			'// Time is valid, so generate the time string.  Do we want 12-hour time with no leading zero or 24-hour time with leading zero?
			'	Sts_InvTime := 0;
			'	If (Cfg_12Hr AND (NOT Cfg_ISODate)) Then
			'		Wrk_Hour := ((Ref_DT.Hr+11) MOD 12) +1;
			'		If (Wrk_Hour > 9) Then
			'			Wrk_Digit.DATA[0] := (Wrk_Hour / 10)+48;
			'			CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		End_If;
			'		Wrk_Digit.DATA[0] := (Wrk_Hour MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'	Else
			'		Wrk_Digit.DATA[0] := (Ref_DT.Hr / 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Hr MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'	End_If;
			'	CONCAT (Wrk_TimeString, Cfg_Colon, Wrk_TimeString);
			'
			'// Minutes: always two digits
			'	Wrk_Digit.DATA[0] := (Ref_DT.Min / 10)+48;
			'	CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'	Wrk_Digit.DATA[0] := (Ref_DT.Min MOD 10)+48;
			'	CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'
			'// Seconds, if selected
			'	If (Cfg_InclSec) Then
			'		CONCAT (Wrk_TimeString, Cfg_Colon, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Sec / 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.Sec MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'	End_If;
			'
			'// Microseconds, if seconds and microseconds selected
			'	If (Cfg_InclSec AND Cfg_InclMicrosec) Then
			'		CONCAT (Wrk_TimeString, Cfg_Period, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.uSec / 100000)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := ((Ref_DT.uSec / 10000) MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := ((Ref_DT.uSec / 1000) MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := ((Ref_DT.uSec / 100) MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := ((Ref_DT.uSec / 10) MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'		Wrk_Digit.DATA[0] := (Ref_DT.uSec MOD 10)+48;
			'		CONCAT (Wrk_TimeString, Wrk_Digit, Wrk_TimeString);
			'	End_If;
			'
			'// Finally, if 12-hour and not ISO, add AM/PM indicator
			'	If (Cfg_12Hr AND (NOT Cfg_ISODate)) Then
			'		CONCAT (Wrk_TimeString, Cfg_Space, Wrk_TimeString);
			'		If (Ref_DT.Hr >= 12) Then
			'			CONCAT (Wrk_TimeString, Cfg_PMString, Wrk_TimeString);
			'		Else
			'			CONCAT (Wrk_TimeString, Cfg_AMString, Wrk_TimeString);
			'		End_If;
			'	End_If;
			'End_If;
			'
			'// Last, Output = date <space> time
			'CONCAT (Wrk_DateString,Cfg_Space,Wrk_DateString);
			'CONCAT (Wrk_DateString,Wrk_TimeString,Ref_Out);
			'
		END_ST_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION WAGO_1505 (Description := "Packs boolean data for processing by a WAGO 750-1505 16-Channel Digital Output Module.",
	                                         Revision := "1.0",
	                                         ExecutePrescan := No,
	                                         ExecutePostscan := No,
	                                         ExecuteEnableInFalse := No,
	                                         CreatedDate := "2009-08-05T16:34:19.287Z",
	                                         CreatedBy := "PC0802\Larry",
	                                         EditedDate := "2010-01-15T22:05:44.546Z",
	                                         EditedBy := "PC0802\Larry",
	                                         SoftwareRevision := "v16.03",
	                                         AdditionalHelpText := "The WAGO_1505 instruction packs boolean data for processing by a WAGO 750-1505 16-Channel Digital Output Module.  When then $'Enable$' input is TRUE, the instruction captures the data at each of the 16 boolean inputs and packs the data into a 2-byte (SINT) data structure for processing by the module.$N$NThe $'ModuleOutputs$' array must be mapped to the 2-byte (SINT) output process image of the respective WAGO 750-1505 16-Channel Digital Output Module.$N$NUse the Copy (COP) instruction to copy the 750-1505 module$'s 2-byte (SINT) output process image (see $'Controller Tags$') from a SINT[2] array for passing data from the $'ModuleOutputs$' InOut array.  Perform this operation after calling the 750_1505 Add-On Instruction.$N$NConsult the WAGO 750-1505 Product Manual for further information about the 16-Channel Digital Output Module.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			ModuleOutputs : SINT[2] (Description := "Output process image of WAGO 750-1505 module.",
			                         Usage := InOut,
			                         RADIX := Decimal,
			                         Required := Yes,
			                         Visible := Yes);
			Output00 : BOOL (Description := "Channel 0 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output01 : BOOL (Description := "Channel 1 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output02 : BOOL (Description := "Channel 2 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output03 : BOOL (Description := "Channel 3 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output04 : BOOL (Description := "Channel 4 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output05 : BOOL (Description := "Channel 5 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output06 : BOOL (Description := "Channel 6 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output07 : BOOL (Description := "Channel 7 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output08 : BOOL (Description := "Channel 8 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output09 : BOOL (Description := "Channel 9 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output10 : BOOL (Description := "Channel 10 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output11 : BOOL (Description := "Channel 11 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output12 : BOOL (Description := "Channel 12 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output13 : BOOL (Description := "Channel 13 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output14 : BOOL (Description := "Channel 14 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
			Output15 : BOOL (Description := "Channel 15 Output Status",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
		END_LOCAL_TAGS

		ROUTINE Logic 
				N: [XIC(Output00) OTE(ModuleOutputs[0].0) ,XIC(Output01) OTE(ModuleOutputs[0].1) ,XIC(Output02) OTE(ModuleOutputs[0].2) ,XIC(Output03) OTE(ModuleOutputs[0].3) ,XIC(Output04) OTE(ModuleOutputs[0].4) ,XIC(Output05) OTE(ModuleOutputs[0].5) ,XIC(Output06) OTE(ModuleOutputs[0].6) ,XIC(Output07) OTE(ModuleOutputs[0].7) ];
				N: [XIC(Output08) OTE(ModuleOutputs[1].0) ,XIC(Output09) OTE(ModuleOutputs[1].1) ,XIC(Output10) OTE(ModuleOutputs[1].2) ,XIC(Output11) OTE(ModuleOutputs[1].3) ,XIC(Output12) OTE(ModuleOutputs[1].4) ,XIC(Output13) OTE(ModuleOutputs[1].5) ,XIC(Output14) OTE(ModuleOutputs[1].6) ,XIC(Output15) OTE(ModuleOutputs[1].7) ];
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION WAGO_455 (Description := "Normalizes data received from a WAGO 750-455 4-Channel 4-20mA Analog Input Module.",
	                                        Revision := "1.1",
	                                        RevisionNote := "Changed condition for overcurrent detection.",
	                                        ExecutePrescan := No,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := No,
	                                        CreatedDate := "2009-08-05T16:34:19.287Z",
	                                        CreatedBy := "PC0802\Larry",
	                                        EditedDate := "2018-07-26T16:47:11.636Z",
	                                        EditedBy := "pc05303\LARRY",
	                                        SoftwareRevision := "v29.00",
	                                        AdditionalHelpText := "The WAGO_455 instruction normalizes data received from a WAGO 750-455 4-Channel 4-20mA Analog Input Module.  When it is enabled, the instruction provides the following information:$N$N    Channel 1 current expressed as numerical value from 0 to 32763$N    Channel 1 current in mA (x100)$N    Channel 1 under-current or broken wire detection$N    Channel 1 over-current detection$N$N    Channel 2 current expressed as numerical value from 0 to 32763$N    Channel 2 current in mA (x100)$N    Channel 2 under-current or broken wire detection$N    Channel 2 over-current detection$N$N    Channel 3 current expressed as numerical value from 0 to 32763$N    Channel 3 current in mA (x100)$N    Channel 3 under-current or broken wire detection$N    Channel 3 over-current detection$N$N    Channel 4 current expressed as numerical value from 0 to 32763$N    Channel 4 current in mA (x100)$N    Channel 4 under-current or broken wire detection$N    Channel 4 over-current detection$N$NThe $'ModuleInputs$' array must be mapped to the 8-byte (SINT) input process image of the respective WAGO 750-455 4-Channel 4-20mA Analog Input Module.$N$NUse the Copy (COP) instruction to copy the 750-455 module$'s 8-byte (SINT) input process image (see $'Controller Tags$') to a SINT[8] array for passing data to the $'ModuleInputs$' InOut array.  Perform this operation before calling the 750_455 Add-On Instruction.$N$NThe outputs Ch#_Undercurrent provide the following indication:$N$N    Off (FALSE) :  Current reading is greater than or equal to the threshold value of 4mA.$N    On (TRUE)  :  Current reading is less than the threshold value of 4mA.$N$NThe outputs Ch#_Overcurrent provide the following indication:$N$N    Off (FALSE) :  Current reading is less than or equal to the threshold value of 20mA.$N    On (TRUE)  :  Current reading is greater than the threshold value of 20mA.$N$NConsult the WAGO 750-455 Product Manual for further information about the 4-Channel 4-20mA Analog Input Module.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			ModuleInputs : SINT[8] (Description := "Input process image of WAGO 750-455 module.",
			                        COMMENT[1].7 := "TC1 Sign Bit",
			                        COMMENT[3].7 := "TC2 Sign Bit",
			                        Usage := InOut,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes);
			Ch1_Value : DINT (Description := "Channel 1 Current Expressed as Numerical Value from 0 to 32763",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Ch1_Current : DINT (Description := "Channel 1 Current in mA (x100)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Ch1_UnderCurrent : BOOL (Description := "Channel 1 Under-Current or Broken Wire Detected",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Ch1_OverCurrent : BOOL (Description := "Channel 1 Over-Current Detected",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Ch2_Value : DINT (Description := "Channel 2 Current Expressed as Numerical Value from 0 to 32763",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Ch2_Current : DINT (Description := "Channel 2 Current in mA (x100)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Ch2_UnderCurrent : BOOL (Description := "Channel 2 Under-Current or Broken Wire Detected",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Ch2_OverCurrent : BOOL (Description := "Channel 2 Over-Current Detected",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Ch3_Value : DINT (Description := "Channel 3 Current Expressed as Numerical Value from 0 to 32763",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Ch3_Current : DINT (Description := "Channel 3 Current in mA (x100)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Ch3_UnderCurrent : BOOL (Description := "Channel 3 Under-Current or Broken Wire Detected",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Ch3_OverCurrent : BOOL (Description := "Channel 3 Over-Current Detected",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
			Ch4_Value : DINT (Description := "Channel 4 Current Expressed as Numerical Value from 0 to 32763",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Ch4_Current : DINT (Description := "Channel 4 Current in mA (x100)",
			                       Usage := Output,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       ExternalAccess := Read Only,
			                       DefaultData := 0);
			Ch4_UnderCurrent : BOOL (Description := "Channel 4 Under-Current or Broken Wire Detected",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Ch4_OverCurrent : BOOL (Description := "Channel 4 Over-Current Detected",
			                           Usage := Output,
			                           RADIX := Decimal,
			                           Required := No,
			                           Visible := Yes,
			                           ExternalAccess := Read Only,
			                           DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			tmpREAL : REAL[8] (RADIX := Float,
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000]");
			tmpDINT : DINT[12] (RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[0,0,0,0,0,0,0,0,0,0,0,0]");
		END_LOCAL_TAGS

		ROUTINE Logic 
				N: BTD(ModuleInputs[0],0,tmpDINT[0],0,8)BTD(ModuleInputs[1],0,tmpDINT[1],8,8)ADD(tmpDINT[1],tmpDINT[0],tmpDINT[2]);
				N: MOV(tmpDINT[2],Ch1_Value);
				N: MOV(Ch1_Value,tmpREAL[0])DIV(tmpREAL[0],20.48,tmpREAL[1])ADD(tmpREAL[1],400,Ch1_Current);
				N: EQU(Ch1_Value,16#0003)OTE(Ch1_UnderCurrent);
				N: EQU(Ch1_Value,16#7FFB)OTE(Ch1_OverCurrent);
				N: BTD(ModuleInputs[2],0,tmpDINT[3],0,8)BTD(ModuleInputs[3],0,tmpDINT[4],8,8)ADD(tmpDINT[4],tmpDINT[3],tmpDINT[5]);
				N: MOV(tmpDINT[5],Ch2_Value);
				N: MOV(Ch2_Value,tmpREAL[2])DIV(tmpREAL[2],20.48,tmpREAL[3])ADD(tmpREAL[3],400,Ch2_Current);
				N: EQU(Ch2_Value,16#0003)OTE(Ch2_UnderCurrent);
				N: EQU(Ch2_Value,16#7FFB)OTE(Ch2_OverCurrent);
				N: BTD(ModuleInputs[4],0,tmpDINT[6],0,8)BTD(ModuleInputs[5],0,tmpDINT[7],8,8)ADD(tmpDINT[7],tmpDINT[6],tmpDINT[8]);
				N: MOV(tmpDINT[8],Ch3_Value);
				N: MOV(Ch3_Value,tmpREAL[4])DIV(tmpREAL[4],20.48,tmpREAL[5])ADD(tmpREAL[5],400,Ch3_Current);
				N: EQU(Ch3_Value,16#0003)OTE(Ch3_UnderCurrent);
				N: EQU(Ch3_Value,16#7FFB)OTE(Ch3_OverCurrent);
				N: BTD(ModuleInputs[6],0,tmpDINT[9],0,8)BTD(ModuleInputs[7],0,tmpDINT[10],8,8)ADD(tmpDINT[10],tmpDINT[9],tmpDINT[11]);
				N: MOV(tmpDINT[11],Ch4_Value);
				N: MOV(Ch4_Value,tmpREAL[6])DIV(tmpREAL[6],20.48,tmpREAL[7])ADD(tmpREAL[7],400,Ch4_Current);
				N: EQU(Ch4_Value,16#0003)OTE(Ch4_UnderCurrent);
				N: EQU(Ch4_Value,16#7FFB)OTE(Ch4_OverCurrent);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION WAGO_461 (Description := "Normalizes data received from a WAGO 750-461 2-Channel RTD Analog Input Module.",
	                                        Revision := "1.2",
	                                        RevisionNote := "Changed handling of negative values.",
	                                        ExecutePrescan := No,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := No,
	                                        CreatedDate := "2009-08-05T16:34:19.287Z",
	                                        CreatedBy := "PC0802\Larry",
	                                        EditedDate := "2011-08-12T16:53:14.448Z",
	                                        EditedBy := "PC0802\Larry",
	                                        SoftwareRevision := "v16.03",
	                                        AdditionalHelpText := "The WAGO_461 instruction normalizes data received from a WAGO 750-461 2-Channel RTD Analog Input Module and its variants.  When it is enabled, the instruction provides the following information:$N$N    Channel 1 measurement expressed as numerical value (Hex)$N    Channel 1 temperature in degC x10 (for Pt and Ni RTD sensors only)$N    Channel 1 resistance in ohms (for resistance measuring only)$N    Channel 1 under-range detection$N    Channel 1 over-range detection (e.g. broken wire)$N$N    Channel 2 measurement expressed as numerical value (Hex)$N    Channel 2 temperature in degC x10 (for Pt and Ni RTD sensors only)$N    Channel 2 resistance in ohms (for resistance measuring only)$N    Channel 2 under-range detection$N    Channel 2 over-range detection (e.g. broken wire)$N$NThe $'ModuleInputs$' array must be mapped to the 4-byte (SINT) input process image of the respective WAGO 750-461 2-Channel RTD Analog Input Module.$N$NUse the Copy (COP) instruction to copy the 750-461 module$'s 4-byte (SINT) input process image (see $'Controller Tags$') to a SINT[4] array for passing data to the $'ModuleInputs$' InOut array.  Perform this operation before calling the 750_461 Add-On Instruction.$N$NNote: This instruction will only work with the standard 750-461 module and the following variants:  $N750-461/000-002$N750-461/000-003$N750-461/000-004$N750-461/000-005$N750-461/000-006$N750-461/000-007$N750-461/003-000 (configured as one of the variants listed here)$NOther variations of this module are not currently supported.$N$NThe Ch1_RTD_Type and Ch2_RTD_Type instruction inputs allow selection of the resistive type for the respective module input channel.  Enter the value 0-9 to define the resistive type for each channel:$N$N    0 : Pt100 (default)$N    1 : Reserved (not currently supported)$N    2 : Reserved (not currently supported)$N    3 : Pt1000$N    4 : Ni100$N    5 : Reserved (not currently supported)$N    6 : Ni1000$N    7 : 10 Ohm to 1.2 kOhm$N    8 : 10 Ohm to 5.0 kOhm$N    9 : Channel not in use$N$NConsult the WAGO 750-461 Product Manual for further information about the 2-Channel RTD Analog Input Module.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			ModuleInputs : SINT[4] (Description := "Input process image of WAGO 750-461 module.",
			                        COMMENT[1].7 := "TC1 Sign Bit",
			                        COMMENT[3].7 := "TC2 Sign Bit",
			                        Usage := InOut,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes);
			Ch1_Value : DINT (Description := "Ch 1 Resistance Value (Hex)",
			                     Usage := Output,
			                     RADIX := Hex,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Ch1_Temp_degCx10 : DINT (Description := "Channel 1 Temperature (degCx10)",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Ch1_Ohms : DINT (Description := "Channel 1 Resistance (ohms)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Ch1_RTD_Type : DINT (Description := "(See Add-On Help for RTD Types)",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes,
			                        DefaultData := 0);
			Ch1_UnderRange : BOOL (Description := "Channel 1 Under-Range Detected",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Ch1_OverRange : BOOL (Description := "Channel 1 Over-Range Detected",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
			Ch2_Value : DINT (Description := "Ch 2 Resistance Value (Hex)",
			                     Usage := Output,
			                     RADIX := Hex,
			                     Required := No,
			                     Visible := Yes,
			                     ExternalAccess := Read Only,
			                     DefaultData := 0);
			Ch2_Temp_degCx10 : DINT (Description := "Channel 2 Temperature (degCx10)",
			                            Usage := Output,
			                            RADIX := Decimal,
			                            Required := No,
			                            Visible := Yes,
			                            ExternalAccess := Read Only,
			                            DefaultData := 0);
			Ch2_Ohms : DINT (Description := "Channel 2 Resistance (ohms)",
			                    Usage := Output,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := Yes,
			                    ExternalAccess := Read Only,
			                    DefaultData := 0);
			Ch2_RTD_Type : DINT (Description := "(See Add-On Help for RTD Types)",
			                        Usage := Input,
			                        RADIX := Decimal,
			                        Required := Yes,
			                        Visible := Yes,
			                        DefaultData := 0);
			Ch2_UnderRange : BOOL (Description := "Channel 2 Under-Range Detected",
			                          Usage := Output,
			                          RADIX := Decimal,
			                          Required := No,
			                          Visible := Yes,
			                          ExternalAccess := Read Only,
			                          DefaultData := 0);
			Ch2_OverRange : BOOL (Description := "Channel 2 Over-Range Detected",
			                         Usage := Output,
			                         RADIX := Decimal,
			                         Required := No,
			                         Visible := Yes,
			                         ExternalAccess := Read Only,
			                         DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			tmpDINT : DINT[10] (RADIX := Decimal,
			                  ExternalAccess := Read/Write,
			                  DefaultData := "[0,0,0,0,0,0,0,0,0,0]");
			tmpINT : INT (RADIX := Decimal,
			                 ExternalAccess := Read/Write,
			                 DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				RC: "**** CHANNEL 1 ****";
				N: BTD(ModuleInputs[0],0,tmpDINT[0],0,8)BTD(ModuleInputs[1],0,tmpDINT[1],8,8)ADD(tmpDINT[1],tmpDINT[0],tmpDINT[2])MOV(tmpDINT[2],Ch1_Value);
				RC: "**** Pt100, Pt1000 ****";
				N: [EQU(Ch1_RTD_Type,0) ,EQU(Ch1_RTD_Type,3) ][NEQ(Ch1_Value,16#8001) MOV(Ch1_Value,tmpINT) MOV(tmpINT,Ch1_Temp_degCx10) ,MOV(0,Ch1_Ohms) ,[EQU(Ch1_Value,16#8001) MOV(-2000,Ch1_Temp_degCx10) OTL(Ch1_UnderRange) ,NEQ(Ch1_Value,16#8001) OTU(Ch1_UnderRange) ] ,[EQU(Ch1_Value,16#2134) OTL(Ch1_OverRange) ,NEQ(Ch1_Value,16#2134) OTU(Ch1_OverRange) ] ];
				RC: "**** Ni100, Ni1000 ****";
				N: [EQU(Ch1_RTD_Type,4) ,EQU(Ch1_RTD_Type,6) ][NEQ(Ch1_Value,16#8001) NEQ(Ch1_Value,16#2134) MOV(Ch1_Value,tmpINT) MOV(tmpINT,Ch1_Temp_degCx10) ,MOV(0,Ch1_Ohms) ,[EQU(Ch1_Value,16#8001) MOV(-600,Ch1_Temp_degCx10) OTL(Ch1_UnderRange) ,NEQ(Ch1_Value,16#8001) OTU(Ch1_UnderRange) ] ,[EQU(Ch1_Value,16#2134) MOV(2500,Ch1_Temp_degCx10) OTL(Ch1_OverRange) ,NEQ(Ch1_Value,16#2134) OTU(Ch1_OverRange) ] ];
				RC: "**** 10 0hm to 1.2 k-ohm ****";
				N: EQU(Ch1_RTD_Type,7)[NEQ(Ch1_Value,16#EC00) NEQ(Ch1_Value,16#2134) DIV(Ch1_Value,10,Ch1_Ohms) ,MOV(0,Ch1_Temp_degCx10) ,EQU(Ch1_Value,16#EC00) MOV(0,Ch1_Ohms) OTU(Ch1_UnderRange) ,[EQU(Ch1_Value,16#2134) MOV(1200,Ch1_Ohms) OTL(Ch1_OverRange) ,NEQ(Ch1_Value,16#2134) OTU(Ch1_OverRange) ] ];
				RC: "**** 10 0hm to 5.0 k-ohm ****";
				N: EQU(Ch1_RTD_Type,8)[NEQ(Ch1_Value,16#EC00) NEQ(Ch1_Value,16#2710) DIV(Ch1_Value,2,Ch1_Ohms) ,MOV(0,Ch1_Temp_degCx10) ,EQU(Ch1_Value,16#EC00) MOV(0,Ch1_Ohms) OTU(Ch1_UnderRange) ,[EQU(Ch1_Value,16#2710) MOV(5000,Ch1_Ohms) OTL(Ch1_OverRange) ,NEQ(Ch1_Value,16#2710) OTU(Ch1_OverRange) ] ];
				RC: "**** Unsupported RTD_Type Entered ****";
				N: [LES(Ch1_RTD_Type,0) ,GRT(Ch1_RTD_Type,8) ,EQU(Ch1_RTD_Type,1) ,EQU(Ch1_RTD_Type,2) ,EQU(Ch1_RTD_Type,5) ][MOV(0,Ch1_Temp_degCx10) ,MOV(0,Ch1_Ohms) ,OTU(Ch1_UnderRange) OTU(Ch1_OverRange) ];
				RC: "**** CHANNEL 2 ****";
				N: BTD(ModuleInputs[2],0,tmpDINT[5],0,8)BTD(ModuleInputs[3],0,tmpDINT[6],8,8)ADD(tmpDINT[6],tmpDINT[5],tmpDINT[7])MOV(tmpDINT[7],Ch2_Value);
				RC: "**** Pt100, Pt1000 ****";
				N: [EQU(Ch2_RTD_Type,0) ,EQU(Ch2_RTD_Type,3) ][NEQ(Ch2_Value,16#8001) MOV(Ch2_Value,tmpINT) MOV(tmpINT,Ch2_Temp_degCx10) ,MOV(0,Ch2_Ohms) ,[EQU(Ch2_Value,16#8001) MOV(-2000,Ch2_Temp_degCx10) OTL(Ch2_UnderRange) ,NEQ(Ch2_Value,16#8001) OTU(Ch2_UnderRange) ] ,[EQU(Ch2_Value,16#2134) OTL(Ch2_OverRange) ,NEQ(Ch2_Value,16#2134) OTU(Ch2_OverRange) ] ];
				RC: "**** Ni100, Ni1000 ****";
				N: [EQU(Ch2_RTD_Type,4) ,EQU(Ch2_RTD_Type,6) ][NEQ(Ch2_Value,16#8001) NEQ(Ch2_Value,16#2134) MOV(Ch2_Value,tmpINT) MOV(tmpINT,Ch2_Temp_degCx10) ,MOV(0,Ch2_Ohms) ,[EQU(Ch2_Value,16#8001) MOV(-600,Ch2_Temp_degCx10) OTL(Ch2_UnderRange) ,NEQ(Ch2_Value,16#8001) OTU(Ch2_UnderRange) ] ,[EQU(Ch2_Value,16#2134) MOV(2500,Ch2_Temp_degCx10) OTL(Ch2_OverRange) ,NEQ(Ch2_Value,16#2134) OTU(Ch2_OverRange) ] ];
				RC: "**** 10 0hm to 1.2 k-ohm ****";
				N: EQU(Ch2_RTD_Type,7)[NEQ(Ch2_Value,16#EC00) NEQ(Ch2_Value,16#2134) DIV(Ch2_Value,10,Ch2_Ohms) ,MOV(0,Ch2_Temp_degCx10) ,EQU(Ch2_Value,16#EC00) MOV(0,Ch2_Ohms) OTU(Ch2_UnderRange) ,[EQU(Ch2_Value,16#2134) MOV(1200,Ch2_Ohms) OTL(Ch2_OverRange) ,NEQ(Ch2_Value,16#2134) OTU(Ch2_OverRange) ] ];
				RC: "**** 10 0hm to 5.0 k-ohm ****";
				N: EQU(Ch2_RTD_Type,8)[NEQ(Ch2_Value,16#EC00) NEQ(Ch2_Value,16#2710) DIV(Ch2_Value,2,Ch2_Ohms) ,MOV(0,Ch2_Temp_degCx10) ,EQU(Ch2_Value,16#EC00) MOV(0,Ch2_Ohms) OTU(Ch2_UnderRange) ,[EQU(Ch2_Value,16#2710) MOV(5000,Ch2_Ohms) OTL(Ch2_OverRange) ,NEQ(Ch2_Value,16#2710) OTU(Ch2_OverRange) ] ];
				RC: "**** Unsupported RTD_Type Entered ****";
				N: [LES(Ch2_RTD_Type,0) ,GRT(Ch2_RTD_Type,8) ,EQU(Ch2_RTD_Type,1) ,EQU(Ch2_RTD_Type,2) ,EQU(Ch2_RTD_Type,5) ][MOV(0,Ch2_Temp_degCx10) ,MOV(0,Ch2_Ohms) ,OTU(Ch2_UnderRange) OTU(Ch2_OverRange) ];
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	ADD_ON_INSTRUCTION_DEFINITION WAGO_559 (Description := "Prepares data for processing by a WAGO 750-559 4-Channel 0-10VDC Analog Output Module.",
	                                        Revision := "1.0",
	                                        ExecutePrescan := No,
	                                        ExecutePostscan := No,
	                                        ExecuteEnableInFalse := No,
	                                        CreatedDate := "2009-08-05T16:34:19.287Z",
	                                        CreatedBy := "PC0802\Larry",
	                                        EditedDate := "2010-05-10T21:05:00.824Z",
	                                        EditedBy := "PC0802\Larry",
	                                        SoftwareRevision := "v16.03",
	                                        AdditionalHelpText := "The WAGO_559 instruction prepares data for processing by a WAGO 750-559 4-Channel 0-10VDC Analog Output Module.  When the $'Enable$' input is TRUE, the instruction monitors the Value and Voltage input values for each channel and makes the following determination:$N$N    If Value >= 0 and Voltage = 0, then the channel output will be determined by the Value input.$N    If Voltage > 0 and Value = 0, then the channel output will be determined by the Voltage input.$N    If Value > 0 and Voltage > 0, then the input value is considered invalid, and the channel output will be 0V.$N    If Value = 0 and Voltage = 0, then the output will be 0V.$N$NIf using the Value input, a number from 0-32767 must be entered.  The instruction will use this number to produce a linear scaled output from 0-10VDC.$N $NIf using the Voltage input, a number from 0 to 10000 must be entered, representing the desired mV output of the module.$N$NThe $'ModuleOutputs$' array must be mapped to the 8-byte (SINT) output process image of the respective WAGO 750-559 4-Channel 0-10VDC Analog Output Module.$N$NUse the Copy (COP) instruction to copy the 750-559 module$'s 8-byte (SINT) output process image (see $'Controller Tags$') from a SINT[8] array for passing data from the $'ModuleOutputs$' InOut array.  Perform this operation after calling the 750_559 Add-On Instruction.$N$NThe outputs ChX_InputErr provide the following indication:$N$N    Off (FALSE) :  Value and Voltage input parameters are within the permissible range.$N    On (TRUE)  :  Value or Voltage input parameters exceed the permissible range, or are both > 0.$N$NConsult the WAGO 750-559 Product Manual for further information about the 4-Channel 0-10VDC Analog Output Module.")
		PARAMETERS
			EnableIn : BOOL (Description := "Enable Input - System Defined Parameter",
			                    Usage := Input,
			                    RADIX := Decimal,
			                    Required := No,
			                    Visible := No,
			                    ExternalAccess := Read Only);
			EnableOut : BOOL (Description := "Enable Output - System Defined Parameter",
			                     Usage := Output,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := No,
			                     ExternalAccess := Read Only);
			ModuleOutputs : SINT[8] (Description := "Output process image of WAGO 750-559 module.",
			                         COMMENT[1].7 := "TC1 Sign Bit",
			                         COMMENT[3].7 := "TC2 Sign Bit",
			                         Usage := InOut,
			                         RADIX := Decimal,
			                         Required := Yes,
			                         Visible := Yes);
			Ch1_Value : DINT (Description := "Channel 1 Voltage Expressed as Numerical Value from 0 to 32767",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Ch1_Voltage : DINT (Description := "Channel 1 Voltage in mV (0-10000)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Ch1_InputErr : BOOL (Description := "Channel 1 Value or Voltage Input Invalid",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Ch2_Value : DINT (Description := "Channel 2 Voltage Expressed as Numerical Value from 0 to 32767",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Ch2_Voltage : DINT (Description := "Channel 2 Voltage in mV (0-10000)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Ch2_InputErr : BOOL (Description := "Channel 2 Value or Voltage Input Invalid",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Ch3_Value : DINT (Description := "Channel 3 Voltage Expressed as Numerical Value from 0 to 32767",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Ch3_Voltage : DINT (Description := "Channel 3 Voltage in mV (0-10000)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Ch3_InputErr : BOOL (Description := "Channel 3 Value or Voltage Input Invalid",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
			Ch4_Value : DINT (Description := "Channel 4 Voltage Expressed as Numerical Value from 0 to 32767",
			                     Usage := Input,
			                     RADIX := Decimal,
			                     Required := No,
			                     Visible := Yes,
			                     DefaultData := 0);
			Ch4_Voltage : DINT (Description := "Channel 4 Voltage in mV (0-10000)",
			                       Usage := Input,
			                       RADIX := Decimal,
			                       Required := No,
			                       Visible := Yes,
			                       DefaultData := 0);
			Ch4_InputErr : BOOL (Description := "Channel 4 Value or Voltage Input Invalid",
			                        Usage := Output,
			                        RADIX := Decimal,
			                        Required := No,
			                        Visible := Yes,
			                        ExternalAccess := Read Only,
			                        DefaultData := 0);
		END_PARAMETERS

		LOCAL_TAGS
			diOutput1 : DINT (RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
			diOutput2 : DINT (RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
			diOutput4 : DINT (RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
			diOutput3 : DINT (RADIX := Decimal,
			                    ExternalAccess := Read/Write,
			                    DefaultData := 0);
		END_LOCAL_TAGS

		ROUTINE Logic 
				N: [[LES(Ch1_Value,0) ,GRT(Ch1_Value,32767) ] ,[LES(Ch1_Voltage,0) ,GRT(Ch1_Voltage,10000) ] ,GRT(Ch1_Value,0) GRT(Ch1_Voltage,0) ][OTE(Ch1_InputErr) ,MOV(0,diOutput1) ];
				N: XIO(Ch1_InputErr)[GRT(Ch1_Voltage,0) [CPT(diOutput1,Ch1_Voltage * 32768 / 10000) ,GRT(diOutput1,32767) MOV(32767,diOutput1) ] ,EQU(Ch1_Voltage,0) MOV(Ch1_Value,diOutput1) ];
				N: BTD(diOutput1,0,ModuleOutputs[0],0,8)BTD(diOutput1,8,ModuleOutputs[1],0,8);
				N: [[LES(Ch2_Value,0) ,GRT(Ch2_Value,32767) ] ,[LES(Ch2_Voltage,0) ,GRT(Ch2_Voltage,10000) ] ,GRT(Ch2_Value,0) GRT(Ch2_Voltage,0) ][OTE(Ch2_InputErr) ,MOV(0,diOutput2) ];
				N: XIO(Ch2_InputErr)[GRT(Ch2_Voltage,0) [CPT(diOutput2,Ch2_Voltage * 32768 / 10000) ,GRT(diOutput2,32767) MOV(32767,diOutput2) ] ,EQU(Ch2_Voltage,0) MOV(Ch2_Value,diOutput2) ];
				N: BTD(diOutput2,0,ModuleOutputs[2],0,8)BTD(diOutput2,8,ModuleOutputs[3],0,8);
				N: [[LES(Ch3_Value,0) ,GRT(Ch3_Value,32767) ] ,[LES(Ch3_Voltage,0) ,GRT(Ch3_Voltage,10000) ] ,GRT(Ch3_Value,0) GRT(Ch3_Voltage,0) ][OTE(Ch3_InputErr) ,MOV(0,diOutput3) ];
				N: XIO(Ch3_InputErr)[GRT(Ch3_Voltage,0) [CPT(diOutput3,Ch3_Voltage * 32768 / 10000) ,GRT(diOutput3,32767) MOV(32767,diOutput3) ] ,EQU(Ch3_Voltage,0) MOV(Ch3_Value,diOutput3) ];
				N: BTD(diOutput3,0,ModuleOutputs[4],0,8)BTD(diOutput3,8,ModuleOutputs[5],0,8);
				N: [[LES(Ch4_Value,0) ,GRT(Ch4_Value,32767) ] ,[LES(Ch4_Voltage,0) ,GRT(Ch4_Voltage,10000) ] ,GRT(Ch4_Value,0) GRT(Ch4_Voltage,0) ][OTE(Ch4_InputErr) ,MOV(0,diOutput4) ];
				N: XIO(Ch4_InputErr)[GRT(Ch4_Voltage,0) [CPT(diOutput4,Ch4_Voltage * 32768 / 10000) ,GRT(diOutput4,32767) MOV(32767,diOutput4) ] ,EQU(Ch4_Voltage,0) MOV(Ch4_Value,diOutput4) ];
				N: BTD(diOutput4,0,ModuleOutputs[6],0,8)BTD(diOutput4,8,ModuleOutputs[7],0,8);
		END_ROUTINE

	END_ADD_ON_INSTRUCTION_DEFINITION

	TAG
		Abort_MCV_Initial_Fill : BOOL (RADIX := Decimal) := 0;
		AIC0706 : PID_ENHANCED (Description := "Disolved Oxygen PID") := [1,40960,3.26333976e+000,2.00000000e+002,0.00000000e+000,9.00000000e+001,3.26333976e+000
				,0.00000000e+000,2.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,2.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,1.00000000e+000,5.00000000e-001,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,5.00000000e+001,2.50000000e+001,2.50000000e+001,5.00000000e+001
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,37748800,0.00000000e+000,0.00000000e+000,3.26333976e+000
				,1.63166988e+000,1.63166988e+000,0.00000000e+000,0.00000000e+000,1.00000000e+000,1.00000000e+000
				,0,0,0,0.00000000e+000,1.59545031e+001,-1.63166988e+000,0.00000000e+000,0.00000000e+000,-1.63166988e+000
				,-1.63166988e+000,1.00000000e+000,8.33333377e-003,0.00000000e+000,1.00000000e+000,1.00000000e+000
				,5.00000000e-001,0.00000000e+000,0.00000000e+000,3.26333976e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,1.41060040e-037,0.00000000e+000,1.63166988e+000,1.63166988e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042,3.70204165e-038
				,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,3.70204165e-038,7.89211295e-042
				,1.00000000e+000];
		AIC0707 : PID_ENHANCED (Description := "ph PID") := [1,40960,-9.99895996e+003,8.50000000e+000,5.50000000e+000,8.00000000e+000,5.50000000e+000
				,0.00000000e+000,8.50000000e+000,5.50000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,5.00000000e+001,5.00000000e+001,5.00000000e+001,5.00000000e+001,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,2.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,2.00000000e+000,1.00000000e+000,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,5.00000000e-001,3.00000000e-001,3.00000000e-001,5.00000000e-001
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,40894816,5.00000000e+001,5.00000000e+001,5.50000000e+000
				,0.00000000e+000,-3.33482000e+005,1.00044600e+004,3.33482000e+005,1.00000000e+000,1.00000000e+000
				,0,0,0,0.00000000e+000,5.82605713e+003,3.33482000e+005,3.33482000e+005,3.33482000e+005,3.33482000e+005
				,3.33482000e+005,2.00000000e+000,1.66666675e-002,0.00000000e+000,1.00000000e+000,2.00000000e+000
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,-9.99895996e+003,0.00000000e+000,5.00000000e+001
				,1.00044600e+004,0.00000000e+000,1.76328099e-037,1.00044600e+004,-3.33482000e+005,0.00000000e+000
				,5.00000000e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042,3.70204165e-038
				,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,3.70204165e-038,7.89211295e-042
				,1.00000000e+000];
		AIC703 : P_AInAdv (Description := "BRX DO PV") := [3,5.61536560e+001,0,0,2,0.00000000e+000,3.00000000e+002,0.00000000e+000,3.00000000e+002,0.00000000e+000
				,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002,1.00000000e+000
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,3.00000000e+002,0.00000000e+000
				,2.50000000e+002,0.00000000e+000,9.50000000e+001,0.00000000e+000,9.00000000e+001,0.00000000e+000
				,1.00000000e+002,1.00000000e+000,2.00000000e+001,1.00000000e+000,-2.00000000e+001,1.00000000e+000
				,3.01000000e+002,-2.08333325e+000,4.16666657e-001,5.61536598e+001,5.61536598e+001,5.61536598e+001
				,5.61536598e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00314362e+002,0.00000000e+000
				,3.00000000e+002,1,1,24,0,0,2098692,[967,750,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[13,'Low-Low Alarm$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[967,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9
				,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[10
				,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,750,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15
				,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[1,'%$00$00$00$00$00$00$00'],[6,'AIC703$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'BRX DO PV$00$00$00$00$00$00$00$00$00$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],0,0,24,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.61536598e+001,1.00000000e-001
				,5.61536598e+001,0.00000000e+000,1.00314362e+002,[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072829449,2147483647,0],0.00000000e+000,1113627992,1113627993,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[0,0,0],[-1609700361,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[0,0,0],[-1609700361,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[0,0,0],[-1609700361,0,0],[17,'PV Deviation High$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[1171579,0,0],[-1609700361,0,0],[-1609700361
				,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[1171579
				,0,0],[-1609700361,0,0],[-1609700361,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[0,0,0],[-1609700361,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[0,0,0],[-1609700361,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[3798590,0,0],[-1609700361
				,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[6,'RA-BAS$00$00$00$00$00$00'],[6,'area01$00$00'],0,0,5.61536560e+001
				];
		AirManualSP : REAL (RADIX := Float) := 0.00000000e+000;
		AirManualSP_Inp : REAL (RADIX := Float) := 0.00000000e+000;
		AirPercentOut : REAL (RADIX := Float) := 6.69999957e-001;
		AirProgOper : BOOL (RADIX := Decimal) := 1;
		AT701 : P_AInAdv (Description := "DO Transmitter") := [134217987,9.93926849e+001,0,0,2,0.00000000e+000,3.00000000e+002,0.00000000e+000,3.00000000e+002
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,3.00000000e+002
				,0.00000000e+000,2.50000000e+002,0.00000000e+000,9.50000000e+001,0.00000000e+000,9.00000000e+001
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,2.00000000e+001,5.00000000e+000,-2.00000000e+001
				,5.00000000e+000,3.00000000e+002,-1.00000000e+000,4.16666657e-001,9.93926849e+001,9.93926849e+001
				,9.93926849e+001,9.93926849e+001,0.00000000e+000,9.93926849e+001,9.77080612e+001,9.95391693e+001
				,0.00000000e+000,3.00000000e+002,1,1,23,1,4,2359428,[92275667,750,0,5,1,0,0,[2445685,5000,0],[-1609701061
				,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[92275667,500,0,5,1,0
				,0,[2446085,5000,0],[-1609701061,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,1,0,0,[2429685,5000,0],[-1609701061,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,750,0,5,1,0,0,[2429685,5000,0],[-1609701061,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[1,'%$00$00$00$00$00$00$00'],[5,'AT701$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[5,'DO PV$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],1,0,23,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,9.93926849e+001,1.00000000e-001
				,9.93926849e+001,0.00000000e+000,9.77080612e+001,[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[967,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072830149,2147483647,0],0.00000000e+000,1120323854,1120323854,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[0,0,0],[-1609701061,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[0,0,0],[-1609701061,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[2445485,0,0],[-1609701061,0,0],[-1609701061
				,0,0],[17,'PV Deviation High$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061
				,0,0],[2445685,0,0],[-1609701061,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[2446085,0,0],[-1609701061,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[2425285,0,0],[-1609701061
				,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061
				,0,0],[2425485,0,0],[-1609701061,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[1727014,0,0],[-1609701061,0,0],[13,'Input Failure$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[6,'RA-BAS$00$00$00$00$00$00'],[6,'area01$00$00'],4,1,9.93926849e+001];
		AT702 : P_AInAdv (Description := "pH Transmitter") := [-939523837,0.00000000e+000,0,0,2,0.00000000e+000,1.40000000e+001,0.00000000e+000,1.40000000e+001
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,1.00000000e+001
				,0.00000000e+000,8.00000000e+000,0.00000000e+000,6.00000000e+000,0.00000000e+000,4.00000000e+000
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+000,0.00000000e+000,-1.00000000e+000
				,0.00000000e+000,1.50000000e+001,-1.00000000e+000,4.16666657e-001,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,7.90771198e+000
				,0.00000000e+000,1.40000000e+001,1,1,24,7,4,2360836,[76547031,750,0,5,7,0,0,[-1609700261,5000,5000],[-1609700261
				,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[76547031,500,0,5,5,0
				,0,[-1609700261,5000,5000],[-1609700261,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,1,0,0,[3430685,5000,0],[-1609700261,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,750,0,5,1,0,0,[1525491,5000,0],[-1609700261,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[2,'pH$00$00$00$00$00$00'],[5,'AT702$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[5,'pH PV$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],7,0,24,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e-001
				,0.00000000e+000,0.00000000e+000,7.90771198e+000,[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072829349,2147483647,0],0.00000000e+000,0,0,[8,'P_AInAdv$00$00$00$00$00$00$00$00'],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[0,0,0],[-1609700261,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[0,0,0],[-1609700261,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[806479,0,0],[-1609700261,0
				,0],[17,'PV Deviation High$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[806479
				,0,0],[-1609700261,0,0],[-1609700261,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[806479,0,0],[-1609700261,0,0],[-1609700261,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[1525491,0,0],[-1609700261
				,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261
				,0,0],[3429685,0,0],[-1609700261,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[0,0,0],[-1609700261,0,0],[13,'Input Failure$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[6,'RA-BAS$00$00$00$00$00$00'],[6,'area01$00$00'],4,7,0.00000000e+000];
		BOR_1 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
		BOR_2 : FBD_BOOLEAN_OR  := [3,3,5.60519386e-045];
		BOR_3 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
		BOR_4 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
		BOR_5 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
		BRX_Comms_Retry_Stop : BOOL (RADIX := Decimal) := 0;
		BRX_Comm_Toggle : BOOL (RADIX := Decimal) := 0;
		BRX_Data : PBSdata_UDT  := [0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0
				,0.00000000e+000,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,2,0.00000000e+000];
		BRX_DO_SP : REAL (RADIX := Float) := 6.00000000e+001;
		Brx_heartbeat_Alarm : BOOL (RADIX := Decimal) := 0;
		Brx_Heartbeat_Alarm_Reset : BOOL (RADIX := Decimal) := 0;
		BRX_Heartbeat_Fail : TIMER  := [879879,10000,0];
		BRX_HiAdj : BOOL (Description := "BRX HI adj in progress",
		            RADIX := Decimal) := 0;
		BRX_HiAdjEnable : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdjTimer : TIMER  := [3521079,15000,0];
		BRX_HiAdjTimer_Done : BOOL (RADIX := Decimal) := 0;
		BRX_HiadjTimeSP : REAL (RADIX := Float) := 1.50000000e+001;
		BRX_HiAdj_Assess1 : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_Assess2 : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_Buffer : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_Idle : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_OFF : BOOL (RADIX := Decimal) := 1;
		BRX_HiAdj_PumpAdj : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_Repeat : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_Reset : BOOL (RADIX := Decimal) := 0;
		BRX_HiAdj_Stability_Timer : TIMER  := [3515279,10000,0];
		BRX_HiAdj_State : DINT (RADIX := Decimal) := 0;
		BRX_HiHi_Retry_Stop : BOOL (RADIX := Decimal) := 0;
		BRX_HiHi_Stopped : BOOL (RADIX := Decimal) := 0;
		BRX_HiHi_Stop_Timer : TIMER  := [0,500,0];
		BRX_HiSP : REAL (RADIX := Float) := 3.00000000e+000;
		BRX_HLoAdj_OFF : BOOL (RADIX := Decimal) := 0;
		BRX_LevelPID : PID_ENHANCED  := [1,5252112,8.99999976e-001,1.00000000e+002,0.00000000e+000,0.00000000e+000,6.00000000e+000
				,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,5.00000000e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,2.00000000e+000,5.00000000e+000,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,3.40282347e+038,1.00000000e+002,1.00000000e+002,3.40282347e+038
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,16777412,0.00000000e+000,0.00000000e+000,6.00000000e+000
				,6.00000000e+000,8.99999976e-001,-5.09999990e+000,-5.09999990e+000,1.00000000e+000,1.00000000e+000
				,0,0,0,1.50463277e-036,-4.25000012e-001,8.99999976e-001,-5.09999990e+000,-5.09999990e+000
				,8.99999976e-001,8.99999976e-001,2.00000000e+000,8.33333358e-002,0.00000000e+000,1.00000000e+000
				,2.00000000e+000,5.00000000e+000,0.00000000e+000,0.00000000e+000,8.99999976e-001,0.00000000e+000
				,0.00000000e+000,-5.09999990e+000,0.00000000e+000,2.35104363e-038,-5.09999990e+000,8.99999976e-001
				,6.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042
				,7.15415835e-039,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,7.15415835e-039
				,7.89211295e-042,1.00000000e+000];
		BRX_Level_EUMax : REAL (RADIX := Float) := 1.50000000e+000;
		BRX_Level_EUmin : REAL (RADIX := Float) := 5.00000000e-001;
		BRX_Level_HiDev : REAL (RADIX := Float) := 2.79999995e+000;
		BRX_Level_Initialize : BOOL (RADIX := Decimal) := 0;
		BRX_Level_LoDev : REAL (RADIX := Float) := 1.00000000e+000;
		BRX_Level_RawMax : REAL (RADIX := Float) := 1.00000000e+002;
		BRX_Level_RawMin : REAL (RADIX := Float) := 0.00000000e+000;
		BRX_Level_Scaler : SCALE  := [1,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.50000000e+000,5.00000000e-001,1,5.00000000e-001
				,0,0.00000000e+000,1.00000000e+002,9.99999978e-003,5.00000000e-001];
		BRX_LoAdj : BOOL (Description := "BRX Lo Adj in progress",
		            RADIX := Decimal) := 1;
		BRX_LoAdjEnable : BOOL (RADIX := Decimal) := 1;
		BRX_LoAdjTimer : TIMER  := [906475,15000,0];
		BRX_LoAdjTimer_Done : BOOL (RADIX := Decimal) := 0;
		BRX_LoadjTimeSP : REAL (RADIX := Float) := 1.50000000e+001;
		BRX_LoAdj_Assess1 : BOOL (RADIX := Decimal) := 0;
		BRX_LoAdj_Assess2 : BOOL (RADIX := Decimal) := 0;
		BRX_LoAdj_Buffer : BOOL (RADIX := Decimal) := 1;
		BRX_LoAdj_Idle : BOOL (RADIX := Decimal) := 0;
		BRX_LoAdj_PumpAdj : BOOL (RADIX := Decimal) := 0;
		BRX_LoAdj_Repeat : BOOL (RADIX := Decimal) := 0;
		BRX_LoAdj_Reset : BOOL (RADIX := Decimal) := 0;
		BRX_LoAdj_Stability_Timer : TIMER  := [-1072830349,10000,5000];
		BRX_LoAdj_State : DINT (RADIX := Decimal) := 40;
		BRX_LoLo_Retry_Stop : BOOL (RADIX := Decimal) := 0;
		BRX_LoLo_Stopped : BOOL (RADIX := Decimal) := 1;
		BRX_LoLo_Stop_Timer : TIMER  := [1086177,500,0];
		BRX_LoSP : REAL (RADIX := Float) := 1.00000000e+000;
		BRX_Waiting_Comms : BOOL (RADIX := Decimal) := 0;
		BRX_Waiting_Comms_Timer : TIMER  := [816577,500,0];
		C02Scaler : SCALE  := [3,0.00000000e+000,1.00000000e+002,0.00000000e+000,8.33000019e-002,0.00000000e+000,1,0.00000000e+000
				,0,0.00000000e+000,1.00000000e+002,9.99999978e-003,0.00000000e+000];
		C02Scaler1 : SCALE  := [1,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
				,0,5.60519386e-045,0.00000000e+000,0.00000000e+000,0.00000000e+000];
		cal_date : STRING  := [8,'8NOV20233$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		cal_day : STRING  := [1,'80$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		cal_month : STRING  := [3,'NOV$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		cal_year : STRING  := [4,'2023$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		CCAMaxCalc : REAL (RADIX := Float) := 1.00000000e+000;
		CCA_3way : P_D4SD (Description := "TIE IO TO STATUS BITS NOT OUTPUT BITS ON p_d4sd for all 4 of them, otherwise will not hold position through power cycle") := [130947,0,2,15,1,15,2,15,4,15,8,0,1,0,2,0,4,0,8,4194304,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,2.00000000e+000,0.00000000e+000,1.00000000e+001,0,2,2,0,2,0,0,0,0,-1601241088,[0,0,0],[0,0,0],[0,0,0],[0,0,0],0,1,[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20,'Dev Position Failure'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Dev-Reported Fault$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[7651,204113920,66
				,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],0,0,0,3,[13,'KV111 / KV112$00$00$00$00$00$00$00'],[15,'CCA 3-Way Valve$00$00$00$00$00'],[20,'Discrete 2, 3 or 4 S$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'],[6,'Sparge$00$00'],[7,'Overlay$00'
				],1,[4012092,2000,0],[4012092,10000,0],1,[6,'P_D4SD$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],2,0,2,0,[6,'area01$00$00'],0,512,[4011892,0,0],1];
		CO2CVMax : REAL (RADIX := Float) := 1.00000000e+002;
		CO2CVMin : REAL (RADIX := Float) := 0.00000000e+000;
		CO2EUMax : REAL (RADIX := Float) := 8.33000019e-002;
		CO2EUMax_Inp : REAL (RADIX := Float) := 8.32999992e+000;
		CO2EUMin : REAL (RADIX := Float) := 0.00000000e+000;
		CO2EUMin_Inp : REAL (RADIX := Float) := 0.00000000e+000;
		CO2ManualSP : REAL (RADIX := Float) := 5.00000000e-002;
		CO2ManualSP_Inp : REAL (RADIX := Float) := 5.00000000e+000;
		CO2MaxCalc : REAL (RADIX := Float) := 2.50000000e-001;
		CO2PercentOut : REAL (RADIX := Float) := 0.00000000e+000;
		CO2ProgOper : BOOL (RADIX := Decimal) := 0;
		CO2_3way : P_D4SD  := [130947,0,2,15,1,15,2,15,4,15,8,0,1,0,2,0,4,0,8,4194304,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,2.00000000e+000,0.00000000e+000,1.00000000e+001,0,2,2,0,2,0,0,0,0,-1601241088,[0,0,0],[0,0,0],[0,0,0],[0,0,0],0,1,[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20,'Dev Position Failure'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Dev-Reported Fault$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[7651,204113920,66
				,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],0,0,0,3,[13,'KV131 / KV132$00$00$00$00$00$00$00'],[15,'CO2 3-Way Valve$00$00$00$00$00'],[20,'Discrete 2, 3 or 4 S$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'],[6,'Sparge$00$00'],[7,'Overlay$00'
				],1,[1259087,2000,0],[1259087,10000,0],1,[6,'P_D4SD$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],2,0,2,0,[6,'area01$00$00'],0,512,[1258887,0,0],1];
		Comm_Loss_Stop : BOOL (RADIX := Decimal) := 0;
		conditionedMediaONS : BOOL (RADIX := Decimal) := 1;
		conditionedMediaONS2 : BOOL (RADIX := Decimal) := 0;
		conditionedMedia_auto : BOOL (RADIX := Decimal) := 1;
		conditionedMedia_CVEUMax : REAL (RADIX := Float) := 0.00000000e+000;
		conditionedMedia_CVEUMin : REAL (RADIX := Float) := 0.00000000e+000;
		ConditionedMedia_HiDev : REAL (RADIX := Float) := 1.00000000e+002;
		ConditionedMedia_Initialize : BOOL (RADIX := Decimal) := 1;
		ConditionedMedia_LoDev : REAL (RADIX := Float) := 7.00000000e+001;
		ConditionedMedia_NoAdjust_Speed : BOOL (RADIX := Decimal) := 0;
		ConditionedMedia_PID : PID_ENHANCED (Description := "DO rich media addition pump") := [1,5251072,5.61536598e+001,3.00000000e+002,0.00000000e+000,3.00000000e+002,6.00000000e+001
				,0.00000000e+000,3.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,1.92209854e+001,0.00000000e+000,1.91734581e+001
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,5.00000000e+000,2.00000000e+000,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,3.40282347e+038,1.00000000e+002,7.00000000e+001,3.40282347e+038
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,16777280,1.92209854e+001,1.92209854e+001,6.00000000e+001
				,2.00000000e+001,1.87178860e+001,3.84634018e+000,1.28211400e+000,1.00000000e+000,1.00000000e+000
				,0,0,0,0.00000000e+000,1.92209854e+001,-1.87178860e+001,1.28211400e+000,1.28115273e+000,-1.87178860e+001
				,-1.87188473e+001,5.00000000e+000,3.33333351e-002,0.00000000e+000,1.00000000e+000,5.00000000e+000
				,2.00000000e+000,0.00000000e+000,0.00000000e+000,5.61536598e+001,0.00000000e+000,1.92209854e+001
				,3.84634018e+000,0.00000000e+000,2.35100664e-038,3.84634018e+000,1.87178860e+001,2.00000000e+001
				,1.92209854e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042,7.15555965e-039
				,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,7.15555965e-039,7.89211295e-042
				,1.00000000e+000];
		ConditionedMedia_Running : BOOL (RADIX := Decimal) := 1;
		ConditionedMedia_Scaler : SCALE  := [1,1.91734581e+001,1.00000000e+002,0.00000000e+000,1.93500000e+002,0.00000000e+000,1,3.71006393e+001
				,0,0.00000000e+000,1.00000000e+002,9.99999978e-003,3.71006393e+001];
		ConditionedMedia_Scaler1 : SCALE  := [1,0.00000000e+000,1.00000000e+002,0.00000000e+000,6.00000000e+001,0.00000000e+000,1,0.00000000e+000
				,0,0.00000000e+000,1.00000000e+002,9.99999978e-003,0.00000000e+000];
		ConditionedMedia_Scaler2 : SCALE  := [1,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
				,0,5.60519386e-045,0.00000000e+000,0.00000000e+000,0.00000000e+000];
		CondMedEUMax : REAL (RADIX := Float) := 0.00000000e+000;
		CondMedEUMin : REAL (RADIX := Float) := 0.00000000e+000;
		CondMedRawMax : REAL (RADIX := Float) := 1.00000000e+002;
		CondMedRawMin : REAL (RADIX := Float) := 0.00000000e+000;
		CondMed_AdjustInProgress : BOOL (RADIX := Decimal) := 1;
		Datalog_Trigger : BOOL (Description := "Toggles Datalogging",
		            RADIX := Binary) := 1;
		DOpbs : PID_ENHANCED  := [1,1056776,9.95263214e+001,1.00000000e+002,0.00000000e+000,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,1.00000000e+000,5.00000000e+000,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,3.40282347e+038,0.00000000e+000,0.00000000e+000,3.40282347e+038
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,17825857,0.00000000e+000,0.00000000e+000,1.00000000e+002
				,1.00000000e+002,9.93926849e+001,6.07315063e-001,6.07315063e-001,1.00000000e+000,1.00000000e+000
				,0,0,0,0.00000000e+000,-1.66666734e+000,-9.93926849e+001,6.07315063e-001,6.07315063e-001,-9.93926849e+001
				,-9.93926849e+001,1.00000000e+000,8.33333358e-002,0.00000000e+000,1.00000000e+000,1.00000000e+000
				,5.00000000e+000,0.00000000e+000,0.00000000e+000,9.93926849e+001,0.00000000e+000,0.00000000e+000
				,6.07315063e-001,0.00000000e+000,2.64488051e-038,6.07315063e-001,9.93926849e+001,1.00000000e+002
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042,7.15555965e-039
				,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,7.15555965e-039,7.89211295e-042
				,1.00000000e+000];
		DOPID_INITIALIZE : BOOL (RADIX := Decimal) := 1;
		DOtestPV : REAL (RADIX := Float) := 2.50000000e+001;
		do_cal_b_0_idle : BOOL (RADIX := Decimal) := 1;
		do_cal_b_100_start_pt2 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_100_start_pt2_Timer : TIMER  := [0,5000,0];
		do_cal_b_105_method_set_loop : BOOL (RADIX := Decimal) := 0;
		do_cal_b_105_method_set_loop_Timer : TIMER  := [0,5000,0];
		do_cal_b_10_set_user2 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_110_place_probe_pt2 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_120_wait_for_stability_pt2 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_130_write_pt2 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_130_write_pt2_Timer : TIMER  := [0,1000,0];
		do_cal_b_140_wait_for_done : BOOL (RADIX := Decimal) := 0;
		do_cal_b_150_place_probe_process : BOOL (RADIX := Decimal) := 0;
		do_cal_b_160_wait_for_stability_process : BOOL (RADIX := Decimal) := 0;
		do_cal_b_170_write_process : BOOL (RADIX := Decimal) := 0;
		do_cal_b_170_write_process_Timer : TIMER  := [0,1000,0];
		do_cal_b_180_wait_for_done_process : BOOL (RADIX := Decimal) := 0;
		do_cal_b_190_done_ok : BOOL (RADIX := Decimal) := 0;
		do_cal_b_200_done_error : BOOL (RADIX := Decimal) := 0;
		do_cal_b_20_set_user2_ack : BOOL (RADIX := Decimal) := 0;
		do_cal_b_210_pwd_error : BOOL (RADIX := Decimal) := 0;
		do_cal_b_30_set_pt1_params : BOOL (RADIX := Decimal) := 0;
		do_cal_b_30_set_pt1_params_Timer : TIMER  := [0,0,0];
		do_cal_b_40_check_params : BOOL (RADIX := Decimal) := 0;
		do_cal_b_40_check_params_Timer : TIMER  := [0,0,0];
		do_cal_b_50_cal_method : BOOL (RADIX := Decimal) := 0;
		do_cal_b_60_place_probe : BOOL (RADIX := Decimal) := 0;
		do_cal_b_70_wait_for_stability_pt1 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_80_write_pt1 : BOOL (RADIX := Decimal) := 0;
		do_cal_b_80_write_pt1_Timer : TIMER  := [0,1000,0];
		do_cal_b_90_wait_pt1_write : BOOL (RADIX := Decimal) := 0;
		do_cal_done_date : STRING  := [0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		do_cal_reset : BOOL (RADIX := Decimal) := 0;
		do_cal_start : BOOL (RADIX := Decimal) := 0;
		do_cal_state_var : DINT (RADIX := Decimal) := 0;
		DO_CVEUMax : REAL (RADIX := Float) := 1.00000000e+002;
		DO_CVEUMin : REAL (RADIX := Float) := 0.00000000e+000;
		DO_HiDev : REAL (Description := "hi deviation alarm$N",
		            RADIX := Float) := 0.00000000e+000;
		DO_LoDev : REAL (Description := "low deviation alarm$N",
		            RADIX := Float) := 0.00000000e+000;
		DO_Normalized : REAL (RADIX := Float) := 9.93926849e+001;
		DO_ON : BOOL (RADIX := Decimal) := 1;
		DO_PID_AUTOREQ : BOOL (RADIX := Decimal) := 1;
		do_probe_placement_ready : BOOL (RADIX := Decimal) := 0;
		do_r_cal_control : DINT (RADIX := Decimal) := 0;
		do_r_cal_date : DINT (RADIX := Decimal) := 403251235;
		do_r_cal_method : DINT (RADIX := Decimal) := 1;
		do_r_cal_offset : REAL (RADIX := Float) := 0.00000000e+000;
		do_r_cal_process : REAL (RADIX := Float) := 0.00000000e+000;
		do_r_cal_slope : REAL (RADIX := Float) := 0.00000000e+000;
		do_r_cal_status : DINT (RADIX := Decimal) := 536871937;
		do_r_cal_time : DINT (RADIX := Decimal) := 4130;
		do_r_do : REAL (RADIX := Float) := 9.95263214e+001;
		do_r_sensor_disconnected : DINT (RADIX := Decimal) := 0;
		do_r_sensor_type : DINT (RADIX := Decimal) := 512;
		do_r_unit : DINT (RADIX := Decimal) := 256;
		do_r_user_level : DINT (RADIX := Decimal) := 3;
		do_r_user_password : DINT (RADIX := Decimal) := 0;
		do_r_wrong_sensor : DINT (RADIX := Decimal) := 0;
		DO_Scale : SCALE  := [1,1.08560000e+004,3.27670000e+004,0.00000000e+000,3.00000000e+002,0.00000000e+000,1,9.93926849e+001
				,0,0.00000000e+000,3.27670000e+004,3.05185094e-005,9.93926849e+001];
		DO_Scale1 : SCALE  := [1,2.67200000e+003,3.27670000e+004,0.00000000e+000,3.00000000e+002,0.00000000e+000,1,2.44636364e+001
				,0,0.00000000e+000,3.27670000e+004,3.05185094e-005,2.44636364e+001];
		do_stability_ok : BOOL (RADIX := Decimal) := 0;
		do_w_cal_buffer_tab : DINT (RADIX := Decimal) := 1;
		do_w_cal_control : DINT (RADIX := Decimal) := 0;
		do_w_cal_date : DINT (RADIX := Decimal) := 0;
		do_w_cal_humidity : DINT (RADIX := Decimal) := 0;
		do_w_cal_method : DINT (RADIX := Decimal) := 32;
		do_w_cal_offset : REAL (RADIX := Float) := 0.00000000e+000;
		do_w_cal_offset_input : REAL (RADIX := Float) := 0.00000000e+000;
		do_w_cal_pressure : DINT (RADIX := Decimal) := 0;
		do_w_cal_process : REAL (RADIX := Float) := 0.00000000e+000;
		do_w_cal_process_input : DINT (RADIX := Decimal) := 0;
		do_w_cal_slope : REAL (RADIX := Float) := 0.00000000e+000;
		do_w_cal_slope_input : REAL (RADIX := Float) := 0.00000000e+000;
		do_w_cal_stability : DINT (RADIX := Decimal) := 1;
		do_w_cal_status : DINT (RADIX := Decimal) := 0;
		do_w_cal_time : DINT (RADIX := Decimal) := 0;
		do_w_cal_unit_cal : DINT (RADIX := Decimal) := 0;
		do_w_sensor_type : DINT (RADIX := Decimal) := 0;
		do_w_user_level : DINT (RADIX := Decimal) := 12;
		do_w_user_password : DINT (RADIX := Decimal) := 18111978;
		Enable_Toggle : BOOL (RADIX := Decimal) := 1;
		EStop : P_DIn  := [1128428823,0,0.00000000e+000,1,18,7,0,1,1,[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Discrete Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[92275667,750,0,5,1,0,0,[1637399,5000,0
				],[-1609700361,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Target Disagree$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[1637399,0,0],[-1609700361
				,0,0],[2,'On$00$00$00$00$00$00'],[3,'Off$00$00$00$00$00'],0,0,7,18,[5,'P_DIn$00$00$00$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700361,0,0],[1637399,0,0],[-1609700361,0
				,0],[15,'Target Disagree$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],1,1,[6,'area01$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],1,[963
				,1000,480,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15
				,'Alarm Condition$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],5];
		Estop_Active_Flag : BOOL (RADIX := Decimal) := 0;
		Estop_Reset_Timer : TIMER  := [0,5000,0];
		Estop_Restart : BOOL (RADIX := Decimal) := 0;
		Estop_Restart_Delay : TIMER  := [-1609701261,5000,5000];
		FIC110 : P_ValveC (Description := "PBS CCA") := [1084297315,0.00000000e+000,0.00000000e+000,2,0.00000000e+000,2.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.00000000e+000,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,1.00000000e+001,1.00000000e+000,1.00000000e+000,1.00000000e+001
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,8.99999961e-003,0.00000000e+000,0,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.00000000e+000
				,2,2,1,0,0,0,0,0,128,[56803,-1976917504,34,128,994,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0
				,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[963
				,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[8
				,'P_ValveC$00$00$00$00$00$00$00$00$00$00$00$00'],[7,'CCA MFC$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'FIC110$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0,[4,'SLPM$00$00$00$00'],0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e-001,0.00000000e+000
				,[-1072829650,2147483647,0],0,0,0,2,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Actuator Fault$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],0,[-1072829650,2147483647,0],1114116,0.00000000e+000,10000,0,0.00000000e+000,0.00000000e+000
				,[8,'P_ValveC$00$00$00$00$00$00$00$00'],0.00000000e+000,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'area01$00$00'],0.00000000e+000,0,0,[655052,0,0]];
		FIC110_Alm_HiDev : BOOL (Description := "HI MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC110_Alm_LoDev : BOOL (Description := "LO MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC110_Dev_Timer : TIMER (Description := "Timer for Deviation Presence before Alarm") := [2138284,5000,0];
		FIC110_HiDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC110_HiDev_Limit : REAL (RADIX := Float) := 5.00000000e-002;
		FIC110_intlk : P_Intlk  := [6531,0,0,1,0,0,1,[[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,1,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]];
		FIC110_LoDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC110_LoDev_Limit : REAL (RADIX := Float) := -5.00000000e-002;
		FIC120 : P_ValveC (Description := "O2 pbs") := [1084297315,0.00000000e+000,0.00000000e+000,2,0.00000000e+000,2.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.00000000e+000,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,1.00000000e+001,2.00000000e-001,2.00000000e-001,1.00000000e+001
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,8.99999961e-003,0.00000000e+000,0,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.00000000e+000
				,2,2,1,0,0,0,0,0,128,[56803,-1976917504,34,128,994,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0
				,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[963
				,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[8
				,'P_ValveC$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'O2 MFC$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'FIC120$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0,[4,'SLPM$00$00$00$00'],0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e-001,0.00000000e+000
				,[-1072829450,2147483647,0],0,0,0,2,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Actuator Fault$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],0,[-1072829450,2147483647,0],9502724,0.00000000e+000,10000,0,0.00000000e+000,0.00000000e+000
				,[8,'P_ValveC$00$00$00$00$00$00$00$00'],0.00000000e+000,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'area01$00$00'],0.00000000e+000,0,0,[3787156,0,0]];
		FIC120_Alm_HiDev : BOOL (Description := "HI MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC120_Alm_LoDev : BOOL (Description := "LO MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC120_Dev_Timer : TIMER  := [1608887,5000,0];
		FIC120_HiDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC120_HiDev_Limit : REAL (RADIX := Float) := 5.00000000e-002;
		FIC120_intlk : P_Intlk  := [6531,0,0,0,0,0,1,[[20,'Enter Description #0'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,1,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[20,'Enter Description #0']];
		FIC120_LoDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC120_LoDev_Limit : REAL (RADIX := Float) := -5.00000000e-002;
		FIC130 : P_ValveC (Description := "CO2 pbs") := [1084297315,0.00000000e+000,0.00000000e+000,2,0.00000000e+000,5.00000000e-001,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.00000000e-001,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,1.00000000e+001,2.00000000e-001,2.00000000e-001,1.00000000e+001
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,8.99999961e-003,0.00000000e+000,0,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.00000000e-001
				,2,2,1,0,0,0,0,0,128,[56803,-1976917504,34,128,994,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0
				,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[963
				,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[8
				,'P_ValveC$00$00$00$00$00$00$00$00$00$00$00$00'],[7,'CO2 MFC$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'FIC130$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0,[4,'SLPM$00$00$00$00'],0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e-001,0.00000000e+000
				,[-1072829050,2147483647,0],0,0,0,2,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Actuator Fault$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],0,[-1072829050,2147483647,0],1114116,0.00000000e+000,10000,0,0.00000000e+000,0.00000000e+000
				,[8,'P_ValveC$00$00$00$00$00$00$00$00'],0.00000000e+000,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'area01$00$00'],0.00000000e+000,0,0,[1835756,0,0]];
		FIC130_Alm_HiDev : BOOL (Description := "HI MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC130_Alm_LoDev : BOOL (Description := "LO MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC130_Dev_Timer : TIMER  := [1684487,5000,0];
		FIC130_HiDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC130_HiDev_Limit : REAL (RADIX := Float) := 5.00000000e-002;
		FIC130_intlk : P_Intlk  := [6531,0,0,0,0,0,1,[[20,'Enter Description #0'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,1,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[20,'Enter Description #0']];
		FIC130_LoDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC130_LoDev_Limit : REAL (RADIX := Float) := -5.00000000e-002;
		FIC140 : P_ValveC (Description := "pbs N2 mfc") := [1084297315,0.00000000e+000,0.00000000e+000,2,0.00000000e+000,2.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.00000000e+000,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,1.00000000e+001,1.00000000e+000,1.00000000e+000,1.00000000e+001
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,8.99999961e-003,0.00000000e+000,0,6.89999998e-001
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.00000000e+000
				,2,2,1,0,0,0,0,0,128,[56803,-1976917504,34,128,994,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0
				,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[963
				,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[8
				,'P_ValveC$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'N2 MFC$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'FIC140$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0,[4,'SLPM$00$00$00$00'],0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e-001,0.00000000e+000
				,[-1072829050,2147483647,0],0,0,0,2,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Actuator Fault$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],0,[-1072829050,2147483647,0],1114116,0.00000000e+000,10000,0,0.00000000e+000,0.00000000e+000
				,[8,'P_ValveC$00$00$00$00$00$00$00$00'],0.00000000e+000,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'area01$00$00'],0.00000000e+000,0,0,[1835756,0,0]];
		FIC140_Alm_HiDev : BOOL (Description := "HI MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC140_Alm_LoDev : BOOL (Description := "LO MFC Deviation Alarm",
		            RADIX := Decimal) := 0;
		FIC140_Dev_Timer : TIMER  := [2137084,5000,0];
		FIC140_HiDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC140_HiDev_Limit : REAL (RADIX := Float) := 5.00000000e-002;
		FIC140_intlk : P_Intlk  := [6531,0,0,0,0,0,1,[[20,'Enter Description #0'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,1,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[20,'Enter Description #0']];
		FIC140_LoDev : REAL (RADIX := Float) := 5.00000000e-002;
		FIC140_LoDev_Limit : REAL (RADIX := Float) := -5.00000000e-002;
		file_test : STRING  := [1,' $00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		GasControl_ON : BOOL (RADIX := Decimal) := 0;
		GasOffOns : BOOL (RADIX := Decimal) := 1;
		GasOnOns : BOOL (RADIX := Decimal) := 0;
		HCR01_Normalized : REAL (Description := "Scaled Heater Output",
		            RADIX := Float) := 0.00000000e+000;
		HCR01_Scale : SCALE  := [1,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+004,0.00000000e+000,1,0.00000000e+000
				,0,0.00000000e+000,1.00000000e+002,9.99999978e-003,0.00000000e+000];
		Heater_Output : P_AOut (Description := "Heating blanket AO") := [335614987,0.00000000e+000,0.00000000e+000,2,0.00000000e+000,5.00000000e+001,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.00000000e+001,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,5.00000000e+001,0,20,0,0,0,0,0,71168,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'
				],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[17
				,'Interlock Tripped$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[13,'Heater Output$00$00$00$00$00$00$00'],[13,'Vessel Heater$00$00$00$00$00$00$00'],[13,'Analog Output$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0,[1,'%$00$00$00$00$00$00$00'],0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e-001
				,0.00000000e+000,[-1072829449,2147483647,0],0,0,0,0,0,20,[6,'P_AOut$00$00$00$00$00$00$00$00$00$00'
				],0.00000000e+000,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'area01$00$00'],0,0.00000000e+000];
		Heater_Output_intlk : P_Intlk  := [14339,0,0,0,0,1,1,[[16,'Agitator Stopped$00$00$00$00'],[16,'Vessel Temp HiHi$00$00$00$00'],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']],1,1,1,1,1,1,0,1,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'
				],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00']],[6,'RA-BAS$00$00$00$00$00$00'
				],0,[6,'area01$00$00'],[16,'Agitator Stopped$00$00$00$00']];
		Json_Alarm : BOOL (RADIX := Decimal) := 0;
		JSON_Fail_Timer : TIMER  := [1015479,10000,0];
		KV111 : P_ValveSO (Description := "CCA Overlay Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV111$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'CCA Overlay$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609700762,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[3286481,0,0]];
		KV112 : P_ValveSO (Description := "CCA Sparge Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV112$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'CCA Sparge$00$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609700563,2000,2000],0,5141,[808377,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[0,0,0]];
		KV121 : P_ValveSO (Description := "O2 Overlay Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV121$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'O2 Overlay$00$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609699962,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[2734589,0,0]];
		KV122 : P_ValveSO (Description := "O2 Sparge Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV122$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'O2 Sparge$00$00$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609699862,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[2986502,0,0]];
		KV131 : P_ValveSO (Description := "CO2 Overlay Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV131$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'CO2 Overlay$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609699862,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[0,0,0]];
		KV132 : P_ValveSO (Description := "CO2 Sparge Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV132$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'CO2 Sparge$00$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609700862,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[0,0,0]];
		KV141 : P_ValveSO (Description := "N2 Overlay Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV141$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'N2 Overlay$00$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609700762,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[0,0,0]];
		KV142 : P_ValveSO (Description := "N2 Sparge Valve") := [470024435,0,2.00000000e+000,5.00000000e+000,1.00000000e+001,0.00000000e+000,0,32,2,2,0,1,1,0,0,0
				,0,[7651,204113920,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000
				,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,500,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19,'Valve Transit Stall$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[451,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Valve Full Stall$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[5,'KV142$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'N2 Sparge$00$00$00$00$00$00$00$00$00$00$00'],[23,'Solenoid Operated Valve$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,2000,0],[-1609700362,2000,2000],0,5141,[808378,10000,0],[0,5000,0],0,0,1,0,[9,'P_ValveSO$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],2,0,[6,'area01$00$00'],0,[0,0,0]];
		Level_Control_Enable : BOOL (RADIX := Decimal) := 0;
		Level_Deadband_High_SP : REAL (RADIX := Float) := 2.59999990e+000;
		Level_Deadband_Low_SP : REAL (RADIX := Float) := 1.00000000e+000;
		LIT801 : P_AInAdv (Description := "Level Value From BRX") := [134512643,1.86770105e+000,0,0,2,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,1.40000000e+001
				,0.00000000e+000,1.00000000e+001,0.00000000e+000,2.00000000e+000,0.00000000e+000,5.00000000e-001
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.50000000e+000,5.00000000e-001,-1.50000000e+000
				,5.00000000e-001,2.00000000e+001,-1.00000000e+000,4.16666657e-001,8.99999976e-001,1.86770105e+000
				,8.99999976e-001,1.86770105e+000,0.00000000e+000,0.00000000e+000,8.99999976e-001,3.06050634e+000
				,0.00000000e+000,1.00000000e+002,1,18,20,5,1,1311750,[92275603,750,0,5,0,0,0,[3948879,5000,0],[3928279,5000
				,0],[0,0,0],0,2338,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[76547031,500,0,5,5,0
				,0,[-1609700961,5000,5000],[-1609700961,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,0,0,0,[2239634,5000,0],[1060479,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[92275667,750,0,5,0,0,0,[2229834,5000,0],[1060479,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[1,'L$00$00$00$00$00$00$00'],[6,'LIT801$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[12,'BRX Level PV$00$00$00$00$00$00$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],5,0,20,18,0.00000000e+000,0.00000000e+000,0.00000000e+000,8.99999976e-001,1.00000000e-001
				,8.99999976e-001,0.00000000e+000,3.06050634e+000,[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072830049,2147483647,0],0.00000000e+000,1072632020,1063675494,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700961,0,0],[0,0,0],[-1609700961,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700961,0,0],[0,0,0],[-1609700961,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700961,0,0],[0,0,0],[-1609700961,0,0],[17,'PV Deviation High$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700961,0,0],[3948879,0,0],[-1609700961
				,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[3923079
				,0,0],[-1609700961,0,0],[-1609700961,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700961,0,0],[2229834,0,0],[-1609700961,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700961,0,0],[2239634,0,0],[-1609700961
				,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700961
				,0,0],[0,0,0],[-1609700961,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'area01$00$00'],1,5,1.86770105e+000];
		LocalDateTimeRef : DateTime  := [2023,11,8,14,26,45,124010];
		LocalDateTimeString : STRING  := [19,'8 NOV 2023 14:26:45916:12:4718$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		LocalDateTimeTtoS : T_TtoS  := [75,[[3,'JAN$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'FEB$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[3,'MAR$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'APR$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[3,'MAY$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'JUN$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[3,'JUL$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'AUG$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[3,'SEP$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'OCT$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[3,'NOV$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[3,'DEC$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[[6,'Sunday$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'Monday$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[7,'Tuesday$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'Wednesday$00$00$00$00$00$00$00$00$00$00$00'
				],[8,'Thursday$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'Friday$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[8,'Saturday$00$00$00$00$00$00$00$00$00$00$00$00']],[3,3,2023,8,[7,8,2023,739137,2023,252,8,2023,11,8
				],739140],[2,'AM$00$00$00$00$00$00'],[2,'PM$00$00$00$00$00$00'],[15,'<Invalid Date!>$00$00$00$00$00'
				],[15,'<Invalid Time!>$00$00$00$00$00'],[11,'8 NOV 2023 $00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[8,'14:26:45$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[1,' $00$00$00$00$00$00$00'],[1,':$00$00$00$00$00$00$00'],[2,', $00$00$00$00$00$00'],[1,'-$00$00$00$00$00$00$00'
				],[1,'5$00$00$00$00$00$00$00'],[4,'2023$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[1
				,'.$00$00$00$00$00$00$00'],0];
		ManualDO_CV : REAL (RADIX := Float) := 5.00000000e+001;
		ManualpH_CV : REAL (RADIX := Float) := 0.00000000e+000;
		MCV_FillWeight : REAL (RADIX := Float) := 1.50000000e+001;
		MCV_HiAdj : BOOL (Description := "MCV hi adjust active$N",
		            RADIX := Decimal) := 0;
		MCV_HiAdjEnable : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdjTimer : TIMER  := [2736434,20000,0];
		MCV_HiAdjTimer_Done : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdjTimeSP : REAL (RADIX := Float) := 2.00000000e+001;
		MCV_HiAdj_Assess1 : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_Assess2 : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_Buffer : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_Idle : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_OFF : BOOL (RADIX := Decimal) := 1;
		MCV_HiAdj_PumpAdj : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_Repeat : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_Reset : BOOL (RADIX := Decimal) := 0;
		MCV_HiAdj_Stability_Timer : TIMER  := [2734634,10000,0];
		MCV_HiAdj_State : DINT (RADIX := Decimal) := 0;
		MCV_HiSP : REAL (RADIX := Float) := 1.50000000e+001;
		MCV_InitialFill : BOOL (RADIX := Decimal) := 0;
		MCV_InitialFillRunning : BOOL (RADIX := Decimal) := 0;
		MCV_InitialFillSpeed : REAL (RADIX := Float) := 1.00000000e+002;
		MCV_InitialFill_Done : BOOL (RADIX := Decimal) := 0;
		MCV_InitialFill_Finished : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdjTimer : TIMER  := [2030499,10000,0];
		MCV_LoAdjTimer_Done : BOOL (RADIX := Decimal) := 1;
		MCV_LoAdj_Assess1 : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Assess2 : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Buffer : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Enable : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Idle : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_OFF : BOOL (RADIX := Decimal) := 1;
		MCV_LoAdj_PumpAdj : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Repeat : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Reset : BOOL (RADIX := Decimal) := 0;
		MCV_LoAdj_Stability_Timer : TIMER  := [1980899,10000,0];
		MCV_LoAdj_State : DINT (RADIX := Decimal) := 0;
		MCV_LoSP : REAL (RADIX := Float) := 1.60000000e+001;
		MCV_LoTimerSP : REAL (RADIX := Float) := 1.00000000e+001;
		MediaAdj_InProgress : BOOL (RADIX := Decimal) := 0;
		MediaFilll_Off_Flag : BOOL (RADIX := Decimal) := 0;
		MediaFill_Alm_HiDev : BOOL (Description := "MEDIA FILL HI DEVIATION ALARM",
		            RADIX := Decimal) := 0;
		MediaFill_Alm_LoDev : BOOL (Description := "MEDIA FILL LO DEVIATION ALARM",
		            RADIX := Decimal) := 0;
		MediaFill_Dev_Timer : TIMER  := [2030499,5000,0];
		MediaFill_HiDev : REAL (RADIX := Float) := 2.00000000e+000;
		MediaFill_HiDev_Limit : REAL (RADIX := Float) := 1.80000000e+001;
		MediaFill_LoDev : REAL (RADIX := Float) := 2.00000000e+000;
		MediaFill_LoDev_Limit : REAL (RADIX := Float) := 1.40000000e+001;
		MediaFill_Off : BOOL (RADIX := Decimal) := 0;
		MediaFill_ON : BOOL (RADIX := Decimal) := 0;
		MediaLoSpeed : REAL (RADIX := Float) := 5.00000000e+001;
		Media_LoLo_Retry_Stop : BOOL (RADIX := Decimal) := 0;
		Media_LoLo_Stopped : BOOL (RADIX := Decimal) := 0;
		Media_LoLo_Stop_Timer : TIMER  := [0,500,0];
		mfc_0_AIR_r_data_ok : BOOL (RADIX := Decimal) := 1;
		mfc_0_AIR_r_id : DINT (Description := "a two digit hex id for each mfc, valid values are 0 - 100 hex",
		            RADIX := Decimal) := 29;
		mfc_0_AIR_r_mdot_pv : REAL (Description := "mass flow pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_0_AIR_r_type : DINT (Description := "a enumeration indicating the mfc type (what gas), types: N2, CO2, AIR, O2",
		            RADIX := Decimal) := 0;
		mfc_0_AIR_r_valve_pv : REAL (Description := "valve position pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 1.75000000e+001;
		mfc_0_AIR_w_cmd_mode : DINT (Description := "an enumeration for valve control: $N0 - cmd valve closed, $N1 - cmd valve open,$N2 - cmd valve in sp mode w/ mfc_0_w_mdot_sp as the sp",
		            RADIX := Decimal) := 0;
		mfc_0_AIR_w_mdot_sp : REAL (Description := "mass flow sp as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_1_O2_r_data_ok : BOOL (RADIX := Decimal) := 1;
		mfc_1_O2_r_id : DINT (Description := "a two digit hex id for each mfc, valid values are 0 - 100 hex",
		            RADIX := Decimal) := 2;
		mfc_1_O2_r_mdot_pv : REAL (Description := "mass flow pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_1_O2_r_type : DINT (Description := "a enumeration indicating the mfc type (what gas), types: N2, CO2, AIR, O2",
		            RADIX := Decimal) := 1;
		mfc_1_O2_r_valve_pv : REAL (Description := "valve position pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 1.03800000e+001;
		mfc_1_O2_w_cmd_mode : DINT (Description := "an enumeration for valve control: 0 - cmd valve closed, 1 - cmd valve open, 2 - cmd valve in sp mode w/ mfc_0_w_mdot_sp as the sp",
		            RADIX := Decimal) := 0;
		mfc_1_O2_w_mdot_sp : REAL (Description := "mass flow sp as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_2_CO2_r_data_ok : BOOL (RADIX := Decimal) := 1;
		mfc_2_CO2_r_id : DINT (Description := "a two digit hex id for each mfc, valid values are 0 - 100 hex",
		            RADIX := Decimal) := 2;
		mfc_2_CO2_r_mdot_pv : REAL (Description := "mass flow pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_2_CO2_r_type : DINT (Description := "a enumeration indicating the mfc type (what gas), types: N2, CO2, AIR, O2",
		            RADIX := Decimal) := 0;
		mfc_2_CO2_r_valve_pv : REAL (Description := "valve position pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 1.41300000e+001;
		mfc_2_CO2_w_cmd_mode : DINT (Description := "an enumeration for valve control: 0 - cmd valve closed, 1 - cmd valve open, 2 - cmd valve in sp mode w/ mfc_0_w_mdot_sp as the sp",
		            RADIX := Decimal) := 0;
		mfc_2_CO2_w_mdot_sp : REAL (Description := "mass flow sp as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_3_N2_r_data_ok : BOOL (RADIX := Decimal) := 1;
		mfc_3_N2_r_id : DINT (Description := "a two digit hex id for each mfc, valid values are 0 - 100 hex",
		            RADIX := Decimal) := 2;
		mfc_3_N2_r_mdot_pv : REAL (Description := "mass flow pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		mfc_3_N2_r_type : DINT (Description := "a enumeration indicating the mfc type (what gas), types: N2, CO2, AIR, O2",
		            RADIX := Decimal) := 0;
		mfc_3_N2_r_valve_pv : REAL (Description := "valve position pv as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 2.10000000e+001;
		mfc_3_N2_w_cmd_mode : DINT (Description := "an enumeration for valve control: 0 - cmd valve closed, 1 - cmd valve open, 2 - cmd valve in sp mode w/ mfc_0_w_mdot_sp as the sp",
		            RADIX := Decimal) := 0;
		mfc_3_N2_w_mdot_sp : REAL (Description := "mass flow sp as a % of full range: 0 - 100 in 0.01 increments",
		            RADIX := Float) := 0.00000000e+000;
		MMV_HiHi_Retry_Stop : BOOL (RADIX := Decimal) := 0;
		MMV_HiHi_Stopped : BOOL (RADIX := Decimal) := 0;
		MMV_HiHi_Stop_Timer : TIMER  := [0,500,0];
		MMV_LoLo_Retry_Stop : BOOL (RADIX := Decimal) := 0;
		MMV_LoLo_Stopped : BOOL (RADIX := Decimal) := 0;
		MMV_LoLo_Stop_Timer : TIMER  := [0,500,0];
		MT_0_R_DATA_OK : BOOL (RADIX := Decimal) := 1;
		MT_0_R_DATA_STABLE : BOOL (RADIX := Decimal) := 1;
		MT_0_R_PV : REAL (RADIX := Float) := 6.33500000e+000;
		MT_0_R_RESET_ACK : BOOL (RADIX := Decimal) := 1;
		MT_0_R_TARE_ACK : BOOL (RADIX := Decimal) := 1;
		MT_0_R_UNIT : DINT (RADIX := Decimal) := 0;
		MT_0_R_ZERO_ACK : BOOL (RADIX := Decimal) := 0;
		MT_0_W_RESET : BOOL (RADIX := Decimal) := 0;
		MT_0_W_SER_PORT : DINT (RADIX := Decimal) := 0;
		MT_0_W_TARE : BOOL (RADIX := Decimal) := 0;
		MT_0_W_ZERO : BOOL (RADIX := Decimal) := 0;
		MT_1_R_DATA_OK : BOOL (RADIX := Decimal) := 1;
		MT_1_R_DATA_STABLE : BOOL (RADIX := Decimal) := 1;
		MT_1_R_PV : REAL (RADIX := Float) := 1.07000005e+000;
		MT_1_R_RESET_ACK : BOOL (RADIX := Decimal) := 0;
		MT_1_R_TARE_ACK : BOOL (RADIX := Decimal) := 1;
		MT_1_R_UNIT : DINT (RADIX := Decimal) := 0;
		MT_1_R_ZERO_ACK : BOOL (RADIX := Decimal) := 0;
		MT_1_W_RESET : BOOL (RADIX := Decimal) := 0;
		MT_1_W_SER_PORT : DINT (RADIX := Decimal) := 0;
		MT_1_W_TARE : BOOL (RADIX := Decimal) := 0;
		MT_1_W_ZERO : BOOL (RADIX := Decimal) := 0;
		N2CVMax : REAL (RADIX := Float) := -5.00000000e+000;
		N2CVMin : REAL (RADIX := Float) := -1.00000000e+002;
		N2EUMax : REAL (RADIX := Float) := 3.30000013e-001;
		N2EUMax_Inp : REAL (RADIX := Float) := 3.30000000e+001;
		N2EUMin : REAL (RADIX := Float) := 0.00000000e+000;
		N2EUMin_Inp : REAL (RADIX := Float) := 0.00000000e+000;
		N2ManualSP : REAL (RADIX := Float) := 0.00000000e+000;
		N2ManualSP_Inp : REAL (RADIX := Float) := 0.00000000e+000;
		N2MaxCalc : REAL (RADIX := Float) := 1.00000000e+000;
		N2PercentOut : REAL (RADIX := Float) := 3.30000013e-001;
		N2ProgOper : BOOL (RADIX := Decimal) := 0;
		N2Scaler : SCALE  := [3,0.00000000e+000,-5.00000000e+000,-1.00000000e+002,3.30000013e-001,0.00000000e+000,3,3.30000013e-001
				,0,0.00000000e+000,9.50000000e+001,1.05263162e-002,3.30000013e-001];
		N2_3way : P_D4SD  := [130947,0,2,15,1,15,2,15,4,15,8,0,1,0,2,0,4,0,8,4194304,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,2.00000000e+000,0.00000000e+000,1.00000000e+001,0,2,2,0,2,0,0,0,0,-1601241088,[0,0,0],[0,0,0],[0,0,0],[0,0,0],0,1,[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20,'Dev Position Failure'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Dev-Reported Fault$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[7651,204113920,66
				,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],0,0,0,3,[13,'KV141 / KV142$00$00$00$00$00$00$00'],[14,'N2 3-Way Valve$00$00$00$00$00$00'],[20
				,'Discrete 2, 3 or 4 S$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'],[6,'Sparge$00$00'],[7,'Overlay$00'
				],1,[1315287,2000,0],[1315287,10000,0],1,[6,'P_D4SD$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],2,0,2,0,[6,'area01$00$00'],0,512,[1315087,0,0],1];
		NULL_String : STRING  := [9,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		O2CVMax : REAL (RADIX := Float) := 1.00000000e+002;
		O2CVMin : REAL (RADIX := Float) := 5.00000000e+000;
		O2EUMax : REAL (RADIX := Float) := 3.30000013e-001;
		O2EUMax_Inp : REAL (RADIX := Float) := 3.30000000e+001;
		O2EUMin : REAL (RADIX := Float) := 0.00000000e+000;
		O2EUMin_Inp : REAL (RADIX := Float) := 0.00000000e+000;
		O2ManualSP : REAL (RADIX := Float) := 0.00000000e+000;
		O2ManualSP_Inp : REAL (RADIX := Float) := 0.00000000e+000;
		O2MaxCalc : REAL (RADIX := Float) := 1.00000000e+000;
		O2PercentOut : REAL (RADIX := Float) := 0.00000000e+000;
		O2ProgOper : BOOL (RADIX := Decimal) := 0;
		O2Scaler : SCALE  := [3,0.00000000e+000,1.00000000e+002,5.00000000e+000,3.30000013e-001,0.00000000e+000,5,0.00000000e+000
				,0,0.00000000e+000,9.50000000e+001,1.05263162e-002,0.00000000e+000];
		O2_3way : P_D4SD  := [130947,0,2,15,1,15,2,15,4,15,8,0,1,0,2,0,4,0,8,4194304,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,2.00000000e+000,0.00000000e+000,1.00000000e+001,0,2,2,0,2,0,0,0,0,-1601241088,[0,0,0],[0,0,0],[0,0,0],[0,0,0],0,1,[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20,'Dev Position Failure'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[963,1000,0,5,0,0,0,[0,5000
				,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Dev-Reported Fault$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],0],[7651,204113920,66
				,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],0,0,0,3,[13,'KV121 / KV122$00$00$00$00$00$00$00'],[14,'O2 3-Way Valve$00$00$00$00$00$00'],[20
				,'Discrete 2, 3 or 4 S$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'],[6,'Sparge$00$00'],[7,'Overlay$00'
				],1,[1263887,2000,0],[1263887,10000,0],1,[6,'P_D4SD$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],2,0,2,0,[6,'area01$00$00'],0,512,[1263687,0,0],1];
		ONS : DINT[3] (RADIX := Decimal) := [17808498,0,0];
		P101 : P_VSD (Description := "Feed Pump") := [4323335,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,12322,2,2,2,0.00000000e+000
				,1.93500000e+002,0.00000000e+000,3.27670000e+004,0.00000000e+000,1.93500000e+002,0.00000000e+000
				,3.27670000e+004,0.00000000e+000,1.93500000e+002,0.00000000e+000,4.09500000e+003,0.00000000e+000
				,4.09500000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,4.09500000e+003,0.00000000e+000
				,4.09500000e+002,0.00000000e+000,1.00000000e+001,1.50000000e+001,1.50000000e+001,2.00000000e+000
				,0.00000000e+000,0,0,0,5.00000000e+001,0.00000000e+000,0,5.00000000e+001,0.00000000e+000,8.46692480e+003
				,0.00000000e+000,5,5.00000000e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.93500000e+002,0.00000000e+000,1.93500000e+002,0,2,2,0,0,1,0,0,0,0,4194304,[7651,204113920,66,512,992
				,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Failed to Stop$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'Failed to Start$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[4,'P101$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'Feed Pump$00$00$00$00$00$00$00$00$00$00$00'
				],[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[3740884,2000,0],[-1609700762,2000,2000],0,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[6,'mL/min$00$00'],5.00000000e+001,[911974,2000,2000],[6,'mL/min$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],0.00000000e+000,[7,'Reverse$00$00$00$00$00$00$00$00$00'],[7,'Forward$00$00$00$00$00$00$00$00$00'
				],[-1609700762,15000,15000],[3740884,15000,0],0,0,1,0,0.00000000e+000,1.00000000e-001,[-1072829850,2147483647
				,0],0.00000000e+000,[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00'],[0,0,0],[0,1,0],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],199229840,2,0,[3717084,15000,0],[808478,15000,0],[6,'area01$00$00'],0,[3715084
				,0,0],0.00000000e+000,5.00000000e+001,224];
		P101Fault : BOOL (RADIX := Decimal) := 0;
		P101Fault_Output : BOOL (RADIX := Decimal) := 0;
		P101_Alarm_Reset : AMP_Alarm_Reset  := [43,100,70,[9,0],[-1609700562,130,200],[1573378,130,0],[9,0,240,0,387,0,0,0,0,0,255,15,0,0]];
		P101_Alarm_Reset_Trigger : BOOL (RADIX := Decimal) := 0;
		P101_Cal : Pump_Cal  := [64,1.30000000e+002,0.00000000e+000,5.00000000e-001,1.00000000e+002,2.60000000e+002,0.00000000e+000
				,5,[0,60000,0],[0,30000,0],1.30000000e+002];
		P101_CalRevs : REAL (RADIX := Float) := 2.00000000e+002;
		P101_Cal_Abort : BOOL (RADIX := Decimal) := 0;
		P101_Cal_Accept : BOOL (RADIX := Decimal) := 0;
		P101_Cal_ColConst : REAL (RADIX := Float) := 2.15000000e-005;
		P101_Cal_Collected : REAL (RADIX := Float) := 8.60000000e+001;
		P101_Cal_Complete : BOOL (RADIX := Decimal) := 1;
		P101_Cal_Constant : REAL (RADIX := Float) := 4.30000007e-001;
		P101_Cal_Direction : BOOL (RADIX := Decimal) := 0;
		P101_Cal_Encoder_Steps : DINT (RADIX := Decimal) := 4000000;
		P101_Cal_Max_Flow : REAL (RADIX := Float) := 1.93500000e+002;
		P101_Cal_Running : BOOL (RADIX := Decimal) := 0;
		P101_Cal_Speed : REAL (Description := "ml/min",
		            RADIX := Float) := 5.00000000e+001;
		p101_Cal_Start : BOOL (RADIX := Decimal) := 0;
		P101_Cal_Steps : REAL (RADIX := Float) := 4.00000000e+006;
		P101_Crash_Stop : AMP_Crash_Stop  := [43,100,70,[9,0],[-1609699862,130,200],[807278,130,0],[9,0,240,0,388,0,0,0,0,0,255,15,0,0]];
		P101_Crash_Stop_Trigger : BOOL (RADIX := Decimal) := 0;
		P101_Current_Speed : REAL (RADIX := Float) := -1.93798447e+000;
		P101_Disable : AMP_Motor_Disable  := [27,100,60,[9,0],[-1609699862,130,200],[2379981,130,0],[9,0,240,0,388,0,0,0,0,0,255,15,0,0]];
		P101_Disable_Trigger : BOOL (RADIX := Decimal) := 0;
		P101_Dose_Abort : BOOL (RADIX := Decimal) := 0;
		P101_Dose_Direction : BOOL (RADIX := Decimal) := 0;
		P101_Dose_mL : REAL (RADIX := Float) := 1.00000000e+003;
		P101_Dose_Running : BOOL (RADIX := Decimal) := 0;
		P101_Dose_Speed_mlmin : REAL (RADIX := Float) := 1.00000000e+002;
		P101_Dose_Start : BOOL (RADIX := Decimal) := 0;
		P101_Enable : AMP_Motor_Enable  := [175,100,70,[9,0],[-1609700362,130,200],[806878,130,0],[9,0,240,0,388,0,0,0,0,0,255,15,0,0]];
		P101_Enable_Trigger : BOOL (RADIX := Decimal) := 1;
		P101_FaultCodeList : P_DescList[1]  := [[0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]]];
		P101_Input_Assembly : AMP_Input_Assembly_v2  := [9,0,240,0,387,0,0,0,0,0,255,15,0,0];
		P101_Input_Assembly_Instance : AMP_Input_Assembly  := [3,9,0,2.40000000e+001,0.00000000e+000,3.87000008e+001,0,0,0.00000000e+000,0,0,255,0,0,[0,0,0,0,0,0,0,0,0
				,0,0,0,0,0],[0,0]];
		P101_intlk : P_Intlk  := [6531,0,0,0,0,0,4,[[11,'LIT801 HiHi$00$00$00$00$00$00$00$00$00'],[10,'WT701 LoLo$00$00$00$00$00$00$00$00$00$00'
				],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,4,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]];
		P101_Jog_Move : AMP_Jog_Move  := [43,100,-1.93798447e+000,1.00000000e+001,1.00000000e+001,70,[9,0],[-1609700462,130,200],[1414698,130
				,0],[9,0,240,0,387,0,0,0,0,0,255,15,0,0],[0,0]];
		P101_Jog_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P101_Jog_Update_Timer : TIMER  := [1486898,1000,0];
		P101_MaxRPM : REAL (RADIX := Float,
		            Constant := Yes) := 4.50000000e+002;
		P101_Motor_Constant : DINT (RADIX := Decimal) := 20000;
		P101_New_Speed : REAL (RADIX := Float) := 0.00000000e+000;
		P101_OCmd_Stop : BOOL (RADIX := Decimal) := 0;
		P101_Relative_Move : AMP_Relative_Move  := [43,100,4000000,3.75000000e+000,1.00000000e+001,1.00000000e+001,70,[9,0],[-1609699962,130,200],[2349784
				,130,0],[9,0,240,0,387,0,0,0,0,0,255,15,0,0],[0,0]];
		P101_Relative_Move_Start_Timer : TIMER  := [0,1000,0];
		P101_Relative_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P101_Running_Fwd : BOOL (RADIX := Decimal) := 0;
		P101_Running_Rev : BOOL (RADIX := Decimal) := 0;
		P101_Speed : REAL (RADIX := Float) := 5.00000000e+001;
		P101_Status_Code : AMP_Status_Code  := [39,9];
		P101_Update_Jog_High_Limit : REAL (RADIX := Float) := 8.33408296e-001;
		P101_Update_Jog_Low_Limit : REAL (RADIX := Float) := 8.33258331e-001;
		P101_Update_Jog_Speed : AMP_Update_Jog_Speed  := [43,100,-1.93798447e+000,70,[9,0],[-1609700962,130,200],[1485898,130,0],[9,0,240,0,387,0,0,0,0,0,255,15,0,0],[0,0]];
		P101_Update_Jog_Speed_Placeholder : REAL (RADIX := Float) := 4.16666657e-001;
		P101_Update_Jog_Speed_Trigger : BOOL (RADIX := Decimal) := 0;
		P101_Update_Jog_Test_Value : REAL (RADIX := Float) := 8.33333373e-001;
		P101_Val_SpeedFdbk_PlaceHolder : REAL (RADIX := Float) := 0.00000000e+000;
		P101_Val_SpeedFdbk_PlaceHolder_DINT : DINT (RADIX := Decimal) := 0;
		P102 : P_VSD (Description := "Media Pump") := [4323335,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,12322,2,2,2,0.00000000e+000
				,1.75500000e+002,0.00000000e+000,3.27670000e+004,0.00000000e+000,1.75500000e+002,0.00000000e+000
				,3.27670000e+004,0.00000000e+000,1.75500000e+002,0.00000000e+000,4.09500000e+003,0.00000000e+000
				,4.09500000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,4.09500000e+003,0.00000000e+000
				,4.09500000e+002,0.00000000e+000,1.00000000e+001,1.50000000e+001,1.50000000e+001,2.00000000e+000
				,0.00000000e+000,0,0,0,5.00000000e+001,0.00000000e+000,0,5.00000000e+001,0.00000000e+000,9.33532715e+003
				,0.00000000e+000,5,5.00000000e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.75500000e+002,0.00000000e+000,1.75500000e+002,0,2,2,0,0,1,0,0,0,0,4194304,[7651,204113920,66,512,992
				,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Failed to Stop$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'Failed to Start$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[4,'P102$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[10,'Media Pump$00$00$00$00$00$00$00$00$00$00'
				],[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[872280,2000,0],[-1609700262,2000,2000],0,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[6,'mL/min$00$00'],5.00000000e+001,[912474,2000,2000],[6,'mL/min$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],0.00000000e+000,[7,'Reverse$00$00$00$00$00$00$00$00$00'],[7,'Forward$00$00$00$00$00$00$00$00$00'
				],[-1609700262,15000,15000],[872280,15000,0],0,0,1,0,0.00000000e+000,1.00000000e-001,[-1072829350,2147483647
				,0],0.00000000e+000,[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00'],[0,0,0],[0,1,0],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],199229840,2,0,[753080,15000,0],[808478,15000,0],[6,'area01$00$00'],0,[751080
				,0,0],0.00000000e+000,5.00000000e+001,224];
		P102Fault : BOOL (RADIX := Decimal) := 0;
		P102Fault_Output : BOOL (RADIX := Decimal) := 0;
		P102_Alarm_Code : AMP_Alarm_Code  := [1,0];
		P102_Alarm_Reset : AMP_Alarm_Reset  := [43,100,70,[9,0],[-1609700862,130,200],[1572578,130,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0]];
		P102_Alarm_Reset_Trigger : BOOL (RADIX := Decimal) := 0;
		P102_Cal : Pump_Cal  := [32,0.00000000e+000,0.00000000e+000,5.00000000e-001,1.00000000e+002,0.00000000e+000,0.00000000e+000
				,5,[0,60000,0],[0,30000,0],0.00000000e+000];
		P102_CalRevs : REAL (RADIX := Float) := 2.00000000e+002;
		P102_Cal_Abort : BOOL (RADIX := Decimal) := 0;
		P102_Cal_Accept : BOOL (RADIX := Decimal) := 0;
		P102_Cal_ColConst : REAL (RADIX := Float) := 1.94999993e-005;
		P102_Cal_Collected : REAL (RADIX := Float) := 7.80000000e+001;
		P102_Cal_Complete : BOOL (RADIX := Decimal) := 1;
		P102_Cal_Constant : REAL (RADIX := Float) := 3.89999986e-001;
		P102_Cal_Direction : BOOL (RADIX := Decimal) := 0;
		P102_Cal_Encoder_Steps : DINT (RADIX := Decimal) := 4000000;
		P102_Cal_Max_Flow : REAL (RADIX := Float) := 1.75500000e+002;
		P102_Cal_Running : BOOL (RADIX := Decimal) := 0;
		P102_Cal_Speed : REAL (Description := "ml/min",
		            RADIX := Float) := 5.00000000e+001;
		P102_Cal_Start : BOOL (RADIX := Decimal) := 0;
		P102_Cal_Steps : REAL (RADIX := Float) := 4.00000000e+006;
		P102_Crash_Stop : AMP_Crash_Stop  := [43,100,70,[9,0],[-1609699862,130,200],[807278,130,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0]];
		P102_Crash_Stop_Trigger : BOOL (RADIX := Decimal) := 0;
		P102_Current_Speed : REAL (RADIX := Float) := -2.13675213e+000;
		P102_Disable : AMP_Motor_Disable  := [27,100,60,[9,0],[-1609700162,130,200],[2379981,130,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0]];
		P102_Disable_Trigger : BOOL (RADIX := Decimal) := 0;
		P102_Dose_Abort : BOOL (RADIX := Decimal) := 0;
		P102_Dose_Direction : BOOL (RADIX := Decimal) := 0;
		P102_Dose_mL : REAL (RADIX := Float) := 1.00000000e+003;
		P102_Dose_Running : BOOL (RADIX := Decimal) := 0;
		P102_Dose_Speed_mlmin : REAL (RADIX := Float) := 1.00000000e+002;
		P102_Dose_Start : BOOL (RADIX := Decimal) := 0;
		P102_Enable : AMP_Motor_Enable  := [175,100,70,[9,0],[-1609700962,130,200],[806878,130,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0]];
		P102_Enable_Trigger : BOOL (RADIX := Decimal) := 1;
		P102_FaultCodeList : P_DescList[1]  := [[0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]]];
		P102_Input_Assembly : AMP_Input_Assembly_v2  := [9,0,244,0,389,0,0,0,0,0,255,15,0,0];
		P102_Input_Assembly_Instance : AMP_Input_Assembly  := [3,9,0,2.43999996e+001,0.00000000e+000,3.89000015e+001,0,0,0.00000000e+000,0,0,255,0,0,[0,0,0,0,0,0,0,0,0
				,0,0,0,0,0],[0,0]];
		P102_intlk : P_Intlk  := [6531,0,0,0,0,0,4,[[10,'WT702 HiHi$00$00$00$00$00$00$00$00$00$00'],[10,'WT701 LoLo$00$00$00$00$00$00$00$00$00$00'
				],[5,'Estop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,4,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[5,'Estop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]];
		P102_Jog_Move : AMP_Jog_Move  := [43,100,0.00000000e+000,1.00000000e+001,1.00000000e+001,70,[9,0],[-1609700162,130,200],[2024898,130
				,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0],[0,0]];
		P102_Jog_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P102_Jog_Update_Timer : TIMER  := [2045298,1000,0];
		P102_MaxRPM : REAL (RADIX := Float,
		            Constant := Yes) := 4.50000000e+002;
		P102_Motor_Constant : REAL (RADIX := Float) := 2.00000000e+004;
		P102_OCmd_Stop : BOOL (RADIX := Decimal) := 0;
		P102_Relative_Move : AMP_Relative_Move  := [43,100,4000000,3.75000000e+000,1.00000000e+001,1.00000000e+001,70,[9,0],[-1609700662,130,200],[659680
				,130,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0],[0,0]];
		P102_Relative_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P102_Running_Fwd : BOOL (RADIX := Decimal) := 0;
		P102_Running_Rev : BOOL (RADIX := Decimal) := 0;
		P102_Status_Code : AMP_Status_Code  := [39,9];
		P102_Update_Jog_Speed : AMP_Update_Jog_Speed  := [27,100,-2.13675213e+000,60,[9,0],[-1609700962,130,200],[2045298,130,0],[9,0,244,0,389,0,0,0,0,0,255,15,0,0],[0,0]];
		P102_Update_Jog_Speed_Trigger : BOOL (RADIX := Decimal) := 0;
		P103 : P_VSD (Description := "Conditioned Media Addition Pump") := [129079,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,-2147471326,2,2
				,2,0.00000000e+000,1.93500000e+002,0.00000000e+000,3.27670000e+004,0.00000000e+000,1.93500000e+002
				,0.00000000e+000,3.27670000e+004,0.00000000e+000,1.93500000e+002,0.00000000e+000,4.09500000e+003
				,0.00000000e+000,4.09500000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,4.09500000e+003
				,0.00000000e+000,4.09500000e+002,0.00000000e+000,1.00000000e+001,1.50000000e+001,1.50000000e+001
				,2.00000000e+000,0.00000000e+000,0,0,0,3.66535225e+001,0.00000000e+000,0,3.66535225e+001,0.00000000e+000
				,6.20685254e+003,0.00000000e+000,1060868,3.66535225e+001,3.66535187e+001,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,1.93500000e+002,0.00000000e+000,1.93500000e+002,0,2,2,0,0,2
				,0,0,0,0,0,[2104803,-1440079360,32,128,994,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0
				,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[963
				,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Failed to Stop$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Failed to Start$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[4
				,'P103$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Cond. Media Pump$00$00$00$00'
				],[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[1109680,2000,0],[-1609700162,2000,2000],0,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[6,'mL/min$00$00'],3.66535225e+001,[912574,2000,2000],[6,'mL/min$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],0.00000000e+000,[7,'Reverse$00$00$00$00$00$00$00$00$00'],[7,'Forward$00$00$00$00$00$00$00$00$00'
				],[-1609700162,15000,15000],[1109680,15000,0],0,0,1,0,0.00000000e+000,1.00000000e-001,[-1072829250,2147483647
				,0],0.00000000e+000,[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00'],[0,0,0],[0,1,0],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],134218128,2,0,[990480,15000,0],[808478,15000,0],[6,'area01$00$00'],0,[988480
				,0,0],0.00000000e+000,3.66535225e+001,28];
		P103Fault : BOOL (RADIX := Decimal) := 0;
		P103Fault_Output : BOOL (RADIX := Decimal) := 0;
		P103_Alarm_Code : AMP_Alarm_Code  := [1,0];
		P103_Alarm_Reset : AMP_Alarm_Reset  := [43,100,70,[49,0],[-1609700962,130,200],[1575178,130,0],[49,0,244,0,395,0,101505840,0,0,0,255,15,0,0]];
		P103_Alarm_Reset_Trigger : BOOL (RADIX := Decimal) := 0;
		P103_Cal : Pump_Cal  := [64,5.00000000e+001,0.00000000e+000,5.00000000e-001,1.00000000e+002,1.00000000e+002,0.00000000e+000
				,5,[0,60000,0],[0,30000,0],5.00000000e+001];
		P103_CalRevs : REAL (RADIX := Float) := 2.00000000e+002;
		P103_Cal_Abort : BOOL (RADIX := Decimal) := 0;
		P103_Cal_Accept : BOOL (RADIX := Decimal) := 0;
		P103_Cal_ColConst : REAL (RADIX := Float) := 2.15000000e-005;
		P103_Cal_Collected : REAL (RADIX := Float) := 8.60000000e+001;
		P103_Cal_Complete : BOOL (RADIX := Decimal) := 1;
		P103_Cal_Constant : REAL (RADIX := Float) := 4.30000007e-001;
		P103_Cal_Direction : BOOL (RADIX := Decimal) := 0;
		P103_Cal_Encoder_Steps : DINT (RADIX := Decimal) := 4000000;
		P103_Cal_Max_Flow : REAL (RADIX := Float) := 1.93500000e+002;
		P103_Cal_Running : BOOL (RADIX := Decimal) := 0;
		P103_Cal_Speed : REAL (Description := "ml/min",
		            RADIX := Float) := 5.00000000e+001;
		P103_Cal_Start : BOOL (RADIX := Decimal) := 0;
		P103_Cal_Steps : REAL (RADIX := Float) := 4.00000000e+006;
		P103_Crash_Stop : AMP_Crash_Stop  := [43,100,70,[49,0],[-1609700962,130,200],[457674,130,0],[49,0,244,0,395,0,101505840,0,0,0,255,15,0,0]];
		P103_Crash_Stop_Trigger : BOOL (RADIX := Decimal) := 0;
		P103_Current_Speed : REAL (RADIX := Float) := 1.42067909e+000;
		P103_Disable : AMP_Motor_Disable  := [27,100,60,[49,0],[-1609699962,130,200],[2379981,130,0],[49,0,244,0,395,0,101534260,0,0,0,255,15,0,0]];
		P103_Disable_Trigger : BOOL (RADIX := Decimal) := 0;
		P103_Dose_Abort : BOOL (RADIX := Decimal) := 0;
		P103_Dose_Direction : BOOL (RADIX := Decimal) := 0;
		P103_Dose_mL : REAL (RADIX := Float) := 1.00000000e+003;
		P103_Dose_Running : BOOL (RADIX := Decimal) := 0;
		P103_Dose_Speed_mlmin : REAL (RADIX := Float) := 1.00000000e+002;
		P103_Dose_Start : BOOL (RADIX := Decimal) := 0;
		P103_Enable : AMP_Motor_Enable  := [175,100,70,[49,0],[-1609700062,130,200],[806878,130,0],[49,0,244,0,395,0,101531407,0,0,0,255,15,0,0]];
		P103_Enable_Trigger : BOOL (RADIX := Decimal) := 1;
		P103_FaultCodeList : P_DescList[1]  := [[0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]]];
		P103_Input_Assembly : AMP_Input_Assembly_v2  := [49,0,244,0,395,0,101505840,0,0,0,255,15,0,0];
		P103_Input_Assembly_Instance : AMP_Input_Assembly  := [3,49,0,2.43999996e+001,0.00000000e+000,3.95000000e+001,0,101517221,0.00000000e+000,0,0,255,0,0
				,[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0]];
		P103_intlk : P_Intlk  := [6531,0,0,0,0,0,4,[[11,'LIT801 HiHi$00$00$00$00$00$00$00$00$00'],[10,'WT702 LoLo$00$00$00$00$00$00$00$00$00$00'
				],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,4,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]];
		P103_Jog_Move : AMP_Jog_Move  := [43,100,-1.44157374e+000,1.00000000e+001,1.00000000e+001,70,[49,0],[-1609699862,130,200],[891774,130
				,0],[49,0,244,0,395,0,101537108,0,0,0,255,15,0,0],[0,0]];
		P103_Jog_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P103_Jog_Update_Timer : TIMER  := [-1072830350,1000,600];
		P103_MaxRPM : REAL (RADIX := Float,
		            Constant := Yes) := 4.50000000e+002;
		P103_Motor_Constant : REAL (RADIX := Float) := 2.00000000e+004;
		P103_OCmd_Stop : BOOL (RADIX := Decimal) := 0;
		P103_Relative_Move : AMP_Relative_Move  := [43,100,4000000,3.75000000e+000,1.00000000e+001,1.00000000e+001,70,[49,0],[-1609700862,130,200],[2674984
				,130,0],[49,0,244,0,396,0,101508688,0,0,0,255,15,0,0],[0,0]];
		P103_Relative_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P103_Running_Fwd : BOOL (RADIX := Decimal) := 0;
		P103_Running_Rev : BOOL (RADIX := Decimal) := 0;
		P103_Status_Code : AMP_Status_Code  := [199,49];
		P103_Update_Jog_Speed : AMP_Update_Jog_Speed  := [43,100,1.42067909e+000,70,[49,0],[-1609700762,130,200],[906774,130,0],[49,0,244,0,396,0,101511541,0,0,0,255,15,0
				,0],[0,0]];
		P103_Update_Jog_Speed_Trigger : BOOL (RADIX := Decimal) := 0;
		P104 : P_VSD (Description := "Recirculation Pump") := [4323335,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,12322,2,2,2,0.00000000e+000
				,1.89000000e+002,0.00000000e+000,3.27670000e+004,0.00000000e+000,1.89000000e+002,0.00000000e+000
				,3.27670000e+004,0.00000000e+000,1.89000000e+002,0.00000000e+000,4.09500000e+003,0.00000000e+000
				,4.09500000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,4.09500000e+003,0.00000000e+000
				,4.09500000e+002,0.00000000e+000,1.00000000e+001,1.50000000e+001,1.50000000e+001,2.00000000e+000
				,0.00000000e+000,0,0,0,0.00000000e+000,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,1048581,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,1.89000000e+002,0.00000000e+000,1.89000000e+002,0,2,2,0,0,1,0,0,0,0,4194304,[2104803
				,-1440079360,32,128,994,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0
				],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[963
				,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Interlock Trip$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14,'Failed to Stop$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[451
				,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Failed to Start$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],0],[4
				,'P104$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Recirculation Pump$00$00'
				],[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[2873893,2000,0],[-1609700362,2000,2000],0,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[6,'mL/min$00$00'],0.00000000e+000,[912374,2000,2000],[6,'mL/min$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],0.00000000e+000,[7,'Reverse$00$00$00$00$00$00$00$00$00'],[7,'Forward$00$00$00$00$00$00$00$00$00'
				],[-1609700362,15000,15000],[2873893,15000,0],0,0,1,0,0.00000000e+000,1.00000000e-001,[-1072829350,2147483647
				,0],0.00000000e+000,[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00'],[3250382,0,0],[0,1,0],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],134218128,2,0,[2856093,15000,0],[808478,15000,0],[6,'area01$00$00'],0,[2854093
				,0,0],0.00000000e+000,0.00000000e+000,28];
		P104Fault : BOOL (RADIX := Decimal) := 0;
		P104Fault_Output : BOOL (RADIX := Decimal) := 0;
		P104_Alarm_Code : AMP_Alarm_Code  := [1,0];
		P104_Alarm_Reset : AMP_Alarm_Reset  := [43,100,70,[49,0],[-1609700762,130,200],[1574379,130,0],[49,0,240,0,382,0,-51502203,0,0,0,255,15,0,0]];
		P104_Alarm_Reset_Trigger : BOOL (RADIX := Decimal) := 0;
		P104_Cal : Pump_Cal  := [64,1.10000000e+002,0.00000000e+000,5.00000000e-001,1.00000000e+002,2.20000000e+002,0.00000000e+000
				,5,[0,60000,0],[0,30000,0],1.10000000e+002];
		P104_CalRevs : REAL (RADIX := Float) := 2.00000000e+002;
		P104_Cal_Abort : BOOL (RADIX := Decimal) := 0;
		P104_Cal_Accept : BOOL (RADIX := Decimal) := 0;
		P104_Cal_ColConst : REAL (RADIX := Float) := 2.09999998e-005;
		P104_Cal_Collected : REAL (RADIX := Float) := 8.40000000e+001;
		P104_Cal_Complete : BOOL (RADIX := Decimal) := 1;
		P104_Cal_Constant : REAL (RADIX := Float) := 4.19999987e-001;
		P104_Cal_Direction : BOOL (RADIX := Decimal) := 0;
		P104_Cal_Encoder_Steps : DINT (RADIX := Decimal) := 4000000;
		P104_Cal_Max_Flow : REAL (RADIX := Float) := 1.89000000e+002;
		P104_Cal_Running : BOOL (RADIX := Decimal) := 0;
		P104_Cal_Speed : REAL (Description := "ml/min",
		            RADIX := Float) := 5.00000000e+001;
		P104_Cal_Start : BOOL (RADIX := Decimal) := 0;
		P104_Cal_Steps : REAL (RADIX := Float) := 4.00000000e+006;
		P104_Crash_Stop : AMP_Crash_Stop  := [43,100,70,[49,0],[-1609700062,130,200],[457674,130,0],[49,0,240,0,381,0,-51502203,0,0,0,255,15,0,0]];
		P104_Crash_Stop_Trigger : BOOL (RADIX := Decimal) := 0;
		P104_Current_Speed : REAL (RADIX := Float) := 0.00000000e+000;
		P104_Disable : AMP_Motor_Disable  := [27,100,60,[49,0],[-1609700962,130,200],[2379981,130,0],[49,0,240,0,381,0,-51502203,0,0,0,255,15,0,0]];
		P104_Disable_Trigger : BOOL (RADIX := Decimal) := 0;
		P104_Dose_Abort : BOOL (RADIX := Decimal) := 0;
		P104_Dose_Direction : BOOL (RADIX := Decimal) := 0;
		P104_Dose_mL : REAL (RADIX := Float) := 1.00000000e+003;
		P104_Dose_Running : BOOL (RADIX := Decimal) := 0;
		P104_Dose_Speed_mlmin : REAL (RADIX := Float) := 1.00000000e+002;
		P104_Dose_Start : BOOL (RADIX := Decimal) := 0;
		P104_Enable : AMP_Motor_Enable  := [175,100,70,[49,0],[-1609700062,130,200],[806878,130,0],[49,0,240,0,381,0,-51502203,0,0,0,255,15,0,0]];
		P104_Enable_Trigger : BOOL (RADIX := Decimal) := 1;
		P104_FaultCodeList : P_DescList[1]  := [[0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]]];
		P104_Input_Assembly : AMP_Input_Assembly_v2  := [49,0,240,0,381,0,-51502203,0,0,0,255,15,0,0];
		P104_Input_Assembly_Instance : AMP_Input_Assembly  := [3,49,0,2.40000000e+001,0.00000000e+000,3.80999985e+001,0,-51502203,0.00000000e+000,0,0,255,0,0
				,[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0]];
		p104_intlk : P_Intlk  := [6531,0,0,0,0,0,1,[[11,'LIT801 LoLo$00$00$00$00$00$00$00$00$00'],[10,'WT702 HiHi$00$00$00$00$00$00$00$00$00$00'
				],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,1,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[11,'LIT801 LoLo$00$00$00$00$00$00$00$00$00'
				]];
		P104_Jog_Move : AMP_Jog_Move  := [43,100,-1.47589707e+000,1.00000000e+001,1.00000000e+001,70,[49,0],[-1609699862,130,200],[891874,130
				,0],[49,0,240,0,381,0,-51502203,0,0,0,255,15,0,0],[0,0]];
		P104_Jog_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P104_Jog_Update_Timer : TIMER  := [-1072830350,1000,600];
		P104_MaxRPM : REAL (RADIX := Float,
		            Constant := Yes) := 4.50000000e+002;
		P104_Motor_Constant : REAL (RADIX := Float) := 2.00000000e+004;
		P104_OCmd_Stop : BOOL (RADIX := Decimal) := 0;
		P104_Relative_Move : AMP_Relative_Move  := [43,100,4000000,3.75000000e+000,1.00000000e+001,1.00000000e+001,70,[49,0],[-1609699862,130,200],[2821584
				,130,0],[49,0,240,0,381,0,-51502203,0,0,0,255,15,0,0],[0,0]];
		P104_Relative_Move_Trigger : BOOL (RADIX := Decimal) := 0;
		P104_Running_Fwd : BOOL (RADIX := Decimal) := 0;
		P104_Running_Rev : BOOL (RADIX := Decimal) := 0;
		P104_Status_Code : AMP_Status_Code  := [199,49];
		P104_Update_Jog_Speed : AMP_Update_Jog_Speed  := [175,100,0.00000000e+000,70,[49,0],[-1609700162,130,200],[912274,130,0],[49,0,240,0,382,0,-51502203,0,0,0,255,15
				,0,0],[0,0]];
		P104_Update_Jog_Speed_Trigger : BOOL (RADIX := Decimal) := 1;
		P105 : P_VSD (Description := "Spent Media Pump") := [4323383,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,-2147471326,2
				,2,2,0.00000000e+000,1.58620007e+003,0.00000000e+000,2.20000000e+003,0.00000000e+000,2.20000000e+003
				,0.00000000e+000,2.20000000e+003,0.00000000e+000,2.20000000e+003,0.00000000e+000,4.09500000e+003
				,0.00000000e+000,4.09500000e+003,0.00000000e+000,4.09500000e+003,0.00000000e+000,4.09500000e+003
				,0.00000000e+000,4.09500000e+003,0.00000000e+000,1.00000000e+001,1.50000000e+001,1.50000000e+001
				,2.00000000e+000,0.00000000e+000,0,0,0,6.93481293e+001,0.00000000e+000,0,6.93481293e+001,0.00000000e+000
				,6.93481293e+001,0.00000000e+000,12292,6.93481293e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,2.20000000e+003,0.00000000e+000,2.20000000e+003,0,2,2,0,0,1,0,0,0,0,0,[7651,204113920
				,66,512,992,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Failed to Stop$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'Failed to Start$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[4,'P105$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[16,'Spent Media Pump$00$00$00$00'
				],[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[2356280,2000,0],[-1609699962,2000,2000],0,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[6,'mL/min$00$00'],6.93481293e+001,[912774,2000,2000],[6,'mL/min$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],0.00000000e+000,[7,'Reverse$00$00$00$00$00$00$00$00$00'],[7,'Forward$00$00$00$00$00$00$00$00$00'
				],[-1609699962,15000,15000],[2356280,15000,0],0,0,1,0,0.00000000e+000,1.00000000e-001,[-1072829050,2147483647
				,0],0.00000000e+000,[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00'],[0,0,0],[0,1,0],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],199229840,2,0,[2194880,15000,0],[3925278,15000,0],[6,'area01$00$00'],0,[2192880
				,0,0],0.00000000e+000,6.93481293e+001,224];
		P105_Alm_Fault : BOOL (RADIX := Decimal) := 0;
		P105_Cal : Pump_Cal  := [0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,5,[0,0,0],[0,0,0],0.00000000e+000];
		P105_Cal_Max_Flow : REAL (RADIX := Float) := 1.58620007e+003;
		P105_Dose_Abort : BOOL (RADIX := Decimal) := 0;
		P105_Dose_Direction : BOOL (RADIX := Decimal) := 0;
		P105_Dose_mL : REAL (Description := "mL",
		            RADIX := Float) := 1.00000000e+003;
		P105_Dose_Running : BOOL (RADIX := Decimal) := 0;
		P105_Dose_Speed_mlmin : REAL (Description := "mL/min",
		            RADIX := Float) := 1.00000000e+002;
		P105_Dose_Start : BOOL (RADIX := Decimal) := 0;
		P105_Dose_Timer : TIMER  := [1985184,600000,0];
		P105_FaultCodeList : P_DescList[1]  := [[0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]]];
		P105_Flow_Rate_Correction : REAL (Description := "Set Speed is in rev/min, this scales the speed command with the flow cal from the pump",
		            RADIX := Float) := 7.21000016e-001;
		P105_intlk : P_Intlk  := [6531,0,0,0,0,0,2,[[10,'WT703 HiHi$00$00$00$00$00$00$00$00$00$00'],[11,'LIT801 LoLo$00$00$00$00$00$00$00$00$00'
				],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,2,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[11,'LIT801 LoLo$00$00$00$00$00$00$00$00$00'
				]];
		P105_mLrev : REAL (Description := "mL/rev",
		            RADIX := Float) := 1.00000000e+001;
		P105_OCmd_Stop : BOOL (RADIX := Decimal) := 0;
		P105_Relative_Move : AMP_Relative_Move  := [5,100,400,6.66599989e+000,0.00000000e+000,0.00000000e+000,10,[0,0],[0,0,0],[0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0]];
		P105_Run_Reverse : BOOL (RADIX := Decimal) := 0;
		P105_Speed_Update_Timer : TIMER  := [1485898,1000,0];
		P105_Timer : TIMER  := [3796163,30000,0];
		PBSData : PBSdata_UDT  := [1.99315395e+001,2.00000000e+001,5.00000000e+001,0,0,0,3.59345894e+001,3.70049896e+001,3.70000000e+001
				,0.00000000e+000,0,0,0,6.55282927e+000,5.61536560e+001,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,2,0,0,0.00000000e+000,0.00000000e+000,9.20047760e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,2,100,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,1.86770105e+000,0,3.37385712e+001
				,50,0.00000000e+000,0,90,1.00000000e+002,1.49251983e-001,1.50000006e-001,1,0,0,1.49251983e-001
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,1.00000000e+002];
		Perfusion_Level_Aggression : REAL (RADIX := Float) := 5.00000000e+001;
		Perfusion_Off : BOOL (RADIX := Decimal) := 0;
		Perfusion_On : BOOL (RADIX := Decimal) := 0;
		Perfusion_Running : BOOL (RADIX := Decimal) := 0;
		Perfusion_Start : BOOL (RADIX := Decimal) := 0;
		Perfusion_Stop_Trigger : BOOL (RADIX := Decimal) := 0;
		Perfusion_Update_Speed : BOOL (RADIX := Decimal) := 0;
		PHpbs : PID_ENHANCED  := [1,1056776,7.88896370e+000,1.40000000e+001,0.00000000e+000,7.00000000e+000,1.00000000e+001
				,0.00000000e+000,1.40000000e+001,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,1.00000000e+000,5.00000000e+000,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,3.40282347e+038,0.00000000e+000,0.00000000e+000,3.40282347e+038
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,17825857,0.00000000e+000,0.00000000e+000,1.00000000e+001
				,7.14285736e+001,0.00000000e+000,1.00000000e+001,7.14285736e+001,1.00000000e+000,1.00000000e+000
				,0,0,0,0.00000000e+000,5.95161819e+000,0.00000000e+000,7.14285736e+001,7.14285736e+001,0.00000000e+000
				,0.00000000e+000,1.00000000e+000,8.33333358e-002,0.00000000e+000,1.00000000e+000,1.00000000e+000
				,5.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+001,0.00000000e+000,2.64488051e-038,1.00000000e+001,0.00000000e+000,7.14285736e+001
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042,7.15555965e-039
				,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,7.15555965e-039,7.89211295e-042
				,1.00000000e+000];
		pHtestPV : REAL (RADIX := Float) := 0.00000000e+000;
		ph_cal_b_0_idle : BOOL (RADIX := Decimal) := 1;
		ph_cal_b_100_start_pt2 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_10_set_user2 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_110_place_probe_pt2 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_120_wait_for_stability_pt2 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_130_write_pt2 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_130_write_pt2_Timer : TIMER  := [0,1000,0];
		ph_cal_b_140_wait_for_done : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_150_place_probe_process : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_160_wait_for_stability_process : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_170_write_process : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_170_write_process_Timer : TIMER  := [0,1000,0];
		ph_cal_b_180_wait_for_done_process : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_190_done_ok : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_200_done_error : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_20_set_user2_ack : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_210_pwd_error : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_25_set_user1_wait : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_25_set_user1_wait_Timer : TIMER  := [0,3000,0];
		ph_cal_b_30_set_pt1_params : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_30_set_pt1_params_Timer : TIMER  := [1224488,2000,0];
		ph_cal_b_40_check_params : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_40_check_params_Timer : TIMER  := [0,3000,0];
		ph_cal_b_50_cal_method : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_60_place_probe : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_70_wait_for_stability_pt1 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_80_write_pt1 : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_80_write_pt1_Timer : TIMER  := [0,1000,0];
		ph_cal_b_90_wait_pt1_write : BOOL (RADIX := Decimal) := 0;
		ph_cal_b_90_wait_pt1_write_Timer : TIMER  := [0,5000,0];
		ph_cal_done_date : STRING  := [9,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		ph_cal_reset : BOOL (RADIX := Decimal) := 0;
		ph_cal_start : BOOL (RADIX := Decimal) := 0;
		ph_cal_state_var : DINT (RADIX := Decimal) := 0;
		pH_CVEUMax : REAL (RADIX := Float) := 1.00000000e+002;
		pH_CVEUMin : REAL (RADIX := Float) := 0.00000000e+000;
		pH_HiDev : REAL (Description := "ph hi deviation$N",
		            RADIX := Float) := 0.00000000e+000;
		pH_Initialize : BOOL (RADIX := Decimal) := 1;
		pH_LoDev : REAL (Description := "pH Lo deviation alarm$N",
		            RADIX := Float) := 0.00000000e+000;
		pH_Normalized : REAL (RADIX := Float) := 0.00000000e+000;
		PH_On : BOOL (RADIX := Decimal) := 1;
		pH_PID_AUTOREQ : BOOL (RADIX := Decimal) := 1;
		pH_probe_placement_ready : BOOL (RADIX := Decimal) := 0;
		ph_r_cal_control : DINT (RADIX := Decimal) := 0;
		ph_r_cal_date : DINT (Description := "Date of last calibration",
		            RADIX := Decimal) := 403251235;
		ph_r_cal_method : DINT (RADIX := Decimal) := 16;
		ph_r_cal_offset : REAL (RADIX := Float) := 0.00000000e+000;
		ph_r_cal_process : REAL (RADIX := Float) := 0.00000000e+000;
		ph_r_cal_slope : REAL (RADIX := Float) := 0.00000000e+000;
		ph_r_cal_status : DINT (RADIX := Decimal) := 1;
		ph_r_cal_time : DINT (RADIX := Decimal) := 65542;
		ph_r_ph : REAL (Description := "PH PV",
		            RADIX := Float) := 7.88896370e+000;
		ph_r_sensor_disconnected : DINT (RADIX := Decimal) := 0;
		ph_r_sensor_type : DINT (RADIX := Decimal) := 256;
		ph_r_unit : DINT (RADIX := Decimal) := 65542;
		ph_r_user_level : DINT (Description := "Current Enumerated user level:$NLevel: 0 Hex: 0x3$NLevel 1: Hex: 0xC$NLevel 2: Hex: 0x30",
		            RADIX := Decimal) := 12;
		ph_r_wrong_sensor : BOOL (RADIX := Decimal) := 0;
		pH_Scale : SCALE  := [1,0.00000000e+000,3.27670000e+004,0.00000000e+000,1.40000000e+001,0.00000000e+000,1,0.00000000e+000
				,0,0.00000000e+000,3.27670000e+004,3.05185094e-005,0.00000000e+000];
		pH_stability_ok : BOOL (RADIX := Decimal) := 0;
		ph_w_cal_buffer_tab : DINT (RADIX := Decimal) := 1;
		ph_w_cal_control : DINT (RADIX := Decimal) := 0;
		ph_w_cal_date : DINT (RADIX := Decimal) := 0;
		ph_w_cal_method : DINT (RADIX := Decimal) := 16;
		ph_w_cal_offset : REAL (RADIX := Float) := 0.00000000e+000;
		ph_w_cal_offset_input : REAL (RADIX := Float) := 1.00000000e+001;
		ph_w_cal_process : REAL (RADIX := Float) := 0.00000000e+000;
		ph_w_cal_process_input : REAL (RADIX := Float) := 0.00000000e+000;
		ph_w_cal_slope : REAL (RADIX := Float) := 0.00000000e+000;
		ph_w_cal_slope_input : REAL (RADIX := Float) := 4.00000000e+000;
		ph_w_cal_stability : DINT (RADIX := Decimal) := 1;
		ph_w_cal_status : DINT (RADIX := Decimal) := 0;
		ph_w_cal_time : DINT (RADIX := Decimal) := 0;
		ph_w_cal_unit_cal : DINT (RADIX := Decimal) := 0;
		ph_w_user_level : DINT (Description := "Commanded Enumerated user level:$NLevel: 0 Hex: 0x3$NLevel 1: Hex: 0xC$NLevel 2: Hex: 0x30",
		            RADIX := Decimal) := 12;
		ph_w_user_password : DINT (Description := "Commanded Password:$NLevel 0: 0x0000 0000$NLevel 1: 0x01145DEA$NLevel 2: 0x00F479CE",
		            RADIX := Decimal) := 18111978;
		PlaceHolderFeedback1 : REAL (RADIX := Float) := 0.00000000e+000;
		PlaceHolderFeedback2 : REAL (RADIX := Float) := 0.00000000e+000;
		PlaceHolderFeedback3 : REAL (RADIX := Float) := 0.00000000e+000;
		PlaceHolderFeedback4 : REAL (RADIX := Float) := 0.00000000e+000;
		PlaceHolderIOFault : DINT[3] (RADIX := Decimal) := [0,0,0];
		PlaceHolderOutput1 : REAL (RADIX := Float) := 3.85049973e+001;
		PlaceHolderOutput2 : REAL (RADIX := Float) := 4.95000000e+001;
		PlaceHolderOutput3 : REAL (RADIX := Float) := 4.99800034e+001;
		PlaceHolderOutput4 : REAL (RADIX := Float) := 4.95000000e+001;
		PLCStatus : ProcData  := [[2023,11,8,14,26,45,124010],0,0,0,0,0,0,0,0,[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0]];
		Pump_Prime_Enable : BOOL (RADIX := Decimal) := 0;
		Recirc_HiSP1 : REAL (Description := "BRX Hi recirc hi speed modifier",
		            RADIX := Float) := 1.10000000e+002;
		Recirc_LoSP1 : REAL (Description := "MCV Hi recirc lo speed modifier",
		            RADIX := Float) := 8.00000000e+001;
		Recirc_LoSP2 : REAL (Description := "BRX Lo recirc lo speed modifier",
		            RADIX := Float) := 9.00000000e+001;
		SIC401 : P_VSD (Description := "Agitator") := [4323335,0.00000000e+000,0,0.00000000e+000,0,0.00000000e+000,0.00000000e+000,12322,0,0,0,0.00000000e+000
				,6.00000000e+002,0.00000000e+000,6.00000000e+002,0.00000000e+000,6.00000000e+002,0.00000000e+000
				,6.00000000e+002,0.00000000e+000,6.00000000e+002,0.00000000e+000,6.00000000e+002,0.00000000e+000
				,6.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,6.00000000e+002,0.00000000e+000
				,6.00000000e+002,0.00000000e+000,1.00000000e+001,1.50000000e+001,1.50000000e+001,2.00000000e+000
				,0.00000000e+000,0,0,0,2.50000000e+002,0.00000000e+000,0,2.50000000e+002,0.00000000e+000,2.50000000e+002
				,0.00000000e+000,5,2.50000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,6.00000000e+002,0.00000000e+000,6.00000000e+002,0,2,2,0,0,1,0,0,0,0,4194304,[7651,204113920,66,512,992
				,[8,'P_CmdSrc$00$00$00$00'],[6,'RA-BAS$00$00']],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'I/O Fault$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Interlock Trip$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[14,'Failed to Stop$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[451,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'Failed to Start$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[6,'SIC401$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[8,'Agitator$00$00$00$00$00$00$00$00$00$00$00$00'
				],[20,'Variable Speed Drive$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[901782,2000,0],[-1609700761,2000,2000],0,[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[11,'Drive Fault$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],0],[3,'rpm$00$00$00$00$00'],2.50000000e+002,[911975,2000,2000],[3,'rpm$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00'],0.00000000e+000,[7,'Reverse$00$00$00$00$00$00$00$00$00'],[7,'Forward$00$00$00$00$00$00$00$00$00'
				],[-1609700761,15000,15000],[901782,15000,0],0,0,1,0,0.00000000e+000,1.00000000e-001,[-1072829849,2147483647
				,0],0.00000000e+000,[5,'P_VSD$00$00$00$00$00$00$00$00$00$00$00'],[0,0,0],[0,1,0],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],199229840,2,0,[870182,15000,0],[808479,15000,0],[6,'area01$00$00'],0,[868182
				,0,0],0.00000000e+000,2.50000000e+002,224];
		SIC401_Command_Trigger : BOOL (RADIX := Decimal) := 0;
		SIC401_Controlword_6040h : AOI_Controlword_6040h  := [19,2,6,6,0,6];
		SIC401_Drive_Fault : BOOL (RADIX := Decimal) := 0;
		SIC401_EntryStatus : DINT (RADIX := Hex) := 0;
		SIC401_FaultCodeList : P_DescList[1] (Description := "made for agaitor p_VSD block") := [[0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]]];
		SIC401_GetOdEntry : AOI_GetOdEntry  := [1,0,0,0,0,0,0];
		SIC401_intlk : P_Intlk  := [6531,0,0,0,0,0,2,[[10,'WT702 LoLo$00$00$00$00$00$00$00$00$00$00'],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],0,0,0,2,0,0,0,0,[7,'P_Intlk$00$00$00$00$00$00$00$00$00'],[10,'Interlocks$00$00$00$00$00$00$00$00$00$00'
				],[7,'P_Intlk$00$00$00$00$00$00$00$00$00$00$00$00$00'],[25,'Interlocks with First Out$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]],[6,'RA-BAS$00$00$00$00$00$00'],0,[6,'area01$00$00'],[5,'EStop$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]];
		SIC401_IO_Common : AOI_IO_Common  := [3,6,6,3,3,0,0,0,0,0,0,0,-200,-200,0,0,0,0,0,0,0,0,3,0,0,3,0,0,0,0];
		SIC401_MotorDriveSubmodeSelect_3202h : AOI_MotorDriveSubmodeSelect_3202h  := [3,0,0,0,[64,12802,0,0,0,0,0],[64,12802,0,4,0],0,0,[0,'$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				]];
		SIC401_Msg_Data_Input : SINT[100] (RADIX := Decimal) := [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
				,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		SIC401_Msg_Data_Output : SINT[100] (RADIX := Decimal) := [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
				,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		SIC401_OCmd_Stop : BOOL (RADIX := Decimal) := 0;
		SIC401_ParamsProfileVelocityMode : UDT_ParamsProfileVelocityMode  := [0,0,0,0,0,0,0,0,0];
		SIC401_Polarity_Check : BOOL (RADIX := Decimal) := 0;
		SIC401_Polarity_Check_Timer : TIMER  := [870380,1000,0];
		SIC401_Polarity_OK : BOOL (RADIX := Decimal) := 0;
		SIC401_Polarity_Set : BOOL (RADIX := Decimal) := 0;
		SIC401_Polarity_Set_Timer : TIMER  := [0,1000,0];
		SIC401_SetOdEntry : AOI_SetOdEntry  := [3,0,0,0,0];
		SIC401_SetParamsProfileVelocityMode : AOI_SetParamsProfileVelocityMode  := [3,0,0,0,[3,0,0,0,0],0,0];
		SIC401_Speed_Update_Timer : TIMER  := [901980,500,0];
		SIC401_Statusword_6041h : AOI_Statusword_6041h  := [27];
		SIC401_Velocity_Update_High_Limit : DINT (RADIX := Decimal) := 201;
		SIC401_Velocity_Update_Low_Limit : DINT (RADIX := Decimal) := 199;
		Slot1_RTD_WAGO461 : WAGO_461  := [35,1062,1062,0,0,8500,8500,0,0,[38,1024,1062,0,0,52,8448,8500,0,0],8500];
		Slot1_RTD_WAGO461_Inputs : SINT[4] (RADIX := Decimal) := [38,4,52,33];
		Slot2_AI_WAGO455 : WAGO_455 (Description := "Normalizes data received from a WAGO 750-455 4-Channel 4-20mA Analog Input Module.") := [323,0,400,10856,930,3,400,3,400,[0.00000000e+000,0.00000000e+000,1.08560000e+004,5.30078125e+002
				,3.00000000e+000,1.46484375e-001,3.00000000e+000,1.46484375e-001],[0,0,0,104,10752,10856,3,0,3,3,0
				,3]];
		Slot2_AI_WAGO455_Inputs : SINT[8] (RADIX := Decimal) := [0,0,104,42,3,0,3,0];
		Slot3_AO_WAGO559 : WAGO_559  := [3,0,0,0,0,0,0,0,0,0,0,0,0];
		Slot3_AO_WAGO559_Outputs : SINT[8] (RADIX := Decimal) := [0,0,0,0,0,0,0,0];
		Slot4_DI_WAGO432_Inputs : SINT[1] (RADIX := Decimal) := [1];
		Slot5_DO_WAGO504_Inputs : SINT[3] (RADIX := Decimal) := [0,0,0];
		Start_ConditionedMedia_Initialize : BOOL (RADIX := Decimal) := 0;
		Start_MCV_Initial_Fill : BOOL (RADIX := Decimal) := 0;
		Stop_ConditionedMedia_Initialize : BOOL (RADIX := Decimal) := 0;
		TempEUMax : REAL (RADIX := Float) := 2.00000000e+001;
		TempEUMin : REAL (RADIX := Float) := 0.00000000e+000;
		TempOffOns : BOOL (RADIX := Decimal) := 1;
		TempOnOns : BOOL (RADIX := Decimal) := 0;
		TempRawMax : REAL (RADIX := Float) := 1.00000000e+002;
		TempRawMin : REAL (RADIX := Float) := 0.00000000e+000;
		Temp_Control_On : BOOL (Description := "Temp On HMI Button$N",
		            RADIX := Decimal) := 1;
		Temp_Initialize : BOOL (RADIX := Decimal) := 1;
		Temp_Limit_Adm : REAL (RADIX := Float) := 5.00000000e+001;
		Temp_OutputLimit : REAL (RADIX := Float) := 2.00000000e+001;
		Temp_PID : PID_ENHANCED (Description := "mcv temp pid") := [1,5251080,1.74563599e+001,1.00000000e+002,0.00000000e+000,0.00000000e+000,4.00000000e+001
				,0.00000000e+000,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,1.00000000e+001,5.00000000e+000,0.00000000e+000,0.00000000e+000
				,3.40282347e+038,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038
				,0.00000000e+000,0,0.00000000e+000,1,0,0,1,16777281,0.00000000e+000,0.00000000e+000,4.00000000e+001
				,4.00000000e+001,1.74563599e+001,2.25436400e+001,2.25436400e+001,1.00000000e+000,1.00000000e+000
				,0,0,0,0.00000000e+000,1.56691599e+000,-1.74563599e+001,2.25436400e+001,2.22942638e+001,-1.74563599e+001
				,-1.77057362e+001,1.00000000e+001,8.33333358e-002,0.00000000e+000,1.00000000e+000,1.00000000e+001
				,5.00000000e+000,0.00000000e+000,0.00000000e+000,1.74563599e+001,0.00000000e+000,0.00000000e+000
				,2.25436400e+001,0.00000000e+000,2.35100692e-038,2.25436400e+001,1.74563599e+001,4.00000000e+001
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.40129846e-042,7.15555965e-039
				,0.00000000e+000,7.89211295e-042,1.00000000e+000,1.40129846e-042,7.15555965e-039,7.89211295e-042
				,1.00000000e+000];
		Temp_PID1 : PID_ENHANCED (Description := "mcv temp pid") := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
				,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
				,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				];
		Temp_PID2 : PID_ENHANCED (Description := "mcv temp pid") := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
				,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
				,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				];
		Temp_Scaler : SCALE  := [1,0.00000000e+000,1.00000000e+002,0.00000000e+000,2.00000000e+001,0.00000000e+000,1,0.00000000e+000
				,0,0.00000000e+000,1.00000000e+002,9.99999978e-003,0.00000000e+000];
		Ten_Sec_Buffer : TIMER  := [0,10000,0];
		test_BOOL : BOOL (RADIX := Decimal) := 0;
		test_COUNT : COUNTER  := [536870912,0,9];
		test_DINT : SINT[32] (RADIX := Decimal) := [3,0,6,0,0,0,0,0,0,0,0,0,56,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		Test_New_Speed : REAL (RADIX := Float) := 0.00000000e+000;
		Test_Temp_Raw : REAL (RADIX := Float) := 9.50000000e+001;
		TOT101 : TOTALIZER  := [33,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,243,5.68041600e+003,8.21732578e+004,1.00000000e-001
				,0,1.40129846e-043,7.15668209e-039,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,1.43773222e-042,8.33333377e-003,0.00000000e+000,5.69340992e+000,-1.35717876e-032];
		TOT1011 : TOTALIZER  := [33,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,243,7.85445078e+004,9.31750000e+003,1.00000000e-001
				,0,1.40129846e-043,5.25834382e-035,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,1.43773222e-042,8.33333377e-003,0.00000000e+000,7.59924698e+000,7.56556276e-016];
		TOT1012 : TOTALIZER  := [33,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,243,7.85445078e+004,9.31750000e+003,1.00000000e-001
				,0,1.40129846e-043,5.25834382e-035,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,1.43773222e-042,8.33333377e-003,0.00000000e+000,7.59924698e+000,7.56556276e-016];
		TOT1013 : TOTALIZER  := [33,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,243,7.85445078e+004,9.31750000e+003,1.00000000e-001
				,0,1.40129846e-043,5.25834382e-035,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,1.43773222e-042,8.33333377e-003,0.00000000e+000,7.59924698e+000,7.56556276e-016];
		TOT102 : TOTALIZER  := [33,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,243,5.45211289e+004,0.00000000e+000,1.00000000e-001
				,0,1.40129846e-043,7.15626170e-039,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,1.43773222e-042,8.33333377e-003,0.00000000e+000,7.33192635e+000,4.86850144e-015];
		TOT1021 : TOTALIZER  := [1,0.00000000e+000,0,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.60519386e-045,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000];
		TOT1022 : TOTALIZER  := [1,0.00000000e+000,0,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.60519386e-045,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000];
		TOT1023 : TOTALIZER  := [1,0.00000000e+000,0,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.60519386e-045,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000];
		TOT103 : TOTALIZER  := [21,3.66535187e+001,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,119,1.95237734e+004,5.51070650e+006,1.00000000e-001
				,0,1.40129846e-043,7.15612157e-039,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,7.20267411e-043,8.33333377e-003,3.66535187e+001,6.59581800e+000,-9.10598191e-035];
		TOT104 : TOTALIZER  := [21,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,247,4.93548400e+006,0.00000000e+000,1.00000000e-001
				,0,1.40129846e-043,7.15640183e-039,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,7.20267411e-043,8.33333377e-003,0.00000000e+000,1.31767100e+001,-5.79318026e+031];
		TOT105 : TOTALIZER  := [33,0.00000000e+000,1,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
				,0.00000000e+000,0,0.00000000e+000,1,0,243,2.93215969e+005,0.00000000e+000,1.00000000e-001
				,0,1.40129846e-043,7.15668209e-039,0.00000000e+000,7.89211295e-042,1.00000000e-001,0.00000000e+000
				,1.43773222e-042,8.33333377e-003,0.00000000e+000,9.11852932e+000,-4.16349900e+020];
		TotalFlowSP : REAL (RADIX := Float) := 2.00000000e+000;
		Total_Gas_Alm_HiDev : BOOL (RADIX := Decimal) := 0;
		Total_Gas_Alm_LoDev : BOOL (RADIX := Decimal) := 0;
		Total_Gas_Dev_Timer : TIMER (Description := "Time for Deviation to be Present before Alarm is Triggered") := [1533285,10000,0];
		Total_Gas_Flow_Limit : REAL (RADIX := Float) := 3.00000000e+000;
		Total_Gas_HiDev : REAL (RADIX := Float) := 5.00000000e-002;
		Total_Gas_HiDev_Limit : REAL (RADIX := Float) := 2.04999995e+000;
		Total_Gas_LoDev : REAL (RADIX := Float) := 5.00000000e-002;
		Total_Gas_LoDev_Limit : REAL (RADIX := Float) := 1.95000000e+000;
		Total_Gas_Val_Pos : REAL (RADIX := Float) := 2.00000000e+000;
		TT700 : P_AInAdv (Description := "Temperature Transmitter") := [134217987,1.06200000e+003,0,0,2,9.92000000e+002,1.39300000e+003,0.00000000e+000,1.00000000e+002
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,4.50000000e+001
				,0.00000000e+000,4.00000000e+001,0.00000000e+000,3.50000000e+001,0.00000000e+000,3.00000000e+001
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,5.00000000e+000,1.00000000e+000,-5.00000000e+000
				,1.00000000e+000,1.40000000e+003,9.00000000e+002,4.16666657e-001,1.74563599e+001,1.74563599e+001
				,1.74563599e+001,1.74563599e+001,0.00000000e+000,1.74563599e+001,1.69576054e+001,1.77057362e+001
				,0.00000000e+000,1.00000000e+002,1,1,24,7,4,2360964,[76547031,750,0,5,7,0,0,[-1609700261,5000,5000],[-1609700261
				,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[76547031,500,0,5,5,0
				,0,[-1609700261,5000,5000],[-1609700261,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,1,0,0,[54946,5000,0],[-1609700261,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,1000,0,5,1,0,0,[54946,5000,0],[-1609700261,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[1,'C$00$00$00$00$00$00$00'],[5,'TT700$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[14
				,'Temperature PV$00$00$00$00$00$00'],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],7,0,24,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.74563599e+001,1.01000000e-001
				,1.74563599e+001,0.00000000e+000,1.69576054e+001,[963,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[967,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072829349,2147483647,0],0.00000000e+000,1149550592,1099671200,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[2508553,0,0],[-1609700261,0
				,0],[16,'PV Deviation Low$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261
				,0,0],[0,0,0],[-1609700261,0,0],[20,'PV Hi Rate of Change'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[2123891
				,0,0],[-1609700261,0,0],[-1609700261,0,0],[17,'PV Deviation High$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[2979181,0,0],[-1609700261,0,0],[-1609700261,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[2976381,0,0],[-1609700261,0,0],[-1609700261
				,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6
				,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[54946,0,0],[-1609700261,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261,0,0],[54946,0,0],[-1609700261,0,0
				],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700261
				,0,0],[54946,0,0],[-1609700261,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'area01$00$00'],4,7,1.06200000e+003];
		TT700_1Point_Complete : BOOL (RADIX := Decimal) := 0;
		TT700_1Point_Offset : REAL (RADIX := Float) := 4.54364014e+000;
		TT700_1Point_Running : BOOL (RADIX := Decimal) := 0;
		TT700_2PointAccept : BOOL (RADIX := Decimal) := 0;
		TT700_2Point_Complete : BOOL (RADIX := Decimal) := 0;
		TT700_Accept1Point : BOOL (RADIX := Decimal) := 0;
		TT700_CalClear : BOOL (RADIX := Decimal) := 0;
		TT700_MaxCfg : REAL (RADIX := Float) := 1.00000000e+002;
		TT700_MinCfg : REAL (RADIX := Float) := 0.00000000e+000;
		TT700_NewMax : REAL (RADIX := Float) := 8.70000000e+001;
		TT700_NewMin : REAL (RADIX := Float) := -1.30000000e+001;
		TT700_RawMax : REAL (RADIX := Float) := 9.50000000e+001;
		TT700_RawMin : REAL (RADIX := Float) := 5.00000000e+000;
		TT700_RawRange : REAL (RADIX := Float) := 9.00000000e+001;
		TT700_Ref1Point : REAL (RADIX := Float) := 2.20000000e+001;
		TT700_RefMax : REAL (RADIX := Float) := 8.50000000e+001;
		TT700_RefMin : REAL (RADIX := Float) := 1.00000000e+001;
		TT700_RefRange : REAL (RADIX := Float) := 7.50000000e+001;
		VPN_Toggle : BOOL (RADIX := Decimal) := 0;
		WT701 : P_AInAdv (Description := "Media Scale, Mettler-Toledo 60kg") := [134217731,6.33500000e+000,0,0,2,0.00000000e+000,6.00000000e+001,0.00000000e+000,6.00000000e+001
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,5.00000000e+001
				,0.00000000e+000,4.00000000e+001,0.00000000e+000,1.00000000e+001,0.00000000e+000,5.00000000e+000
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,6.00000000e+000,1.00000000e+000,-6.00000000e+000
				,1.00000000e+000,6.10000000e+001,-2.08333325e+000,4.16666657e-001,6.33500000e+000,6.33500000e+000
				,6.33500000e+000,6.33500000e+000,0.00000000e+000,0.00000000e+000,6.33500000e+000,6.33799982e+000
				,0.00000000e+000,6.00000000e+001,1,1,20,5,4,2360324,[92275667,750,0,5,1,0,0,[3132285,5000,0],[-1609700661
				,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[76547031,500,0,5,5,0
				,0,[-1609700661,5000,5000],[-1609700661,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,1,0,0,[1664891,5000,0],[-1609700661,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,750,0,5,1,0,0,[1664891,5000,0],[-1609700661,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[2,'kg$00$00$00$00$00$00'],[5,'WT701$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[15,'Media Weight PV$00$00$00$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],5,0,20,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,6.33500000e+000,1.00000000e-001
				,6.33500000e+000,0.00000000e+000,6.33699989e+000,[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072829749,2147483647,0],0.00000000e+000,1087027282,1087027282,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700661,0,0],[0,0,0],[-1609700661,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700661,0,0],[0,0,0],[-1609700661,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700661,0,0],[0,0,0],[-1609700661,0,0],[17,'PV Deviation High$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700661,0,0],[3132285,0,0],[-1609700661
				,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[442698
				,0,0],[-1609700661,0,0],[-1609700661,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700661,0,0],[1664891,0,0],[-1609700661,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700661,0,0],[1664891,0,0],[-1609700661
				,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700661
				,0,0],[0,0,0],[-1609700661,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'area01$00$00'],4,5,6.33500000e+000];
		WT701_Tare_ACK : BOOL (RADIX := Decimal) := 0;
		WT701_Tare_Success : BOOL (RADIX := Decimal) := 0;
		WT701_Zero_ACK : BOOL (RADIX := Decimal) := 0;
		WT701_Zero_DONE : BOOL (RADIX := Decimal) := 0;
		WT701_Zero_Timer : TIMER  := [1852175,5000,0];
		WT702 : P_AInAdv (Description := "MCV Weight, Hardy 30kg") := [134217731,2.52999973e+000,0,0,2,0.00000000e+000,3.00000000e+001,0.00000000e+000,3.00000000e+001
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,2.50000000e+001
				,0.00000000e+000,2.00000000e+001,0.00000000e+000,5.00000000e+000,0.00000000e+000,1.00000000e+000
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,3.00000000e+000,1.00000000e+000,-3.00000000e+000
				,1.00000000e+000,3.10000000e+001,-2.08333325e+000,4.16666657e-001,2.52999973e+000,2.52999973e+000
				,2.52999973e+000,2.52999973e+000,0.00000000e+000,0.00000000e+000,1.26999998e+000,2.52999973e+000
				,0.00000000e+000,3.00000000e+001,1,1,20,5,4,2360324,[92275667,750,0,5,1,0,0,[797698,5000,0],[-1609701061
				,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[76547031,500,0,5,5,0
				,0,[-1609701061,5000,5000],[-1609701061,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,1,0,0,[3108930,5000,0],[-1609701061,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,750,0,5,1,0,0,[1705491,5000,0],[-1609701061,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[2,'kg$00$00$00$00$00$00'],[5,'WT702$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'MCV Weight PV$00$00$00$00$00$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],5,0,20,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,2.52999973e+000,1.00000000e-001
				,2.52999973e+000,0.00000000e+000,1.26999998e+000,[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072830149,2147483647,0],0.00000000e+000,1075964804,1075964804,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[0,0,0],[-1609701061,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[0,0,0],[-1609701061,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[0,0,0],[-1609701061,0,0],[17,'PV Deviation High$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[794499,0,0],[-1609701061,0
				,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[3031181
				,0,0],[-1609701061,0,0],[-1609701061,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[1705491,0,0],[-1609701061,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061,0,0],[3108930,0,0],[-1609701061
				,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609701061
				,0,0],[1279389,0,0],[-1609701061,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'area01$00$00'],4,5,2.52999973e+000];
		WT702_AD_Error : BOOL (RADIX := Decimal) := 0;
		WT702_AD_Error_Timer : TIMER  := [0,5000,0];
		WT702_Message_Timer : TIMER  := [0,5000,0];
		WT702_Motion_Error : BOOL (RADIX := Decimal) := 0;
		WT702_Motion_Error_Timer : TIMER  := [0,5000,0];
		WT702_Out_Tolerance : BOOL (RADIX := Decimal) := 0;
		WT702_Tare_ACK : BOOL (RADIX := Decimal) := 0;
		WT702_Tare_Success : BOOL (RADIX := Decimal) := 0;
		WT702_Tolerance_Timer : TIMER  := [0,5000,0];
		WT702_Zero_ACK : BOOL (RADIX := Decimal) := 0;
		WT702_Zero_DONE : BOOL (RADIX := Decimal) := 0;
		WT702_Zero_DONE_Timer : TIMER  := [1893789,5000,0];
		WT702_Zero_In_Progress : BOOL (RADIX := Decimal) := 0;
		WT702_Zero_Timer : TIMER  := [0,5000,0];
		WT703 : P_AInAdv (Description := "Spent Media/Harvest Scale, Mettler-Toledo 60kg") := [134217731,1.07000005e+000,0,0,2,0.00000000e+000,6.00000000e+001,0.00000000e+000,6.00000000e+001
				,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+002,1.00000000e+000,1.00000000e+002
				,1.00000000e+000,0.00000000e+000,1.00000000e+000,0.00000000e+000,1.00000000e+000,5.00000000e+001
				,0.00000000e+000,4.50000000e+001,0.00000000e+000,5.00000000e+000,0.00000000e+000,1.00000000e+000
				,0.00000000e+000,1.00000000e+002,1.00000000e+000,6.00000000e+000,1.00000000e+000,-6.00000000e+000
				,1.00000000e+000,6.10000000e+001,-2.08333325e+000,4.16666657e-001,1.07000005e+000,1.07000005e+000
				,1.07000005e+000,1.07000005e+000,0.00000000e+000,0.00000000e+000,1.05200000e+000,1.07000005e+000
				,0.00000000e+000,6.00000000e+001,1,1,20,5,2,2360324,[92275667,750,0,5,1,0,0,[2089898,5000,0],[-1609700161
				,5000,5000],[0,0,0],0,288,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13,'Low-Low Alarm$00$00$00$00$00$00$00'
				],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'],4],[76547031,500,0,5,5,0
				,0,[-1609700161,5000,5000],[-1609700161,5000,5000],[0,0,0],0,289,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[9,'Low Alarm$00$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],4],[92275667,500,0,5,0,0,0,[1769291,5000,0],[3134781,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[10,'High Alarm$00$00$00$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[92275667,750,0,5,0,0,0,[3187885,5000,0],[3128781,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[15,'High-High Alarm$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[2,'kg$00$00$00$00$00$00'],[5,'WT703$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[18,'Spent Media Weight$00$00'
				],[21,'Advanced Analog Input$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[963,1000,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[13
				,'Input Failure$00$00$00$00$00$00$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],5,0,20,1,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.07000005e+000,1.00000000e-001
				,1.07000005e+000,0.00000000e+000,1.05900000e+000,[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'
				],[19,'Low Deviation Alarm$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[20
				,'High Deviation Alarm'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[451,500,0,5,0,0,0,[0,5000,0],[0,5000,0],[0,0,0],0,290,[7,'P_Alarm$00$00$00$00$00$00$00$00$00$00$00$00$00'],[19
				,'High Rate of Change$00'],0,[6,'RA-BAS$00$00$00$00$00$00'],[7,'P_Alarm$00$00$00$00$00$00$00$00$00'
				],0],[-1072829249,2147483647,0],0.00000000e+000,1065940419,1065940419,[8,'P_AInAdv$00$00$00$00$00$00$00$00'
				],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700161,0,0],[0,0,0],[-1609700161,0,0],[16,'PV Deviation Low$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700161,0,0],[0,0,0],[-1609700061,0,0],[20,'PV Hi Rate of Change'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700061,0,0],[0,0,0],[-1609700061,0,0],[17,'PV Deviation High$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700061,0,0],[2089898,0,0],[-1609700061
				,0,0],[10,'PV Low-Low$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[63,0.00000000e+000,0.00000000e+000,0.00000000e+000,[3255781
				,0,0],[-1609700061,0,0],[-1609700061,0,0],[6,'PV Low$00$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000
				,0.00000000e+000,0.00000000e+000,[-1609700061,0,0],[3187885,0,0],[-1609700061,0,0],[12,'PV High-High$00$00$00$00$00$00$00$00'
				],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'
				],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700061,0,0],[1769291,0,0],[-1609700061
				,0,0],[7,'PV High$00$00$00$00$00$00$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'
				],[16,'Gating Condition$00$00$00$00'],0],[43,0.00000000e+000,0.00000000e+000,0.00000000e+000,[-1609700061
				,0,0],[0,0,0],[-1609700061,0,0],[13,'Input Failure$00$00$00$00$00$00$00'],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'P_Gate$00$00$00$00$00$00$00$00$00$00'],[16,'Gating Condition$00$00$00$00'],0],[6,'RA-BAS$00$00$00$00$00$00'
				],[6,'area01$00$00'],2,5,1.07000005e+000];
		WT703_Tare_ACK : BOOL (RADIX := Decimal) := 0;
		WT703_Tare_Success : BOOL (RADIX := Decimal) := 0;
		WT703_Zero_ACK : BOOL (RADIX := Decimal) := 0;
		WT703_Zero_DONE : BOOL (RADIX := Decimal) := 0;
		WT703_Zero_Timer : TIMER  := [1462297,5000,0];
		zero : STRING  := [1,'0$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00$00'
				];
		Zero_Real : REAL (RADIX := Float) := 0.00000000e+000;
		SIC401_GetOdEntry_MSG : MESSAGE (MessageType := Unconfigured,
		                               RequestedLength := 1,
		                               CommTypeCode := 0,
		                               LocalIndex := 0);
		SIC401_SetODEntry_MSG : MESSAGE (MessageType := Unconfigured,
		                               RequestedLength := 1,
		                               CommTypeCode := 0,
		                               LocalIndex := 0);
	END_TAG

	PROGRAM CM_PBS (MAIN := "Main",
	                MODE := 0,
	                DisableFlag := 0,
	                UseAsFolder := 0)
		TAG
			BOR_01 : FBD_BOOLEAN_OR  := [1,0,5.60519386e-045];
			SCL_01 : SCALE  := [1,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
					,0,5.60519386e-045,0.00000000e+000,0.00000000e+000,0.00000000e+000];
			SEL_01 : SELECT  := [1,0.00000000e+000,1.00000000e+002,1,0.00000000e+000,5.60519386e-045];
			SEL_02 : SELECT  := [1,0.00000000e+000,0.00000000e+000,1,0.00000000e+000,5.60519386e-045];
			SEL_03 : SELECT  := [1,0.00000000e+000,0.00000000e+000,1,0.00000000e+000,5.60519386e-045];
			SEL_04 : SELECT  := [1,0.00000000e+000,0.00000000e+000,1,0.00000000e+000,5.60519386e-045];
			TOT_01 : TOTALIZER  := [1,0.00000000e+000,0,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0,0.00000000e+000,1,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.60519386e-045,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000];
			TOT_02 : TOTALIZER  := [1,0.00000000e+000,0,1.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0,0.00000000e+000,1,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,5.60519386e-045,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000];
		END_TAG

		ROUTINE Brx_Comms 
				N: XIC(BRX_Comm_Toggle)XIO(Brx_heartbeat_Alarm)TON(BRX_Heartbeat_Fail,?,?);
				N: XIC(BRX_Comm_Toggle)XIC(PBSData.exchangeHeartbeat)ONS(ONS[0].9)MOV(0,BRX_Heartbeat_Fail.ACC);
				N: XIC(BRX_Comm_Toggle)XIC(BRX_Heartbeat_Fail.DN)OTL(Brx_heartbeat_Alarm);
				N: XIC(BRX_Comm_Toggle)XIC(Brx_Heartbeat_Alarm_Reset)OTU(Brx_heartbeat_Alarm);
				N: XIC(BRX_Comm_Toggle)XIC(PBSData.jsonFailure)[TON(JSON_Fail_Timer,?,?) ,XIC(JSON_Fail_Timer.DN) OTE(Json_Alarm) ];
				N: XIO(BRX_Comm_Toggle)OTU(Brx_heartbeat_Alarm);
				N: [XIC(Brx_heartbeat_Alarm) ,XIC(Json_Alarm) ]OTE(Comm_Loss_Stop);
		END_ROUTINE

		ROUTINE CM_Agitator 
				N: [[XIC(WT702.Alm_LoLo) OTE(SIC401_intlk.Inp_Intlk00) ,XIC(Estop_Active_Flag) OTE(SIC401_intlk.Inp_Intlk01) ,XIC(SIC401_Drive_Fault) OTE(SIC401_intlk.Inp_Intlk02) ,P_Intlk(SIC401_intlk) ,XIC(SIC401_intlk.Sts_IntlkOK) OTE(SIC401.Inp_IntlkOK) ] ,P_VSD(SIC401,SIC401_FaultCodeList) ];
		END_ROUTINE

		ROUTINE CM_AI 
				RC: "=====================================================================$N"
				    "TT700$N"
				    "=====================================================================";
				N: [MOV(Slot1_RTD_WAGO461.Ch1_Temp_degCx10,TT700.Inp_PV) ,P_AInAdv(TT700) ];
				N: [MOV(DO_Normalized,AT701.Inp_PV) ,P_AInAdv(AT701) ];
				N: [MOV(pH_Normalized,AT702.Inp_PV) ,P_AInAdv(AT702) ];
				N: [MOV(PBSData.level_pv,LIT801.Inp_PV) ,P_AInAdv(LIT801) ];
				N: P_AInAdv(WT701);
				N: P_AInAdv(WT703);
				N: [P_AInAdv(WT702) ,AFI() OTE(WT702.Inp_PVBad) ,AFI() OTE(WT702.Inp_PVUncertain) ,MOV(MCV_Scale:I.Net_Weight,WT702.Inp_PV) ,XIC(WT702_Zero_ACK) MOV(1,MCV_Scale:O.Command) ,XIC(WT702_Tare_ACK) MOV(2,MCV_Scale:O.Command) ,AFI() EQU(MCV_Scale:I.Command_Status,65535) OTE(WT702_Zero_In_Progress) ,[AFI() EQU(MCV_Scale:I.Command_Status,0) ,[EQU(2,MCV_Scale:O.Command) ,EQU(1,MCV_Scale:O.Command) ] EQU(WT702.Inp_PV,0) ] [OTE(WT702_Zero_DONE) ,TON(WT702_Zero_DONE_Timer,?,?) ,XIC(WT702_Zero_DONE_Timer.DN) MOV(0,MCV_Scale:O.Command) ] ,AFI() EQU(MCV_Scale:I.Command_Status,1) [TON(WT702_Motion_Error_Timer,?,?) ,XIO(WT702_Zero_Timer.DN) OTE(WT702_Motion_Error) ] ,AFI() EQU(MCV_Scale:I.Command_Status,2) [TON(WT702_AD_Error_Timer,?,?) ,XIO(WT702_AD_Error_Timer.DN) OTE(WT702_AD_Error) ] ,AFI() EQU(MCV_Scale:I.Command_Status,3) [TON(WT702_Tolerance_Timer,?,?) ,XIO(WT702_Tolerance_Timer.DN) OTE(WT702_Out_Tolerance) ] ];
				N: [MOV(PBSData.do_pv,AIC703.Inp_PV) ,P_AInAdv(AIC703) ];
		END_ROUTINE

		ROUTINE CM_AO 
				N: [MOV(Temp_Limit_Adm,Heater_Output.Cfg_MaxCV) MOV(Temp_Limit_Adm,Heater_Output.Cfg_CVEUMax) MOV(Temp_Scaler.Out,Heater_Output.PSet_CV) ,[[XIC(SIC401_Drive_Fault) ,XIC(SIC401_Drive:I1.Data[0].7) ] OTE(Heater_Output_intlk.Inp_Intlk00) ,XIC(TT700.Alm_HiHi) OTE(Heater_Output_intlk.Inp_Intlk01) ,XIC(EStop.Alm_TgtDisagree) OTE(Heater_Output_intlk.Inp_Intlk02) ,P_Intlk(Heater_Output_intlk) ,XIC(Heater_Output_intlk.Sts_IntlkOK) OTE(Heater_Output.Inp_IntlkOK) ,XIO(Heater_Output.Inp_IntlkOK) OTL(Temp_Initialize) ] ,P_AOut(Heater_Output) ];
		END_ROUTINE

		ROUTINE CM_DI 
				N: XIC(Wago_IO:I1.Data[0].0)[OTE(EStop.Inp_PV) ,P_DIn(EStop) ];
				N: XIO(EStop.Inp_PV)OTE(Estop_Active_Flag);
				N: XIO(Estop_Active_Flag)TON(Estop_Restart_Delay,?,?);
		END_ROUTINE

		ROUTINE CM_DO 
				N: XIC(VPN_Toggle)OTE(Wago_IO:O1.Data[0].3);
		END_ROUTINE

		FBD_ROUTINE CM_Totalizers (Description := "Totalizers",
		                           SheetSize := "Tabloid - 11 x 17 in",
		                           SheetOrientation := Landscape)
			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 260,
				       Y := 100,
				       Operand := "P101.Val_SpeedFdbk",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 560,
				       Y := 240,
				       Operand := "P101_Status_Code.In_Position",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 240,
				       Y := 220,
				       Operand := "P101_Status_Code.Moving",
				       HideDescription := No)
				END_IREF

				TOT_BLOCK  (ID := 3,
				            X := 760,
				            Y := 100,
				            Operand := "TOT101",
				            VisiblePins := "In, ProgProgReq, ProgOperReq, ProgStartReq, ProgStopReq, ProgResetReq, Total, OldTotal, ProgOper, RunStop, ProgResetDone, TargetFlag, TargetDev1Flag, TargetDev2Flag",
				            HideDescription := No)
				END_TOT_BLOCK

				BNOT_FUNCTION  (ID := 4,
				                X := 500,
				                Y := 280)
				END_BNOT_FUNCTION

				BAND_FUNCTION  (ID := 5,
				                X := 600,
				                Y := 240)
				END_BAND_FUNCTION

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 5,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgProgReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgStartReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 4,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "Out",
				       ToElementID := 5,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "Out",
				       ToElementID := 3,
				       ToParameter := "ProgStopReq")
				END_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 240,
				       Y := 60,
				       Operand := "P102.Val_SpeedFdbk",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 540,
				       Y := 200,
				       Operand := "P102_Status_Code.In_Position",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 220,
				       Y := 180,
				       Operand := "P102_Status_Code.Moving",
				       HideDescription := No)
				END_IREF

				TOT_BLOCK  (ID := 3,
				            X := 740,
				            Y := 60,
				            Operand := "TOT102",
				            VisiblePins := "In, ProgProgReq, ProgOperReq, ProgStartReq, ProgStopReq, ProgResetReq, Total, OldTotal, ProgOper, RunStop, ProgResetDone, TargetFlag, TargetDev1Flag, TargetDev2Flag",
				            HideDescription := No)
				END_TOT_BLOCK

				BNOT_FUNCTION  (ID := 4,
				                X := 480,
				                Y := 240)
				END_BNOT_FUNCTION

				BAND_FUNCTION  (ID := 5,
				                X := 580,
				                Y := 200)
				END_BAND_FUNCTION

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 5,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgProgReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgStartReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 4,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "Out",
				       ToElementID := 5,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "Out",
				       ToElementID := 3,
				       ToParameter := "ProgStopReq")
				END_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 260,
				       Y := 60,
				       Operand := "P103.Val_SpeedFdbk",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 560,
				       Y := 200,
				       Operand := "P103_Status_Code.In_Position",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 240,
				       Y := 180,
				       Operand := "P103_Status_Code.Moving",
				       HideDescription := No)
				END_IREF

				TOT_BLOCK  (ID := 3,
				            X := 760,
				            Y := 60,
				            Operand := "TOT103",
				            VisiblePins := "In, ProgProgReq, ProgOperReq, ProgStartReq, ProgStopReq, ProgResetReq, Total, OldTotal, ProgOper, RunStop, ProgResetDone, TargetFlag, TargetDev1Flag, TargetDev2Flag",
				            HideDescription := No)
				END_TOT_BLOCK

				BNOT_FUNCTION  (ID := 4,
				                X := 500,
				                Y := 240)
				END_BNOT_FUNCTION

				BAND_FUNCTION  (ID := 5,
				                X := 600,
				                Y := 200)
				END_BAND_FUNCTION

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 5,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgProgReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgStartReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 4,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "Out",
				       ToElementID := 5,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "Out",
				       ToElementID := 3,
				       ToParameter := "ProgStopReq")
				END_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 260,
				       Y := 60,
				       Operand := "P104.Val_SpeedFdbk",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 560,
				       Y := 200,
				       Operand := "P104_Status_Code.In_Position",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 240,
				       Y := 180,
				       Operand := "P104_Status_Code.Moving",
				       HideDescription := No)
				END_IREF

				TOT_BLOCK  (ID := 3,
				            X := 760,
				            Y := 60,
				            Operand := "TOT104",
				            VisiblePins := "In, ProgProgReq, ProgOperReq, ProgStartReq, ProgStopReq, ProgResetReq, Total, OldTotal, ProgOper, RunStop, ProgResetDone, TargetFlag, TargetDev1Flag, TargetDev2Flag",
				            HideDescription := No)
				END_TOT_BLOCK

				BNOT_FUNCTION  (ID := 4,
				                X := 500,
				                Y := 240)
				END_BNOT_FUNCTION

				BAND_FUNCTION  (ID := 5,
				                X := 600,
				                Y := 200)
				END_BAND_FUNCTION

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 5,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgProgReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 3,
				       ToParameter := "ProgStartReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 4,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "Out",
				       ToElementID := 5,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "Out",
				       ToElementID := 3,
				       ToParameter := "ProgStopReq")
				END_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 520,
				       Y := 280,
				       Operand := "P105.Sts_JoggingFwd",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 520,
				       Y := 300,
				       Operand := "P105.Sts_JoggingRev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 520,
				       Y := 240,
				       Operand := "P105.Sts_RunningFwd",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 3,
				       X := 520,
				       Y := 260,
				       Operand := "P105.Sts_RunningRev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 4,
				       X := 800,
				       Y := 300,
				       Operand := "P105.Sts_Stopped",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 5,
				       X := 740,
				       Y := 160,
				       Operand := "P105.Val_SpeedFdbk",
				       HideDescription := No)
				END_IREF

				BOR_BLOCK  (ID := 6,
				            X := 580,
				            Y := 180,
				            Operand := "BOR_5",
				            VisiblePins := "In1, In2, In3, In4, Out",
				            HideDescription := No)
				END_BOR_BLOCK

				TOT_BLOCK  (ID := 7,
				            X := 820,
				            Y := 160,
				            Operand := "TOT105",
				            VisiblePins := "In, ProgProgReq, ProgOperReq, ProgStartReq, ProgStopReq, ProgResetReq, Total, OldTotal, ProgOper, RunStop, ProgResetDone, TargetFlag, TargetDev1Flag, TargetDev2Flag",
				            HideDescription := No)
				END_TOT_BLOCK

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 6,
				       ToParameter := "In3")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 6,
				       ToParameter := "In4")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 6,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 3,
				       FromParameter := "",
				       ToElementID := 6,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "",
				       ToElementID := 7,
				       ToParameter := "ProgStopReq")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "",
				       ToElementID := 7,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "Out",
				       ToElementID := 7,
				       ToParameter := "ProgProgReq")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "Out",
				       ToElementID := 7,
				       ToParameter := "ProgStartReq")
				END_WIRE

			END_SHEET

		END_FBD_ROUTINE

		ROUTINE Conditioned_Addition_Control 
				RC: "Scales user input (s --> ms) and moves to relevant timer";
				N: CPT(MCV_HiAdjTimer.PRE,MCV_HiAdjTimeSP * 1000)CPT(BRX_HiAdjTimer.PRE,BRX_HiadjTimeSP * 1000)CPT(BRX_LoAdjTimer.PRE,BRX_LoadjTimeSP * 1000);
				RC: "Any State above 10 means Active Media Adjustment";
				N: [GRT(MCV_HiAdj_State,10) ,GRT(BRX_HiAdj_State,10) ,GRT(BRX_LoAdj_State,10) ]OTE(CondMed_AdjustInProgress);
				N: XIC(Start_ConditionedMedia_Initialize)[OTL(ConditionedMedia_Initialize) ,OTE(P103.PCmd_Lock) OTE(P104.PCmd_Lock) ];
				N: [XIC(Stop_ConditionedMedia_Initialize) ,XIC(Estop_Active_Flag) ,XIC(Comm_Loss_Stop) ,XIO(P103.Inp_IntlkOK) ,XIO(P104.Inp_IntlkOK) ][OTU(ConditionedMedia_Initialize) ,OTE(P103.PCmd_Unlock) OTE(P104.PCmd_Unlock) ];
				RC: "When the Media and BRX Vessel Values are withing the Adjustment SP, then the pumps will be driven by the PID.$N"
				    "The GRT and EQU rungs are to make the grahics work. Probably a better way to do that system wide, instead of here fot only this process.";
				N: XIC(ConditionedMedia_Initialize)XIO(P103_Cal.Cal_Running)XIO(P104_Cal.Cal_Running)[OTE(ConditionedMedia_Running) ,XIO(CondMed_AdjustInProgress) [LES(WT702.Val,MCV_HiSP) ,XIO(MCV_HiAdjEnable) ] [GRT(LIT801.Val,BRX_LoSP) ,XIO(BRX_LoAdjEnable) ] [LES(LIT801.Val,BRX_HiSP) ,XIO(BRX_HiAdjEnable) ] OTE(ConditionedMedia_NoAdjust_Speed) ];
		END_ROUTINE

		ROUTINE DO_CAL (Description := "STATE MACHINE FOR DO CAL")
				RC: "Set odo cal state engine to Enable EEPROM$N"
				    "";
				N: XIC(do_cal_start)[MOV(10,do_cal_state_var) ,OTU(do_cal_start) OTU(do_cal_reset) ,COP(NULL_String,do_cal_done_date,9) ];
				N: XIC(do_cal_reset)[MOV(0,do_cal_state_var) ,MOV(16#0002,do_w_cal_control) ,COP(NULL_String,do_cal_done_date,9) ,OTU(do_cal_start) OTU(do_cal_reset) ];
				RC: "oDO Cal State: Idle/reset params$N"
				    "";
				N: EQU(do_cal_state_var,0)[OTE(do_cal_b_0_idle) ,MOV(0,do_w_cal_control) ,MOV(0,do_w_cal_offset) ,MOV(0,do_w_cal_slope) ,MOV(0,do_w_cal_process) ,MOV(12,do_w_user_level) ,MOV(16#01145DEA,do_w_user_password) ,MOV(0,do_w_cal_unit_cal) ,MOV(1,do_w_cal_stability) ,MOV(1,do_w_cal_buffer_tab) ,MOV(0,do_w_cal_pressure) ,MOV(0,do_w_cal_humidity) ,MOV(0,do_w_cal_date) ,MOV(0,do_w_cal_time) ,NEQ(2,do_r_cal_method) NEQ(32,do_r_cal_method) MOV(32,do_w_cal_method) ];
				RC: "oDO Cal State: Set User Level to 1$N"
				    "";
				N: EQU(do_cal_state_var,10)[OTE(do_cal_b_10_set_user2) ,MOV(16#0000000C,do_w_user_level) ,MOV(16#01145DEA,do_w_user_password) ,MOV(20,do_cal_state_var) ];
				RC: "Check User Level is 1";
				N: EQU(do_cal_state_var,20)[OTE(do_cal_b_20_set_user2_ack) ,EQU(do_r_user_level,12) MOV(30,do_cal_state_var) ];
				RC: "oDO Cal State: Set params for Calibration";
				N: EQU(do_cal_state_var,30)[OTE(do_cal_b_30_set_pt1_params) ,TON(do_cal_b_30_set_pt1_params_Timer,?,?) ,MOV(do_w_cal_offset_input,do_w_cal_offset) ,MOV(do_w_cal_slope_input,do_w_cal_slope) ,MOV(do_w_cal_process_input,do_w_cal_process) ,MOV(16#00040009,do_w_cal_unit_cal) ,MOV(16#01,do_w_cal_stability) ,MOV(16#0001,do_w_cal_buffer_tab) ,MOV(1013,do_w_cal_pressure) ,MOV(50,do_w_cal_humidity) ,MOV(16#18092023,do_w_cal_date) ,MOV(16#00001022,do_w_cal_time) ,XIC(do_cal_b_30_set_pt1_params_Timer.DN) MOV(40,do_cal_state_var) ];
				RC: "Check Parmeters are Pushed to Probe. TBD Later.";
				N: EQU(do_cal_state_var,40)[[OTE(do_cal_b_40_check_params) ,TON(do_cal_b_40_check_params_Timer,?,?) ] ,EQU(do_w_cal_slope,do_r_cal_slope) EQU(do_w_cal_offset,do_r_cal_offset) EQU(do_w_cal_process,do_r_cal_process) XIC(do_cal_b_40_check_params_Timer.DN) MOV(50,do_cal_state_var) ];
				RC: "Proceed to 2-Point Cal or Jump to 1-Point Cal";
				N: EQU(do_cal_state_var,50)[OTE(do_cal_b_50_cal_method) ,EQU(2,do_r_cal_method) MOV(60,do_cal_state_var) ,EQU(32,do_r_cal_method) MOV(150,do_cal_state_var) ];
				RC: "Acknowledge when Probe is in place and start Cal";
				N: EQU(do_cal_state_var,60)[OTE(do_cal_b_60_place_probe) ,XIC(do_probe_placement_ready) MOV(16#01,do_w_cal_control) MOV(70,do_cal_state_var) ];
				RC: "Wait for Operator to Confirm Stable Reading";
				N: EQU(do_cal_state_var,70)[OTE(do_cal_b_70_wait_for_stability_pt1) ,XIC(do_stability_ok) EQU(do_r_cal_status,8) MOV(80,do_cal_state_var) ];
				RC: "Save cal values and move to next step";
				N: EQU(do_cal_state_var,80)[OTE(do_cal_b_80_write_pt1) ,MOV(3,do_w_cal_control) ,MOV(90,do_cal_state_var) ];
				RC: "Waiting for Write to Finish Then Move to 2nd Point (Offset Cal) or End Cal if 1 Point";
				N: EQU(do_cal_state_var,90)[OTE(do_cal_b_90_wait_pt1_write) ,[EQU(do_r_cal_status,2) ,EQU(do_r_cal_status,1) ] EQU(0,do_r_cal_control) MOV(0,do_w_cal_control) MOV(100,do_cal_state_var) ];
				RC: "2nd  Cal Point";
				N: EQU(do_cal_state_var,100)[OTE(do_cal_b_100_start_pt2) ,MOV(16#01,do_w_cal_method) ,EQU(16#01,do_r_cal_method) MOV(110,do_cal_state_var) ];
				RC: "2nd Cal Probe Placement";
				N: EQU(do_cal_state_var,110)[OTE(do_cal_b_110_place_probe_pt2) ,XIC(do_probe_placement_ready) MOV(1,do_w_cal_control) MOV(120,do_cal_state_var) ];
				RC: "2nd Cal Stability Check by Operator";
				N: EQU(do_cal_state_var,120)[OTE(do_cal_b_120_wait_for_stability_pt2) ,XIC(do_stability_ok) [EQU(do_r_cal_status,8) ,EQU(do_r_cal_status,536870913) ] MOV(130,do_cal_state_var) ];
				RC: "Initiate Calibration Write";
				N: EQU(do_cal_state_var,130)[OTE(do_cal_b_130_write_pt2) ,TON(do_cal_b_130_write_pt2_Timer,?,?) ,MOV(3,do_w_cal_control) ,XIC(do_cal_b_130_write_pt2_Timer.DN) MOV(140,do_cal_state_var) ];
				RC: "Finish saving cal value";
				N: EQU(do_cal_state_var,140)[OTE(do_cal_b_140_wait_for_done) ,[EQU(do_r_cal_status,2) ,EQU(do_r_cal_status,16#40000002) ,EQU(do_r_cal_status,536870914) ,EQU(do_r_cal_status,536870913) ] MOV(190,do_cal_state_var) ];
				RC: "===========================$N"
				    "DO 1-Point Calibration$N"
				    "===========================";
				N: NOP();
				RC: "1-Point Cal Probe Placement";
				N: EQU(do_cal_state_var,150)[OTE(do_cal_b_150_place_probe_process) ,XIC(do_probe_placement_ready) MOV(1,do_w_cal_control) MOV(160,do_cal_state_var) ];
				RC: "1-Point Stability Check by Operator";
				N: EQU(do_cal_state_var,160)[OTE(do_cal_b_160_wait_for_stability_process) ,XIC(do_stability_ok) EQU(do_r_cal_status,8) MOV(170,do_cal_state_var) ];
				RC: "Initiate Calibration Write";
				N: EQU(do_cal_state_var,170)[OTE(do_cal_b_170_write_process) ,TON(do_cal_b_170_write_process_Timer,?,?) ,MOV(3,do_w_cal_control) ,XIC(do_cal_b_170_write_process_Timer.DN) MOV(180,do_cal_state_var) ];
				RC: "Finish saving cal value";
				N: EQU(do_cal_state_var,180)[OTE(do_cal_b_180_wait_for_done_process) ,EQU(do_r_cal_status,2) MOV(190,do_cal_state_var) ];
				N: EQU(do_cal_state_var,190)[OTE(do_cal_b_190_done_ok) ,MOV(cal_date,do_cal_done_date) ];
				N: EQU(do_cal_state_var,200)OTE(do_cal_b_200_done_error);
				N: EQU(do_cal_state_var,210)OTE(do_cal_b_210_pwd_error);
		END_ROUTINE

		ROUTINE Main 
				N: JSR(RL_PH,0);
				N: JSR(Pump_Interlock_Stops,0);
				N: JSR(Wago_Comms,0);
				N: JSR(RL_MTS,0);
				N: JSR(RL_DO,0);
				N: JSR(PBS_MFCs,0);
				N: JSR(PBS_SIC401_PDI,0);
				N: JSR(PBS_P101,0);
				N: JSR(PBS_P102,0);
				N: JSR(PBS_P103,0);
				N: JSR(PBS_P104,0);
				N: JSR(PBS_P105,0);
				N: JSR(CM_AI,0);
				N: JSR(Conditioned_Addition_Control,0);
				N: JSR(CM_Agitator,0);
				N: JSR(CM_Totalizers,0);
				N: JSR(CM_DO,0);
				N: JSR(CM_AO,0);
				N: JSR(Perfusion_Control,0);
				N: JSR(Media_Fill,0);
				N: JSR(CM_DI,0);
				N: JSR(RTD_Calibration,0);
				N: JSR(Brx_Comms,0);
				N: JSR(SM_MCV_HiAdj,0);
				N: JSR(SM_BRX_HiAdj,0);
				N: JSR(SM_BRX_LoAdj,0);
				N: JSR(DO_CAL,0);
				N: JSR(PH_CAL,0);
				N: JSR(Wago_Signal_Scaling,0);
		END_ROUTINE

		ROUTINE Media_Fill 
				N: [XIC(Estop_Active_Flag) ,XIO(P102.Inp_IntlkOK) ]OTU(MCV_InitialFill)OTU(MediaFill_ON);
				RC: "Scale user input of time ( s --> ms) and move to timer";
				N: CPT(MCV_LoAdjTimer.PRE,MCV_LoTimerSP*1000);
				RC: "BEGIN STATE MACHINE$N"
				    "------------------------------------------$N"
				    "Reset State Machine After Fault$N"
				    "Turn OFF State Machine by Putting in State 0$N"
				    "Turn OFF State Machine On Start-Up$N"
				    "Turn OFF State Machine if PID OFF$N"
				    "Turn OFF State Machine if Cal is Running";
				N: [XIC(MCV_LoAdj_Reset) ,XIC(MediaFill_Off) ,XIC(s:fs) ,XIC(MCV_InitialFill) ,XIC(P102_Cal.Cal_Running) ,XIC(Estop_Active_Flag) ][MOV(0,MCV_LoAdj_State) ,OTU(MCV_LoAdj_Reset) ,OTU(MediaFill_ON) ,OTE(MediaFilll_Off_Flag) ];
				RC: "State 0: State Machine OFF$N"
				    "Turn OFF Pumps and Set Speed To Zero$N"
				    "$N"
				    "Toggle Start Bit to Move to State 10$N"
				    "Enable State Machine$N"
				    "Put Pump in Program Mode";
				N: EQU(MCV_LoAdj_State,0)[OTE(MCV_LoAdj_OFF) ,XIC(MediaFill_ON) MOV(10,MCV_LoAdj_State) ];
				RC: "State 10: Idle$N"
				    "Stop Pump and Set Pump Speed to 0$N"
				    "If the vessel weight PV exceeds the SP, move to State 20.";
				N: EQU(MCV_LoAdj_State,10)[OTE(MCV_LoAdj_Idle) ,LES(WT702.Val,MCV_LoSP) MOV(20,MCV_LoAdj_State) ];
				RC: "State 20: Pump Speed Adjustment$N"
				    "P-104 Output is set to P-103 PV multiplied by BRX Hi Adjust speed ratio for BRX_HiAdjTimer time.$N"
				    "Run Pump$N"
				    "Move to State 30 when timer is done.$N"
				    "";
				N: EQU(MCV_LoAdj_State,20)[OTE(MCV_LoAdj_PumpAdj) ,TON(MCV_LoAdjTimer,?,?) ,XIC(MCV_LoAdjTimer.DN) MOV(30,MCV_LoAdj_State) ];
				RC: "Step 30: Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured BRX Hi Adjust Weight go to State 50.$N"
				    "If Vessel weight PV exceeds configured BRX Hi Adjust Weight go to State 40.";
				N: EQU(MCV_LoAdj_State,30)[OTE(MCV_LoAdj_Assess1) ,GEQ(WT702.Val,BRX_HiSP) MOV(50,MCV_LoAdj_State) ,LES(WT702.Val,BRX_HiSP) MOV(40,MCV_LoAdj_State) ];
				RC: "Step 40: Buffer$N"
				    "Stop Pump$N"
				    "Wait 10 seconds for BRX level reading to stabilize, then proceed to State 50.";
				N: EQU(MCV_LoAdj_State,40)[OTE(MCV_LoAdj_Buffer) ,TON(MCV_LoAdj_Stability_Timer,?,?) ,XIC(MCV_LoAdj_Stability_Timer.DN) MOV(50,MCV_LoAdj_State) ];
				RC: "Step 50: Post Buffer Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured BRX Hi Adjust Weight go to State 10.$N"
				    "If Vessel weight PV exceeds configured BRX Hi Adjust Weight go to State 20.$N"
				    "-------------------------------------------------------------------------------------------------------------$N"
				    "LAST RUNG OF STATE MACHINE";
				N: EQU(MCV_LoAdj_State,50)[OTE(MCV_LoAdj_Assess2) ,GEQ(WT702.Val,MCV_LoSP) MOV(10,MCV_LoAdj_State) ,LES(WT702.Val,MCV_LoSP) MOV(20,MCV_LoAdj_State) ];
				RC: "Any State above 10 means Active Media Adjustment";
				N: GRT(MCV_LoAdj_State,10)OTE(MediaAdj_InProgress);
				N: GEQ(MCV_LoAdj_State,10)[ADD(MCV_LoSP,MediaFill_HiDev,MediaFill_HiDev_Limit) ,SUB(MCV_LoSP,MediaFill_LoDev,MediaFill_LoDev_Limit) ]LIM(MediaFill_HiDev_Limit,WT702.Val,MediaFill_LoDev_Limit)[TON(MediaFill_Dev_Timer,?,?) ,XIC(MediaFill_Dev_Timer.DN) [GRT(WT702.Val,MediaFill_HiDev_Limit) OTE(MediaFill_Alm_HiDev) ,LES(WT702.Val,MediaFill_LoDev_Limit) OTE(MediaFill_Alm_LoDev) ] ];
				N: [XIC(Start_MCV_Initial_Fill) OTL(MCV_InitialFill) ,XIC(MediaFill_ON) ]OTE(P102.PCmd_Lock);
				N: [XIC(Abort_MCV_Initial_Fill) OTU(MCV_InitialFill) ,XIC(MediaFilll_Off_Flag) ]OTE(P102.PCmd_Unlock);
				RC: "InItial Fill$N"
				    "---------------------------------$N"
				    "Turn on P102 and set to MCV_InitialFillSpeed until MCV_FillWeight";
				N: XIC(MCV_InitialFill)XIO(MediaAdj_InProgress)[OTE(MCV_InitialFillRunning) ,GEQ(WT702.Val,MCV_FillWeight) [OTE(MCV_InitialFill_Finished) ,OTL(MCV_InitialFill_Done) ,XIC(P102_Crash_Stop.Done) OTU(MCV_InitialFill) ] ];
		END_ROUTINE

		ROUTINE PBS_MFCs 
				N: [XIO(mfc_0_AIR_r_data_ok) OTE(FIC110.Inp_IOFault) ,MOV(mfc_0_AIR_r_mdot_pv,FIC110.Inp_PosFdbk) ,XIC(CCA_3way.Sts_St0) OTE(Wago_IO:O1.Data[0].6) ,XIC(CCA_3way.Sts_St1) OTE(Wago_IO:O1.Data[0].4) ,P_D4SD(CCA_3way) ,P_ValveSO(KV112) P_ValveSO(KV111) ,[XIC(Estop_Active_Flag) [OTE(FIC110_intlk.Inp_Intlk00) ,OTE(FIC110.PCmd_Prog) ] ,P_Intlk(FIC110_intlk) ,XIC(FIC110_intlk.Sts_IntlkOK) OTE(FIC110.Inp_IntlkOK) ] ,P_ValveC(FIC110) ,MOV(FIC110.Out_CV,mfc_0_AIR_w_mdot_sp) ,GRT(FIC110.Out_CV,0) OTE(FIC110.Out_Open) ,XIC(FIC110.Out_Open) MOV(2,mfc_0_AIR_w_cmd_mode) ,LEQ(FIC110.Out_CV,0) OTE(FIC110.Out_Close) ,XIC(FIC110.Out_Close) MOV(0,mfc_0_AIR_w_cmd_mode) ,[ADD(FIC110.Val_CVSet,FIC110_HiDev,FIC110_HiDev_Limit) ,SUB(FIC110.Val_CVSet,FIC110_LoDev,FIC110_LoDev_Limit) ] LIM(FIC110_HiDev_Limit,FIC110.Val_Pos,FIC110_LoDev_Limit) [TON(FIC110_Dev_Timer,?,?) ,XIC(FIC110_Dev_Timer.DN) [GRT(FIC110.Val_Pos,FIC110_HiDev_Limit) OTE(FIC110_Alm_HiDev) ,LES(FIC110.Val_Pos,FIC110_LoDev_Limit) OTE(FIC110_Alm_LoDev) ] ] ];
				N: [XIO(mfc_1_O2_r_data_ok) OTE(FIC120.Inp_IOFault) ,MOV(mfc_1_O2_r_mdot_pv,FIC120.Inp_PosFdbk) ,XIC(O2_3way.Sts_St0) OTE(Wago_IO:O1.Data[0].7) ,XIC(O2_3way.Sts_St1) OTE(Wago_IO:O1.Data[0].5) ,P_D4SD(O2_3way) ,P_ValveSO(KV122) P_ValveSO(KV121) ,[XIC(Estop_Active_Flag) [OTE(FIC120_intlk.Inp_Intlk00) ,OTE(FIC120.PCmd_Prog) ] ,P_Intlk(FIC120_intlk) ,XIC(FIC120_intlk.Sts_IntlkOK) OTE(FIC120.Inp_IntlkOK) ] ,P_ValveC(FIC120) ,MOV(FIC120.Out_CV,mfc_1_O2_w_mdot_sp) ,GRT(FIC120.Out_CV,0) OTE(FIC120.Out_Open) ,XIC(FIC120.Out_Open) MOV(2,mfc_1_O2_w_cmd_mode) ,LEQ(FIC120.Out_CV,0) OTE(FIC120.Out_Close) ,XIC(FIC120.Out_Close) MOV(0,mfc_1_O2_w_cmd_mode) ,[ADD(FIC120.Val_CVSet,FIC120_HiDev,FIC120_HiDev_Limit) ,SUB(FIC120.Val_CVSet,FIC120_LoDev,FIC120_LoDev_Limit) ] LIM(FIC120_HiDev_Limit,FIC120.Val_Pos,FIC120_LoDev_Limit) [TON(FIC120_Dev_Timer,?,?) ,XIC(FIC120_Dev_Timer.DN) [GRT(FIC120.Val_Pos,FIC120_HiDev_Limit) OTE(FIC120_Alm_HiDev) ,LES(FIC120.Val_Pos,FIC120_LoDev_Limit) OTE(FIC120_Alm_LoDev) ] ] ];
				N: [XIO(mfc_2_CO2_r_data_ok) OTE(FIC130.Inp_IOFault) ,MOV(mfc_2_CO2_r_mdot_pv,FIC130.Inp_PosFdbk) ,XIC(CO2_3way.Sts_St0) OTE(Wago_IO:O1.Data[2].0) ,XIC(CO2_3way.Sts_St1) OTE(Wago_IO:O1.Data[1].6) ,P_D4SD(CO2_3way) ,P_ValveSO(KV132) P_ValveSO(KV131) ,[XIC(Estop_Active_Flag) [OTE(FIC130_intlk.Inp_Intlk00) ,OTE(FIC130.PCmd_Prog) ] ,P_Intlk(FIC130_intlk) ,XIC(FIC130_intlk.Sts_IntlkOK) OTE(FIC130.Inp_IntlkOK) ] ,P_ValveC(FIC130) ,MOV(FIC130.Out_CV,mfc_2_CO2_w_mdot_sp) ,GRT(FIC130.Out_CV,0) OTE(FIC130.Out_Open) ,XIC(FIC130.Out_Open) MOV(2,mfc_2_CO2_w_cmd_mode) ,LEQ(FIC130.Out_CV,0) OTE(FIC130.Out_Close) ,XIC(FIC130.Out_Close) MOV(0,mfc_2_CO2_w_cmd_mode) ,[ADD(FIC130.Val_CVSet,FIC130_HiDev,FIC130_HiDev_Limit) ,SUB(FIC130.Val_CVSet,FIC130_LoDev,FIC130_LoDev_Limit) ] LIM(FIC130_HiDev_Limit,FIC130.Val_Pos,FIC130_LoDev_Limit) [TON(FIC130_Dev_Timer,?,?) ,XIC(FIC130_Dev_Timer.DN) [GRT(FIC130.Val_Pos,FIC130_HiDev_Limit) OTE(FIC130_Alm_HiDev) ,LES(FIC130.Val_Pos,FIC130_LoDev_Limit) OTE(FIC130_Alm_LoDev) ] ] ];
				N: [XIO(mfc_3_N2_r_data_ok) OTE(FIC140.Inp_IOFault) ,MOV(mfc_3_N2_r_mdot_pv,FIC140.Inp_PosFdbk) ,XIC(N2_3way.Sts_St0) OTE(Wago_IO:O1.Data[2].1) ,XIC(N2_3way.Sts_St1) OTE(Wago_IO:O1.Data[1].7) ,P_D4SD(N2_3way) ,P_ValveSO(KV141) P_ValveSO(KV142) ,[XIC(Estop_Active_Flag) [OTE(FIC140_intlk.Inp_Intlk00) ,OTE(FIC140.PCmd_Prog) ] ,P_Intlk(FIC140_intlk) ,XIC(FIC140_intlk.Sts_IntlkOK) OTE(FIC140.Inp_IntlkOK) ] ,P_ValveC(FIC140) ,MOV(FIC140.Out_CV,mfc_3_N2_w_mdot_sp) ,GRT(FIC140.Out_CV,0) OTE(FIC140.Out_Open) ,XIC(FIC140.Out_Open) MOV(2,mfc_3_N2_w_cmd_mode) ,LEQ(FIC140.Out_CV,0) OTE(FIC140.Out_Close) ,XIC(FIC140.Out_Close) MOV(0,mfc_3_N2_w_cmd_mode) ,[ADD(FIC140.Val_CVSet,FIC140_HiDev,FIC140_HiDev_Limit) ,SUB(FIC140.Val_CVSet,FIC140_LoDev,FIC140_LoDev_Limit) ] LIM(FIC140_HiDev_Limit,FIC140.Val_Pos,FIC140_LoDev_Limit) [TON(FIC140_Dev_Timer,?,?) ,XIC(FIC140_Dev_Timer.DN) [GRT(FIC140.Val_Pos,FIC140_HiDev_Limit) OTE(FIC140_Alm_HiDev) ,LES(FIC140.Val_Pos,FIC140_LoDev_Limit) OTE(FIC140_Alm_LoDev) ] ] ];
		END_ROUTINE

		ROUTINE PBS_P101 
				N: [XIC(P101Fault) OTE(P101Fault_Output) ,XIC(LIT801.Alm_HiHi) OTE(P101_intlk.Inp_Intlk00) ,XIC(WT701.Alm_LoLo) OTE(P101_intlk.Inp_Intlk01) ,XIC(Estop_Active_Flag) [OTE(P101_intlk.Inp_Intlk02) ,MOV(0,P101.Val_SpeedFdbk) ] ,P_Intlk(P101_intlk) ,XIC(P101_intlk.Sts_IntlkOK) OTE(P101.Inp_IntlkOK) ];
				N: P_VSD(P101,P101_FaultCodeList);
				N: AMP_Motor_Enable(P101_Enable,P101_Drive:I.Data,P101_Drive:O.Data,P101_Enable_Trigger)AMP_Motor_Disable(P101_Disable,P101_Drive:I.Data,P101_Drive:O.Data,P101_Disable_Trigger)AMP_Alarm_Reset(P101_Alarm_Reset,P101_Drive:I.Data,P101_Drive:O.Data,P101_Alarm_Reset_Trigger)AMP_Jog_Move(P101_Jog_Move,P101_Drive:I.Data,P101_Drive:O.Data,P101_Jog_Move_Trigger,P101_Jog_Move.Speed,P101_Jog_Move.Acc,P101_Jog_Move.Dec)AMP_Crash_Stop(P101_Crash_Stop,P101_Drive:I.Data,P101_Drive:O.Data,P101_Crash_Stop_Trigger)AMP_Relative_Move(P101_Relative_Move,P101_Drive:I.Data,P101_Drive:O.Data,P101_Relative_Move_Trigger,P101_Relative_Move.Distance,P101_Relative_Move.Speed,P101_Relative_Move.Acc,P101_Relative_Move.Dec)AMP_Update_Jog_Speed(P101_Update_Jog_Speed,P101_Drive:I.Data,P101_Drive:O.Data,P101_Update_Jog_Speed_Trigger,P101_Update_Jog_Speed.Speed)AMP_Input_Assembly(P101_Input_Assembly_Instance,P101_Drive:I.Data,P101_Input_Assembly)AMP_Status_Code(P101_Status_Code,P101_Input_Assembly.Status_Code);
				N: XIC(s:fs)MOV(20000,P101_Motor_Constant)MOV(10,P101_Relative_Move.Acc)MOV(10,P101_Relative_Move.Dec)MOV(10,P101_Jog_Move.Acc)MOV(10,P101_Jog_Move.Dec);
				N: XIC(Enable_Toggle)OTE(P101_Enable_Trigger);
				N: XIO(Enable_Toggle)OTE(P101_Disable_Trigger);
				RC: "P101.Out_Start Branch Handles Operator Run from Face plate$N"
				    "";
				N: [XIC(P101.Out_Start) [XIC(P101.Out_Fwd) CPT(P101_Jog_Move.Speed,( P101.Val_SpeedRef )/ ( P101_Cal_Constant * 60)) ,XIC(P101.Out_Rev) CPT(P101_Jog_Move.Speed,( P101.Val_SpeedRef )/ ( P101_Cal_Constant * 60) * (-1)) ] ,XIC(Perfusion_On) CPT(P101_Jog_Move.Speed,( P101_Speed ) / ( P101_Cal_Constant * 60) * (-1)) ][ONS(ONS[0].21) MOV(P101_Jog_Move.Speed,P101_Current_Speed) ,OTE(P101_Jog_Move_Trigger) ];
				RC: "Timer for Speed Update during Jog";
				N: XIC(P101_Status_Code.Jogging)XIO(P101_Status_Code.Q_Program_Running)XIO(Estop_Active_Flag)[[TON(P101_Jog_Update_Timer,?,?) ,XIC(P101_Jog_Update_Timer.DN) [MOV(P101_Update_Jog_Speed.Speed,P101_Current_Speed) ,RES(P101_Jog_Update_Timer) ] ] ,CPT(P101.Val_SpeedFdbk,ABS( P101_Current_Speed * P101_Cal_Constant * 60)) ];
				RC: "Logic to Choos which Move New Jog Speed off of Timer$N"
				    "";
				N: XIC(P101_Status_Code.Jogging)XIC(P101_Jog_Update_Timer.EN)[XIC(P101.Sts_Oper) [XIC(P101.Out_Fwd) CPT(P101_Update_Jog_Speed.Speed,( P101.Val_SpeedRef )/ ( P101_Cal_Constant * 60)) ,XIC(P101.Out_Rev) CPT(P101_Update_Jog_Speed.Speed,( P101.Val_SpeedRef )/ ( P101_Cal_Constant * 60) * (-1)) ] ,XIC(Perfusion_Running) CPT(P101_Update_Jog_Speed.Speed,( P101_Speed ) * (1 / 60 ) * ( 1 / P101_Cal_Constant ) * ( -1 )) ]OTE(P101_Update_Jog_Speed_Trigger);
				RC: "Ties Movement of AMP AoI to P_VSD Graphics.";
				N: XIC(P101_Status_Code.Moving)XIO(Estop_Active_Flag)[[XIC(P101_Status_Code.Jogging) GRT(P101_Current_Speed,0) ,XIC(P101_Relative_Move.In_Progress) GRT(P101_Relative_Move.Distance,0) ] [OTE(P101.Inp_CommandDir) ,OTE(P101.Inp_ActualDir) ,MOV(2,P101.Val_Sts) ] ,[XIC(P101_Status_Code.Jogging) LES(P101_Current_Speed,0) ,XIC(P101_Relative_Move.In_Progress) LES(P101_Relative_Move.Distance,0) ] MOV(3,P101.Val_Sts) ,XIC(P101_Status_Code.Jogging) EQU(P101.Val_SpeedFdbk,0) MOV(1,P101.Val_Sts) ,XIC(P101_Relative_Move.In_Progress) CPT(P101.Val_SpeedFdbk,ABS ( ( P101_Relative_Move.Speed ) * ( P101_Cal_Constant ) * 60 )) ];
				RC: "Stops P101";
				N: [XIC(P101.Out_Stop) ,XIC(P101_Cal_Abort) ,XIC(P101_Dose_Abort) ,XIC(P101_Disable_Trigger) ,XIC(Perfusion_Stop_Trigger) ,XIC(Comm_Loss_Stop) XIO(BRX_Waiting_Comms) XIC(BRX_Comms_Retry_Stop) ,XIC(LIT801.Alm_HiHi) XIO(BRX_HiHi_Stopped) XIC(BRX_HiHi_Retry_Stop) ,XIC(WT701.Alm_LoLo) XIO(Media_LoLo_Stopped) XIC(Media_LoLo_Retry_Stop) ,XIC(Estop_Active_Flag) ]OTE(P101_Crash_Stop_Trigger);
				RC: "Starts the Cal and Dosing Process";
				N: [XIC(p101_Cal_Start) ,XIC(P101_Dose_Start) ]OTE(P101_Relative_Move_Trigger);
				RC: "Puts the pump in program mode for relevant processes";
				N: [XIC(P101_Relative_Move_Trigger) ,XIC(P101_Relative_Move.In_Progress) ,XIC(Perfusion_Running) ]OTE(P101.PCmd_Prog);
				RC: "Initialize P101 Cal Run";
				N: XIC(p101_Cal_Start)XIO(P101_Dose_Running)XIO(Perfusion_Running)[OTL(P101_Cal_Running) ,OTU(P101_Relative_Move.Done) ];
				RC: "P101 Calibration Run";
				N: XIC(P101_Cal_Running)[CPT(P101_Relative_Move.Speed,( P101_Cal_Speed / 100 ) * (7.5)) MUL(P101_CalRevs,P101_Motor_Constant,P101_Cal_Steps) MOV(P101_Cal_Steps,P101_Cal_Encoder_Steps) [XIC(P101_Cal_Direction) NEG(P101_Cal_Encoder_Steps,P101_Relative_Move.Distance) ,XIO(P101_Cal_Direction) MOV(P101_Cal_Encoder_Steps,P101_Relative_Move.Distance) ] ,XIC(P101_Relative_Move.Done) [CPT(P101_Cal_ColConst,P101_Cal_Collected / P101_Cal_Steps) MUL(P101_Cal_ColConst,P101_Motor_Constant,P101_Cal_Constant) MUL(P101_Cal_Constant,P101_MaxRPM,P101_Cal_Max_Flow) ,XIC(P101_Cal_Accept) MOV(P101_Cal_Max_Flow,P101.Cfg_SpeedRefEUMax) MOV(P101_Cal_Max_Flow,P101.Cfg_SpeedFdbkEUMax) MOV(P101_Cal_Max_Flow,P101.Cfg_MaxSpdRef) [OTU(P101_Cal_Running) ,OTL(P101_Cal_Complete) ] ] ,[XIC(P101_Cal_Abort) ,XIC(Estop_Active_Flag) ] [OTU(P101_Cal_Running) ,OTU(P101_Cal_Complete) ] ];
				RC: "Initialize P101 Dose Run";
				N: XIC(P101_Dose_Start)XIO(P101_Cal_Running)XIO(Perfusion_Running)[OTL(P101_Dose_Running) ,OTU(P101_Relative_Move.Done) ];
				RC: "P101 Dosing";
				N: XIC(P101_Dose_Running)[XIC(P101_Dose_Direction) CPT(P101_Relative_Move.Distance,( P101_Dose_mL ) / ( P101_Cal_ColConst) * (-1)) CPT(P101_Relative_Move.Speed,( P101_Dose_Speed_mlmin )/ ( P101_Cal_Constant * 60)) ,XIO(P101_Dose_Direction) CPT(P101_Relative_Move.Distance,( P101_Dose_mL ) / ( P101_Cal_ColConst)) CPT(P101_Relative_Move.Speed,( P101_Dose_Speed_mlmin )/ ( P101_Cal_Constant * 60)) ,[XIC(P101_Relative_Move.Done) ,XIC(P101_Dose_Abort) ,XIC(Estop_Active_Flag) ] OTU(P101_Dose_Running) ];
		END_ROUTINE

		ROUTINE PBS_P102 
				N: [XIC(P102Fault) OTE(P102Fault_Output) ,XIC(WT702.Alm_HiHi) OTE(P102_intlk.Inp_Intlk00) ,XIC(WT701.Alm_LoLo) OTE(P102_intlk.Inp_Intlk01) ,XIC(Estop_Active_Flag) [OTE(P102_intlk.Inp_Intlk02) ,MOV(0,P102.Val_SpeedFdbk) ] ,P_Intlk(P102_intlk) ,XIC(P102_intlk.Sts_IntlkOK) OTE(P102.Inp_IntlkOK) ];
				N: P_VSD(P102,P102_FaultCodeList);
				N: AMP_Motor_Enable(P102_Enable,P102_Drive:I.Data,P102_Drive:O.Data,P102_Enable_Trigger)AMP_Motor_Disable(P102_Disable,P102_Drive:I.Data,P102_Drive:O.Data,P102_Disable_Trigger)AMP_Alarm_Reset(P102_Alarm_Reset,P102_Drive:I.Data,P102_Drive:O.Data,P102_Alarm_Reset_Trigger)AMP_Jog_Move(P102_Jog_Move,P102_Drive:I.Data,P102_Drive:O.Data,P102_Jog_Move_Trigger,P102_Jog_Move.Speed,P102_Jog_Move.Acc,P102_Jog_Move.Dec)AMP_Crash_Stop(P102_Crash_Stop,P102_Drive:I.Data,P102_Drive:O.Data,P102_Crash_Stop_Trigger)AMP_Relative_Move(P102_Relative_Move,P102_Drive:I.Data,P102_Drive:O.Data,P102_Relative_Move_Trigger,P102_Relative_Move.Distance,P102_Relative_Move.Speed,P102_Relative_Move.Acc,P102_Relative_Move.Dec)AMP_Update_Jog_Speed(P102_Update_Jog_Speed,P102_Drive:I.Data,P102_Drive:O.Data,P102_Update_Jog_Speed_Trigger,P102_Update_Jog_Speed.Speed)AMP_Input_Assembly(P102_Input_Assembly_Instance,P102_Drive:I.Data,P102_Input_Assembly)AMP_Status_Code(P102_Status_Code,P102_Input_Assembly.Status_Code);
				N: XIC(s:fs)MOV(20000,P102_Motor_Constant)MOV(10,P102_Relative_Move.Acc)MOV(10,P102_Relative_Move.Dec)MOV(10,P102_Jog_Move.Acc)MOV(10,P102_Jog_Move.Dec);
				N: XIC(Enable_Toggle)OTE(P102_Enable_Trigger);
				N: XIO(Enable_Toggle)OTE(P102_Disable_Trigger);
				RC: "P102.Out_Start Branch Handles Operator Run from Face plate$N"
				    "";
				N: [XIC(P102.Out_Start) [XIC(P102.Out_Fwd) CPT(P102_Jog_Move.Speed,( P102.Val_SpeedRef )/ ( P102_Cal_Constant * 60)) ,XIC(P102.Out_Rev) CPT(P102_Jog_Move.Speed,( P102.Val_SpeedRef )/ ( P102_Cal_Constant * 60) * (-1)) ] ,XIC(MCV_InitialFillRunning) CPT(P102_Jog_Move.Speed,( MCV_InitialFillSpeed ) / ( P102_Cal_Constant * 60) * (-1)) ,XIC(MCV_LoAdj_Idle) MOV(0,P102_Jog_Move.Speed) ][ONS(ONS[0].22) MOV(P102_Jog_Move.Speed,P102_Current_Speed) ,OTE(P102_Jog_Move_Trigger) ];
				RC: "Timer for Speed Update during Jog";
				N: XIC(P102_Status_Code.Jogging)XIO(P102_Status_Code.Q_Program_Running)XIO(Estop_Active_Flag)[[TON(P102_Jog_Update_Timer,?,?) ,XIC(P102_Jog_Update_Timer.DN) [MOV(P102_Update_Jog_Speed.Speed,P102_Current_Speed) ,RES(P102_Jog_Update_Timer) ] ] ,CPT(P102.Val_SpeedFdbk,ABS(P102_Current_Speed*P102_Cal_Constant*60)) ];
				RC: "Logic to Choos which Move New Jog Speed off of Timer$N"
				    "";
				N: XIC(P102_Status_Code.Jogging)XIC(P102_Jog_Update_Timer.EN)[XIC(P102.Sts_Oper) [XIC(P102.Out_Fwd) CPT(P102_Update_Jog_Speed.Speed,( P102.Val_SpeedRef )/ ( P102_Cal_Constant * 60)) ,XIC(P102.Out_Rev) CPT(P102_Update_Jog_Speed.Speed,( P102.Val_SpeedRef )/ ( P102_Cal_Constant * 60) * (-1)) ] ,XIC(MCV_InitialFillRunning) CPT(P102_Update_Jog_Speed.Speed,( MCV_InitialFillSpeed ) / ( P102_Cal_Constant * 60) * (-1)) ,XIC(MCV_LoAdj_PumpAdj) CPT(P102_Update_Jog_Speed.Speed,( MediaLoSpeed ) / ( P102_Cal_Constant * 60) * (-1)) ,XIC(MCV_LoAdj_Buffer) MOV(0,P102_Update_Jog_Speed.Speed) ]OTE(P102_Update_Jog_Speed_Trigger);
				RC: "Ties Movement of AMP AoI to P_VSD Graphics.";
				N: XIC(P102_Status_Code.Moving)XIO(Estop_Active_Flag)[[XIC(P102_Status_Code.Jogging) GRT(P102_Current_Speed,0) ,XIC(P102_Relative_Move.In_Progress) GRT(P102_Relative_Move.Distance,0) ] [OTE(P102.Inp_CommandDir) ,OTE(P102.Inp_ActualDir) ,MOV(2,P102.Val_Sts) ] ,[XIC(P102_Status_Code.Jogging) LES(P102_Current_Speed,0) ,XIC(P102_Relative_Move.In_Progress) LES(P102_Relative_Move.Distance,0) ] MOV(3,P102.Val_Sts) ,XIC(P102_Status_Code.Jogging) EQU(P102.Val_SpeedFdbk,0) MOV(1,P102.Val_Sts) ,XIC(P102_Relative_Move.In_Progress) CPT(P102.Val_SpeedFdbk,ABS ( ( P102_Relative_Move.Speed ) * ( P102_Cal_Constant ) * 60 )) ];
				RC: "Stops P102";
				N: [XIC(P102.Out_Stop) ,XIC(P102_Cal_Abort) ,XIC(P102_Dose_Abort) ,XIC(P102_Disable_Trigger) ,XIC(Abort_MCV_Initial_Fill) ,XIC(MCV_InitialFill_Finished) ,XIC(MediaFill_Off) ,XIC(Comm_Loss_Stop) XIO(BRX_Waiting_Comms) XIC(BRX_Comms_Retry_Stop) ,XIC(WT702.Alm_HiHi) XIO(MMV_HiHi_Stopped) XIC(MMV_HiHi_Retry_Stop) ,XIC(WT701.Alm_LoLo) XIO(Media_LoLo_Stopped) XIC(Media_LoLo_Retry_Stop) ,XIC(Estop_Active_Flag) ]OTE(P102_Crash_Stop_Trigger);
				RC: "Starts the Cal and Dosing Process";
				N: [XIC(P102_Cal_Start) ,XIC(P102_Dose_Start) ]OTE(P102_Relative_Move_Trigger);
				RC: "Puts the pump in program mode for relevant processes";
				N: [XIC(P102_Relative_Move_Trigger) ,XIC(P102_Relative_Move.In_Progress) ,XIC(MCV_LoAdj_Enable) ,XIC(MCV_InitialFillRunning) ,XIC(Abort_MCV_Initial_Fill) ]OTE(P102.PCmd_Prog);
				RC: "Initialize P102 Cal Run";
				N: XIC(P102_Cal_Start)XIO(P102_Dose_Running)[OTL(P102_Cal_Running) ,OTU(P102_Relative_Move.Done) ];
				RC: "P102 Calibration Run";
				N: XIC(P102_Cal_Running)[CPT(P102_Relative_Move.Speed,( P102_Cal_Speed / 100 ) * 7.5) MUL(P102_CalRevs,P102_Motor_Constant,P102_Cal_Steps) MOV(P102_Cal_Steps,P102_Cal_Encoder_Steps) [XIC(P102_Cal_Direction) NEG(P102_Cal_Encoder_Steps,P102_Relative_Move.Distance) ,XIO(P102_Cal_Direction) MOV(P102_Cal_Encoder_Steps,P102_Relative_Move.Distance) ] ,XIC(P102_Relative_Move.Done) [CPT(P102_Cal_ColConst,P102_Cal_Collected / P102_Cal_Steps) MUL(P102_Cal_ColConst,P102_Motor_Constant,P102_Cal_Constant) MUL(P102_Cal_Constant,P102_MaxRPM,P102_Cal_Max_Flow) ,XIC(P102_Cal_Accept) MOV(P102_Cal_Max_Flow,P102.Cfg_SpeedRefEUMax) MOV(P102_Cal_Max_Flow,P102.Cfg_SpeedFdbkEUMax) MOV(P102_Cal_Max_Flow,P102.Cfg_MaxSpdRef) [OTU(P102_Cal_Running) ,OTL(P102_Cal_Complete) ] ] ,[XIC(P102_Cal_Abort) ,XIC(Estop_Active_Flag) ] [OTU(P102_Cal_Running) ,OTU(P102_Cal_Complete) ] ];
				RC: "Initialize P102 Dose Run";
				N: XIC(P102_Dose_Start)XIO(P102_Cal_Running)[OTL(P102_Dose_Running) ,OTU(P102_Relative_Move.Done) ];
				RC: "P102 Dosing";
				N: XIC(P102_Dose_Running)[XIC(P102_Dose_Direction) CPT(P102_Relative_Move.Distance,( P102_Dose_mL ) / ( P102_Cal_ColConst) * (-1)) CPT(P102_Relative_Move.Speed,( P102_Dose_Speed_mlmin )/ ( P102_Cal_Constant * 60)) ,XIO(P102_Dose_Direction) CPT(P102_Relative_Move.Distance,( P102_Dose_mL ) / ( P102_Cal_ColConst)) CPT(P102_Relative_Move.Speed,( P102_Dose_Speed_mlmin )/ ( P102_Cal_Constant * 60)) ,[XIC(P102_Relative_Move.Done) ,XIC(P102_Dose_Abort) ,XIC(Estop_Active_Flag) ] OTU(P102_Dose_Running) ];
		END_ROUTINE

		ROUTINE PBS_P103 
				N: [XIC(P103Fault) OTE(P103Fault_Output) ,XIC(LIT801.Alm_HiHi) OTE(P103_intlk.Inp_Intlk00) ,XIC(WT702.Alm_LoLo) OTE(P103_intlk.Inp_Intlk01) ,XIC(Estop_Active_Flag) [OTE(P103_intlk.Inp_Intlk02) ,MOV(0,P103.Val_SpeedFdbk) ] ,P_Intlk(P103_intlk) ,XIC(P103_intlk.Sts_IntlkOK) OTE(P103.Inp_IntlkOK) ];
				N: P_VSD(P103,P103_FaultCodeList);
				N: AMP_Motor_Enable(P103_Enable,P103_Drive:I.Data,P103_Drive:O.Data,P103_Enable_Trigger)AMP_Motor_Disable(P103_Disable,P103_Drive:I.Data,P103_Drive:O.Data,P103_Disable_Trigger)AMP_Alarm_Reset(P103_Alarm_Reset,P103_Drive:I.Data,P103_Drive:O.Data,P103_Alarm_Reset_Trigger)AMP_Jog_Move(P103_Jog_Move,P103_Drive:I.Data,P103_Drive:O.Data,P103_Jog_Move_Trigger,P103_Jog_Move.Speed,P103_Jog_Move.Acc,P103_Jog_Move.Dec)AMP_Crash_Stop(P103_Crash_Stop,P103_Drive:I.Data,P103_Drive:O.Data,P103_Crash_Stop_Trigger)AMP_Relative_Move(P103_Relative_Move,P103_Drive:I.Data,P103_Drive:O.Data,P103_Relative_Move_Trigger,P103_Relative_Move.Distance,P103_Relative_Move.Speed,P103_Relative_Move.Acc,P103_Relative_Move.Dec)AMP_Update_Jog_Speed(P103_Update_Jog_Speed,P103_Drive:I.Data,P103_Drive:O.Data,P103_Update_Jog_Speed_Trigger,P103_Update_Jog_Speed.Speed)AMP_Input_Assembly(P103_Input_Assembly_Instance,P103_Drive:I.Data,P103_Input_Assembly)AMP_Status_Code(P103_Status_Code,P103_Input_Assembly.Status_Code);
				N: XIC(s:fs)MOV(20000,P103_Motor_Constant)MOV(10,P103_Relative_Move.Acc)MOV(10,P103_Relative_Move.Dec)MOV(10,P103_Jog_Move.Acc)MOV(10,P103_Jog_Move.Dec);
				N: XIC(Enable_Toggle)OTE(P103_Enable_Trigger);
				N: XIO(Enable_Toggle)OTE(P103_Disable_Trigger);
				RC: "P103.Out_Start Branch Handles Operator Run from Face plate$N"
				    "";
				N: [XIC(P103.Out_Start) [XIC(P103.Out_Fwd) CPT(P103_Jog_Move.Speed,( P103.Val_SpeedRef )/ ( P103_Cal_Constant * 60)) ,XIC(P103.Out_Rev) CPT(P103_Jog_Move.Speed,( P103.Val_SpeedRef )/ ( P103_Cal_Constant * 60) * (-1)) ] ,XIC(ConditionedMedia_Running) CPT(P103_Jog_Move.Speed,( ConditionedMedia_Scaler.Out )/ ( P103_Cal_Constant * 60) * (-1)) ]NEQ(BRX_LoAdj_State,40)ONS(ONS[0].28)[MOV(P103_Jog_Move.Speed,P103_Current_Speed) ,OTE(P103_Jog_Move_Trigger) ];
				RC: "Timer for Speed Update during Jog";
				N: XIC(P103_Status_Code.Jogging)XIO(P103_Status_Code.Q_Program_Running)XIO(Estop_Active_Flag)[[TON(P103_Jog_Update_Timer,?,?) ,XIC(P103_Jog_Update_Timer.DN) [MOV(P103_Update_Jog_Speed.Speed,P103_Current_Speed) ,RES(P103_Jog_Update_Timer) ] ] ,CPT(P103.Val_SpeedFdbk,ABS(P103_Current_Speed*P103_Cal_Constant*60)) ];
				RC: "Logic to Choos which Move New Jog Speed off of Timer$N"
				    "";
				N: XIC(P103_Status_Code.Jogging)XIC(P103_Jog_Update_Timer.EN)[XIC(P103.Sts_Oper) [XIC(P103.Out_Fwd) CPT(P103_Update_Jog_Speed.Speed,( P103.Val_SpeedRef )/ ( P103_Cal_Constant * 60)) ,XIC(P103.Out_Rev) CPT(P103_Update_Jog_Speed.Speed,( P103.Val_SpeedRef )/ ( P103_Cal_Constant * 60) * (-1)) ] ,XIC(P103.Sts_Prog) [XIC(ConditionedMedia_NoAdjust_Speed) [XIC(MCV_HiAdj_Idle) ,XIO(MCV_HiAdjEnable) ] [XIC(BRX_LoAdj_Idle) ,XIO(BRX_LoAdjEnable) ] [XIC(BRX_HiAdj_Idle) ,XIO(BRX_HiAdjEnable) ] CPT(P103_Update_Jog_Speed.Speed,( ConditionedMedia_Scaler.Out )/ ( P103_Cal_Constant * 60)) ,[XIC(MCV_HiAdj_PumpAdj) ,XIC(BRX_LoAdj_PumpAdj) ,XIC(BRX_HiAdj_PumpAdj) ] CPT(P103_Update_Jog_Speed.Speed,( P103.PSet_SpeedRef ) / ( P103_Cal_Constant * 60)) ] ]OTE(P103_Update_Jog_Speed_Trigger);
				RC: "Ties Movement of AMP AoI to P_VSD Graphics.";
				N: XIC(P103_Status_Code.Moving)[[XIC(P103_Status_Code.Jogging) GRT(P103_Current_Speed,0) ,XIC(P103_Relative_Move.In_Progress) GRT(P103_Relative_Move.Distance,0) ] [OTE(P103.Inp_CommandDir) ,OTE(P103.Inp_ActualDir) ,MOV(2,P103.Val_Sts) ] ,[XIC(P103_Status_Code.Jogging) LES(P103_Current_Speed,0) ,XIC(P103_Relative_Move.In_Progress) LES(P103_Relative_Move.Distance,0) ] MOV(3,P103.Val_Sts) ,XIC(P103_Status_Code.Jogging) EQU(P103.Val_SpeedFdbk,0) MOV(1,P103.Val_Sts) ,XIC(P103_Relative_Move.In_Progress) CPT(P103.Val_SpeedFdbk,ABS ( ( P103_Relative_Move.Speed ) * ( P103_Cal_Constant ) * 60 )) ];
				RC: "Stops P103";
				N: [XIC(P103.Out_Stop) ,XIC(P103_Cal_Abort) ,XIC(P103_Dose_Abort) ,XIC(P103_Disable_Trigger) ,XIC(Stop_ConditionedMedia_Initialize) ,XIC(Comm_Loss_Stop) XIO(BRX_Waiting_Comms) XIC(BRX_Comms_Retry_Stop) ,XIC(LIT801.Alm_HiHi) XIO(BRX_HiHi_Stopped) XIC(BRX_HiHi_Retry_Stop) ,XIC(WT702.Alm_LoLo) XIO(MMV_LoLo_Stopped) XIC(MMV_LoLo_Retry_Stop) ,XIC(Estop_Active_Flag) ]OTE(P103_Crash_Stop_Trigger);
				RC: "Starts the Cal and Dosing Process";
				N: [XIC(P103_Cal_Start) ,XIC(P103_Dose_Start) ]OTE(P103_Relative_Move_Trigger);
				RC: "Puts the pump in program mode for relevant processes";
				N: [XIC(P103_Relative_Move_Trigger) ,XIC(P103_Relative_Move.In_Progress) ,XIC(ConditionedMedia_Running) ]OTE(P103.PCmd_Prog);
				RC: "Initialize P103 Cal Run";
				N: XIC(P103_Cal_Start)XIO(P103_Dose_Running)[OTL(P103_Cal_Running) ,OTU(P103_Relative_Move.Done) ];
				RC: "P103 Calibration Run";
				N: XIC(P103_Cal_Running)[CPT(P103_Relative_Move.Speed,( P103_Cal_Speed / 100 ) * 7.5) MUL(P103_CalRevs,P103_Motor_Constant,P103_Cal_Steps) MOV(P103_Cal_Steps,P103_Cal_Encoder_Steps) [XIC(P103_Cal_Direction) NEG(P103_Cal_Encoder_Steps,P103_Relative_Move.Distance) ,XIO(P103_Cal_Direction) MOV(P103_Cal_Encoder_Steps,P103_Relative_Move.Distance) ] ,XIC(P103_Relative_Move.Done) [CPT(P103_Cal_ColConst,P103_Cal_Collected / P103_Cal_Steps) MUL(P103_Cal_ColConst,P103_Motor_Constant,P103_Cal_Constant) MUL(P103_Cal_Constant,P103_MaxRPM,P103_Cal_Max_Flow) ,XIC(P103_Cal_Accept) MOV(P103_Cal_Max_Flow,P103.Cfg_SpeedRefEUMax) MOV(P103_Cal_Max_Flow,P103.Cfg_SpeedFdbkEUMax) MOV(P103_Cal_Max_Flow,P103.Cfg_MaxSpdRef) [OTU(P103_Cal_Running) ,OTL(P103_Cal_Complete) ] ] ,[XIC(P103_Cal_Abort) ,XIC(Estop_Active_Flag) ] [OTU(P103_Cal_Running) ,OTU(P103_Cal_Complete) ] ];
				RC: "Initialize P103 Dose Run";
				N: XIC(P103_Dose_Start)XIO(P103_Cal_Running)[OTL(P103_Dose_Running) ,OTU(P103_Relative_Move.Done) ];
				RC: "P103 Dosing";
				N: XIC(P103_Dose_Running)[XIC(P103_Dose_Direction) CPT(P103_Relative_Move.Distance,( P103_Dose_mL ) / ( P103_Cal_ColConst) * (-1)) CPT(P103_Relative_Move.Speed,( P103_Dose_Speed_mlmin )/ ( P103_Cal_Constant * 60)) ,XIO(P103_Dose_Direction) CPT(P103_Relative_Move.Distance,( P103_Dose_mL ) / ( P103_Cal_ColConst)) CPT(P103_Relative_Move.Speed,( P103_Dose_Speed_mlmin )/ ( P103_Cal_Constant * 60)) ,[XIC(P103_Relative_Move.Done) ,XIC(P103_Dose_Abort) ,XIC(Estop_Active_Flag) ] OTU(P103_Dose_Running) ];
		END_ROUTINE

		ROUTINE PBS_P104 
				N: [XIC(P104Fault) OTE(P104Fault_Output) ,XIC(LIT801.Alm_LoLo) OTE(p104_intlk.Inp_Intlk00) ,XIC(WT702.Alm_HiHi) OTE(p104_intlk.Inp_Intlk01) ,XIC(Estop_Active_Flag) [OTE(p104_intlk.Inp_Intlk02) ,MOV(0,P104.Val_SpeedFdbk) ] ,P_Intlk(p104_intlk) ,XIC(p104_intlk.Sts_IntlkOK) OTE(P104.Inp_IntlkOK) ];
				N: P_VSD(P104,P104_FaultCodeList);
				N: AMP_Motor_Enable(P104_Enable,P104_Drive:I.Data,P104_Drive:O.Data,P104_Enable_Trigger)AMP_Motor_Disable(P104_Disable,P104_Drive:I.Data,P104_Drive:O.Data,P104_Disable_Trigger)AMP_Alarm_Reset(P104_Alarm_Reset,P104_Drive:I.Data,P104_Drive:O.Data,P104_Alarm_Reset_Trigger)AMP_Jog_Move(P104_Jog_Move,P104_Drive:I.Data,P104_Drive:O.Data,P104_Jog_Move_Trigger,P104_Jog_Move.Speed,P104_Jog_Move.Acc,P104_Jog_Move.Dec)AMP_Crash_Stop(P104_Crash_Stop,P104_Drive:I.Data,P104_Drive:O.Data,P104_Crash_Stop_Trigger)AMP_Relative_Move(P104_Relative_Move,P104_Drive:I.Data,P104_Drive:O.Data,P104_Relative_Move_Trigger,P104_Relative_Move.Distance,P104_Relative_Move.Speed,P104_Relative_Move.Acc,P104_Relative_Move.Dec)AMP_Update_Jog_Speed(P104_Update_Jog_Speed,P104_Drive:I.Data,P104_Drive:O.Data,P104_Update_Jog_Speed_Trigger,P104_Update_Jog_Speed.Speed)AMP_Input_Assembly(P104_Input_Assembly_Instance,P104_Drive:I.Data,P104_Input_Assembly)AMP_Status_Code(P104_Status_Code,P104_Input_Assembly.Status_Code);
				N: XIC(s:fs)MOV(20000,P104_Motor_Constant)MOV(10,P104_Relative_Move.Acc)MOV(10,P104_Relative_Move.Dec)MOV(10,P104_Jog_Move.Acc)MOV(10,P104_Jog_Move.Dec);
				N: XIC(Enable_Toggle)OTE(P104_Enable_Trigger);
				N: XIO(Enable_Toggle)OTE(P104_Disable_Trigger);
				RC: "P104.Out_Start Branch Handles Operator Run from Face plate$N"
				    "";
				N: [XIC(P104.Out_Start) [XIC(P104.Out_Fwd) CPT(P104_Jog_Move.Speed,( P104.Val_SpeedRef )/ ( P104_Cal_Constant * 60)) ,XIC(P104.Out_Rev) CPT(P104_Jog_Move.Speed,( P104.Val_SpeedRef )/ ( P104_Cal_Constant * 60) * (-1)) ] ,XIC(ConditionedMedia_Running) CPT(P104_Jog_Move.Speed,( ConditionedMedia_Scaler.Out )/ ( P104_Cal_Constant * 60) * (-1)) ]NEQ(BRX_HiAdj_State,40)NEQ(BRX_LoAdj_State,40)ONS(ONS[0].29)[MOV(P104_Jog_Move.Speed,P104_Current_Speed) ,OTE(P104_Jog_Move_Trigger) ];
				RC: "Timer for Speed Update during Jog";
				N: XIC(P104_Status_Code.Jogging)XIO(P104_Status_Code.Q_Program_Running)XIO(Estop_Active_Flag)[[TON(P104_Jog_Update_Timer,?,?) ,XIC(P104_Jog_Update_Timer.DN) [MOV(P104_Update_Jog_Speed.Speed,P104_Current_Speed) ,RES(P104_Jog_Update_Timer) ] ] ,CPT(P104.Val_SpeedFdbk,ABS(P104_Current_Speed*P104_Cal_Constant*60)) ];
				RC: "Logic to Choos which Move New Jog Speed off of Timer$N"
				    "";
				N: XIC(P104_Status_Code.Jogging)XIC(P104_Jog_Update_Timer.EN)[XIC(P104.Sts_Oper) [XIC(P104.Out_Fwd) CPT(P104_Update_Jog_Speed.Speed,( P104.Val_SpeedRef )/ ( P104_Cal_Constant * 60)) ,XIC(P104.Out_Rev) CPT(P104_Update_Jog_Speed.Speed,( P104.Val_SpeedRef )/ ( P104_Cal_Constant * 60) * (-1)) ] ,XIC(P104.Sts_Prog) [XIC(ConditionedMedia_NoAdjust_Speed) [XIC(MCV_HiAdj_Idle) ,XIO(MCV_HiAdjEnable) ] [XIC(BRX_LoAdj_Idle) ,XIO(BRX_LoAdjEnable) ] [XIC(BRX_HiAdj_Idle) ,XIO(BRX_HiAdjEnable) ] CPT(P104_Update_Jog_Speed.Speed,( ConditionedMedia_Scaler.Out )/ ( P104_Cal_Constant * 60) * (-1)) ,[XIC(MCV_HiAdj_PumpAdj) ,XIC(BRX_LoAdj_PumpAdj) ,XIC(BRX_HiAdj_PumpAdj) ] CPT(P104_Update_Jog_Speed.Speed,( P104.PSet_SpeedRef ) / ( P104_Cal_Constant * 60) * ( -1 )) ,[XIC(MCV_HiAdj_Buffer) ,XIC(BRX_LoAdj_Buffer) ,XIC(BRX_HiAdj_Buffer) ] MOV(0,P104_Update_Jog_Speed.Speed) ] ]OTE(P104_Update_Jog_Speed_Trigger);
				RC: "Ties Movement of AMP AoI to P_VSD Graphics.";
				N: XIC(P104_Status_Code.Moving)XIO(Estop_Active_Flag)[[XIC(P104_Status_Code.Jogging) GRT(P104_Current_Speed,0) ,XIC(P104_Relative_Move.In_Progress) GRT(P104_Relative_Move.Distance,0) ] [OTE(P104.Inp_CommandDir) ,OTE(P104.Inp_ActualDir) ,MOV(2,P104.Val_Sts) ] ,[XIC(P104_Status_Code.Jogging) LES(P104_Current_Speed,0) ,XIC(P104_Relative_Move.In_Progress) LES(P104_Relative_Move.Distance,0) ] MOV(3,P104.Val_Sts) ,XIC(P104_Status_Code.Jogging) EQU(P104.Val_SpeedFdbk,0) MOV(1,P104.Val_Sts) ,XIC(P104_Relative_Move.In_Progress) CPT(P104.Val_SpeedFdbk,ABS ( ( P104_Relative_Move.Speed ) * ( P104_Cal_Constant ) * 60 )) ];
				RC: "Stops P104";
				N: [XIC(P104.Out_Stop) ,XIC(P104_Cal_Abort) ,XIC(P104_Dose_Abort) ,XIC(P104_Disable_Trigger) ,XIC(Stop_ConditionedMedia_Initialize) ,XIC(Comm_Loss_Stop) XIO(BRX_Waiting_Comms) XIC(BRX_Comms_Retry_Stop) ,XIC(LIT801.Alm_LoLo) XIO(BRX_LoLo_Stopped) XIC(BRX_LoLo_Retry_Stop) ,XIC(WT702.Alm_HiHi) XIO(MMV_HiHi_Stopped) XIC(MMV_HiHi_Retry_Stop) ,XIC(Estop_Active_Flag) ]OTE(P104_Crash_Stop_Trigger);
				RC: "Starts the Cal and Dosing Process";
				N: [XIC(P104_Cal_Start) ,XIC(P104_Dose_Start) ]OTE(P104_Relative_Move_Trigger);
				RC: "Puts the pump in program mode for relevant processes";
				N: [XIC(P104_Relative_Move_Trigger) ,XIC(P104_Relative_Move.In_Progress) ,XIC(ConditionedMedia_Running) ]OTE(P104.PCmd_Prog);
				RC: "Initialize P104 Cal Run";
				N: XIC(P104_Cal_Start)XIO(P104_Dose_Running)[OTL(P104_Cal_Running) ,OTU(P104_Relative_Move.Done) ];
				RC: "P104 Calibration Run";
				N: XIC(P104_Cal_Running)[CPT(P104_Relative_Move.Speed,( P104_Cal_Speed / 100 ) * 7.5) MUL(P104_CalRevs,P104_Motor_Constant,P104_Cal_Steps) MOV(P104_Cal_Steps,P104_Cal_Encoder_Steps) [XIC(P104_Cal_Direction) NEG(P104_Cal_Encoder_Steps,P104_Relative_Move.Distance) ,XIO(P104_Cal_Direction) MOV(P104_Cal_Encoder_Steps,P104_Relative_Move.Distance) ] ,XIC(P104_Relative_Move.Done) [CPT(P104_Cal_ColConst,P104_Cal_Collected / P104_Cal_Steps) MUL(P104_Cal_ColConst,P104_Motor_Constant,P104_Cal_Constant) MUL(P104_Cal_Constant,P104_MaxRPM,P104_Cal_Max_Flow) ,XIC(P104_Cal_Accept) MOV(P104_Cal_Max_Flow,P104.Cfg_SpeedRefEUMax) MOV(P104_Cal_Max_Flow,P104.Cfg_SpeedFdbkEUMax) MOV(P104_Cal_Max_Flow,P104.Cfg_MaxSpdRef) [OTU(P104_Cal_Running) ,OTL(P104_Cal_Complete) ] ] ,[XIC(P104_Cal_Abort) ,XIC(Estop_Active_Flag) ] [OTU(P104_Cal_Running) ,OTU(P104_Cal_Complete) ] ];
				RC: "Initialize P104 Dose Run";
				N: XIC(P104_Dose_Start)XIO(P104_Cal_Running)[OTL(P104_Dose_Running) ,OTU(P104_Relative_Move.Done) ];
				RC: "P104 Dosing";
				N: XIC(P104_Dose_Running)[XIC(P104_Dose_Direction) CPT(P104_Relative_Move.Distance,( P104_Dose_mL ) / ( P104_Cal_ColConst) * (-1)) CPT(P104_Relative_Move.Speed,( P104_Dose_Speed_mlmin )/ ( P104_Cal_Constant * 60)) ,XIO(P104_Dose_Direction) CPT(P104_Relative_Move.Distance,( P104_Dose_mL ) / ( P104_Cal_ColConst)) CPT(P104_Relative_Move.Speed,( P104_Dose_Speed_mlmin )/ ( P104_Cal_Constant * 60)) ,[XIC(P104_Relative_Move.Done) ,XIC(P104_Dose_Abort) ,XIC(Estop_Active_Flag) ] OTU(P104_Dose_Running) ];
		END_ROUTINE

		ROUTINE PBS_P105 
				N: XIC(s:fs)OTL(Wago_IO:O1.Data[0].2);
				N: [XIC(P105_Ethernet:I.LeakDetected) ,XIC(P105_Ethernet:I.MotorStallError) ,XIC(P105_Ethernet:I.MotorSpeedError) ,XIC(P105_Ethernet:I.OverCurrentError) ,XIC(P105_Ethernet:I.OverVoltageError) ,XIC(P105_Ethernet:I.FlowSensorError) ,XIC(P105_Ethernet:I.PressureSensorError) ,XIC(P105_Ethernet:I.PressureSwitchError) ,XIC(P105_Ethernet:I.ConnectionFaulted) ]OTE(P105_Alm_Fault);
				N: [[XIC(WT703.Alm_HiHi) OTE(P105_intlk.Inp_Intlk00) ,XIC(LIT801.Alm_LoLo) OTE(P105_intlk.Inp_Intlk01) ,XIC(Estop_Active_Flag) [OTE(P105_intlk.Inp_Intlk02) ,MOV(0,P105.Val_SpeedFdbk) ] ,P_Intlk(P105_intlk) ,XIC(P105_intlk.Sts_IntlkOK) OTE(P105.Inp_IntlkOK) ] ,P_VSD(P105,P105_FaultCodeList) ,AFI() Pump_Cal(P105_Cal,P105.Sts_RunningFwd,P105.PCmd_Prog,P105.Cfg_SpeedRefEUMin,P105.Cfg_SpeedRefEUMax,P105.Cfg_SpeedFdbkEUMin,P105.Cfg_SpeedFdbkEUMax,P105.Cfg_MinSpdRef,P105.Cfg_MaxSpdRef,P105.PSet_SpeedRef,P105.PCmd_StartFwd,P105.Sts_Prog,P105.PCmd_Stop) ,MUL(P105_Ethernet:I.SpeedLimit,P105_Flow_Rate_Correction,P105.Cfg_MaxSpdRef) MOV(P105.Cfg_MaxSpdRef,P105_Cal_Max_Flow) ,MOV(P105_Ethernet:I.FlowCal,P105_Ethernet:O.SetFlowCal) ,DIV(P105_Ethernet:I.FlowCal,10000,P105_Flow_Rate_Correction) ];
				RC: "Set Pump DIrection";
				N: [XIC(P105.Sts_Oper) XIC(P105.Out_Rev) ,XIC(P105_Dose_Running) XIC(P105_Dose_Direction) ][OTE(P105_Run_Reverse) ,OTE(P105_Ethernet:O.SetReverse) ];
				N: [XIC(P105.Sts_Prog) XIC(P105_Dose_Running) ,XIC(P105.Sts_Prog) XIC(Perfusion_Running) ,XIC(P105.Sts_Oper) XIC(P105.Sts_RunningFwd) ,XIC(P105.Sts_Oper) XIC(P105.Sts_RunningRev) ]OTE(P105_Ethernet:O.Run);
				N: [XIC(P105.Out_Stop) ,XIC(Perfusion_Stop_Trigger) ,XIC(P105_Dose_Abort) ,EQU(P105.Val_SpeedRef,0) ,XIC(Comm_Loss_Stop) ONS(ONS[0].29) ,[XIC(WT703.Alm_HiHi) ,XIC(LIT801.Alm_LoLo) ] ONS(ONS[0].30) ][OTU(P105_Ethernet:O.Run) ,MOV(1,P105.Val_Sts) ];
				N: [XIC(P105_Dose_Running) ,XIC(Perfusion_Running) ]OTE(P105.PCmd_Prog);
				RC: "Logic to Tie P_VSD Graphics to Pump";
				N: XIC(P105_Ethernet:O.Run)XIO(Estop_Active_Flag)[XIC(P105_Run_Reverse) [OTU(P105.Inp_CommandDir) ,OTU(P105.Inp_ActualDir) ,MOV(3,P105.Val_Sts) ] ,XIO(P105_Run_Reverse) [OTL(P105.Inp_CommandDir) ,OTL(P105.Inp_ActualDir) ,MOV(2,P105.Val_Sts) ] ];
				RC: "Initialize P104 Dose Run";
				N: XIC(P105_Dose_Start)OTL(P105_Dose_Running);
				RC: "P105 Dose Timer";
				N: XIC(P105_Dose_Running)[CPT(P105_Dose_Timer.PRE,( P105_Dose_mL ) / ( P105_Dose_Speed_mlmin ) * 60 * 1000) TON(P105_Dose_Timer,?,?) ,[XIC(P105_Dose_Timer.DN) ,XIC(P105_Dose_Abort) ] OTU(P105_Dose_Running) ];
				RC: "Timer for Speed Updates During Run";
				N: XIC(P105_Ethernet:O.Run)[[TON(P105_Speed_Update_Timer,?,?) ,XIC(P105_Speed_Update_Timer.DN) RES(P105_Speed_Update_Timer) ] ,CPT(P105.Val_SpeedFdbk,( P105_Ethernet:I.PumpSpeed ) * ( P105_Flow_Rate_Correction)) ];
				RC: "Send Flowrate (mL/min) to Pump";
				N: XIC(P105_Speed_Update_Timer.EN)[XIC(P105.Sts_Oper) DIV(P105.Val_SpeedRef,P105_Flow_Rate_Correction,P105_Ethernet:O.SetSpeed) ,XIC(P105.Sts_Prog) [XIC(Perfusion_Running) MOV(P105.PSet_SpeedRef,P105_Ethernet:O.SetSpeed) ,XIC(P105_Dose_Running) DIV(P105_Dose_Speed_mlmin,P105_Flow_Rate_Correction,P105_Ethernet:O.SetSpeed) ] ];
		END_ROUTINE

		ROUTINE PBS_SIC401_PDI (Description := "PBS Agitator via PDI$N")
				RC: "Puts Drive in Profile Velocity Mode, Starting Drive";
				N: XIC(SIC401_Polarity_OK)MOV(23,SIC401_Drive:O1.Data[7]);
				RC: "Puts Drive in QuickStop, Stops Drive$N"
				    "";
				N: [XIC(SIC401.Out_Stop) ,XIC(Estop_Active_Flag) ][MOV(3,SIC401_Drive:O1.Data[7]) ,OTU(SIC401_Polarity_OK) ];
				RC: "Resets Drive and Clears Errors if Fault has Been Rectified";
				N: XIC(SIC401.Inp_Reset)MOV(2,SIC401_Drive:O1.Data[7]);
				RC: "Set Drive Polarity to Run In Forward or Reverse";
				N: [XIC(SIC401.Out_Start) ,XIC(SIC401_Polarity_Set) ][TON(SIC401_Polarity_Set_Timer,?,?) ,MOV(126,SIC401_Drive:O1.Data[4]) MOV(96,SIC401_Drive:O1.Data[5]) ,XIC(SIC401.Out_Fwd) [MOV(0,SIC401_Drive:O1.Data[0]) ,MOV(0,SIC401_Drive:O1.Data[1]) ,MOV(0,SIC401_Drive:O1.Data[2]) ,MOV(0,SIC401_Drive:O1.Data[3]) ] ,XIC(SIC401.Out_Rev) [MOV(64,SIC401_Drive:O1.Data[0]) ,MOV(0,SIC401_Drive:O1.Data[1]) ,MOV(0,SIC401_Drive:O1.Data[2]) ,MOV(0,SIC401_Drive:O1.Data[3]) ] ,XIO(SIC401_Polarity_Check) MOV(15,SIC401_Drive:O1.Data[7]) ]OTE(SIC401_Polarity_Set);
				RC: "Check Drive Polarity Before Starting (This could cause a desync between graphics and agitator)";
				N: XIC(SIC401_Polarity_Set_Timer.DN)[OTE(SIC401_Polarity_Check) ,TON(SIC401_Polarity_Check_Timer,?,?) ,MOV(14,SIC401_Drive:O1.Data[7]) ,[XIC(SIC401.Out_Fwd) EQU(0,SIC401_Drive:I1.Data[4]) ,XIC(SIC401.Out_Rev) EQU(64,SIC401_Drive:I1.Data[4]) ] [OTL(SIC401_Polarity_OK) ,OTU(SIC401_Polarity_Set) ] ,XIC(SIC401_Polarity_Check_Timer.DN) RES(SIC401_Polarity_Set_Timer) ];
				RC: "Selects Equation for Correct Speed to send to Drive";
				N: XIC(SIC401_Polarity_OK)[LEQ(SIC401.Val_SpeedRef,127) [MOV(SIC401.Val_SpeedRef,SIC401_Drive:O1.Data[0]) ,MOV(0,SIC401_Drive:O1.Data[1]) ] ,LIM(128,SIC401.Val_SpeedRef,255) [CPT(SIC401_Drive:O1.Data[0],( SIC401.Val_SpeedRef * -1 ) + ( 2 * ( SIC401.Val_SpeedRef - 128 ) )) ,MOV(0,SIC401_Drive:O1.Data[1]) ] ,LIM(256,SIC401.Val_SpeedRef,383) [CPT(SIC401_Drive:O1.Data[0],( SIC401.Val_SpeedRef - 256 )) ,MOV(1,SIC401_Drive:O1.Data[1]) ] ,LIM(384,SIC401.Val_SpeedRef,511) [CPT(SIC401_Drive:O1.Data[0],( SIC401.Val_SpeedRef * -1 ) + ( 2 * ( SIC401.Val_SpeedRef - 256 ) )) ,MOV(1,SIC401_Drive:O1.Data[1]) ] ,GEQ(SIC401.Val_SpeedRef,512) [CPT(SIC401_Drive:O1.Data[0],( SIC401.Val_SpeedRef - 512 )) ,MOV(2,SIC401_Drive:O1.Data[1]) ] ];
				RC: "Live Update Speed Timer";
				N: [XIC(SIC401.Sts_RunningFwd) ,XIC(SIC401.Sts_RunningRev) ,XIC(SIC401_Polarity_Set) ][TON(SIC401_Speed_Update_Timer,?,?) ,XIC(SIC401_Speed_Update_Timer.DN) [RES(SIC401_Speed_Update_Timer) ,OTE(SIC401_Drive:O1.Data[7].7) ] ];
				RC: "Run Logic for Graphics";
				N: XIO(Estop_Active_Flag)[XIC(SIC401.Out_Fwd) [OTE(SIC401.Inp_CommandDir) ,OTE(SIC401.Inp_ActualDir) ] ,XIC(SIC401.Out_Rev) [OTU(SIC401.Inp_ActualDir) ,OTU(SIC401.Inp_ActualDir) ] ];
				RC: "Update Graphics to reflect Estop state";
				N: XIC(Estop_Active_Flag)[OTE(SIC401.Out_Stop) ,OTU(SIC401.Out_Fwd) OTU(SIC401.Sts_RunningFwd) ,OTU(SIC401.Out_Rev) OTU(SIC401.Sts_RunningRev) ,MOV(1,SIC401.Val_Sts) ,MOV(0,SIC401.Val_SpeedFdbk) ];
				RC: "Alarms if Drive is Faulted";
				N: XIC(SIC401_Drive:I1.Data[2].2)OTE(SIC401_Drive_Fault);
		END_ROUTINE

		ROUTINE Perfusion_Control 
				N: XIC(Perfusion_Start)[OTL(Perfusion_On) ,OTE(P101.PCmd_Lock) OTE(P105.PCmd_Lock) ];
				N: [XIC(Estop_Active_Flag) ,XIC(Perfusion_Stop_Trigger) ,XIC(Comm_Loss_Stop) ,XIO(P101.Inp_IntlkOK) ,XIO(P105.Inp_IntlkOK) ][OTU(Perfusion_On) ,OTU(BRX_Level_Initialize) ,OTE(P101.PCmd_Unlock) OTE(P105.PCmd_Unlock) ];
				N: XIC(Perfusion_On)XIO(P101_Cal_Running)[OTE(Perfusion_Running) ,XIC(Level_Control_Enable) [CPT(P105.PSet_SpeedRef,ABS(( P101_Current_Speed * P101_Cal_Constant * 60 / P105_Flow_Rate_Correction ) * BRX_Level_Scaler.Out)) ,LIM(Level_Deadband_High_SP,LIT801.Val,Level_Deadband_Low_SP) OTU(BRX_Level_Initialize) ,LIM(Level_Deadband_Low_SP,LIT801.Val,Level_Deadband_High_SP) OTL(BRX_Level_Initialize) ] ,XIO(Level_Control_Enable) CPT(P105.PSet_SpeedRef,ABS(( P101_Current_Speed * P101_Cal_Constant * 60 / P105_Flow_Rate_Correction ))) OTL(BRX_Level_Initialize) ];
		END_ROUTINE

		ROUTINE PH_CAL (Description := "STATE MACHINE FOR PH CAL")
				RC: "Set ph cal state engine to Enable EEPROM$N"
				    "";
				N: XIC(ph_cal_start)[MOV(10,ph_cal_state_var) ,OTU(ph_cal_start) OTU(ph_cal_reset) ,COP(NULL_String,ph_cal_done_date,9) ];
				N: XIC(ph_cal_reset)[MOV(0,ph_cal_state_var) ,MOV(16#0002,ph_w_cal_control) ,COP(NULL_String,ph_cal_done_date,9) ,OTU(ph_cal_start) OTU(ph_cal_reset) ];
				RC: "PH Cal State: Idle/reset params$N"
				    "";
				N: EQU(ph_cal_state_var,0)[OTE(ph_cal_b_0_idle) ,MOV(0,ph_w_cal_control) ,MOV(0,ph_w_cal_offset) ,MOV(0,ph_w_cal_slope) ,MOV(0,ph_w_cal_process) ,MOV(12,ph_w_user_level) ,MOV(16#01145DEA,ph_w_user_password) ,MOV(0,ph_w_cal_unit_cal) ,MOV(1,ph_w_cal_stability) ,MOV(1,ph_w_cal_buffer_tab) ,MOV(0,ph_w_cal_date) ,MOV(0,ph_w_cal_time) ];
				RC: "PH Cal State: Set User Level to 1$N"
				    "";
				N: EQU(ph_cal_state_var,10)[OTE(ph_cal_b_10_set_user2) ,MOV(16#0000000C,ph_w_user_level) ,MOV(16#01145DEA,ph_w_user_password) ,MOV(20,ph_cal_state_var) ];
				RC: "Change User Level to 1";
				N: EQU(ph_cal_state_var,20)[OTE(ph_cal_b_20_set_user2_ack) ,EQU(ph_r_user_level,12) MOV(30,ph_cal_state_var) ];
				RC: "PH Cal State: Set params for Calibration";
				N: EQU(ph_cal_state_var,30)[OTE(ph_cal_b_30_set_pt1_params) ,TON(ph_cal_b_30_set_pt1_params_Timer,?,?) ,MOV(ph_w_cal_offset_input,ph_w_cal_offset) ,MOV(ph_w_cal_slope_input,ph_w_cal_slope) ,MOV(ph_w_cal_process_input,ph_w_cal_process) ,MOV(16#0000_0001,ph_w_cal_stability) ,MOV(16#0000_0001,ph_w_cal_buffer_tab) ,MOV(16#1809_2023,ph_w_cal_date) ,MOV(16#0000_1022,ph_w_cal_time) ,XIC(ph_cal_b_30_set_pt1_params_Timer.DN) MOV(40,ph_cal_state_var) ];
				RC: "Check Parmeters are Pushed to Probe. TBD Later.";
				N: EQU(ph_cal_state_var,40)[[OTE(ph_cal_b_40_check_params) ,TON(ph_cal_b_40_check_params_Timer,?,?) ] ,EQU(ph_w_cal_slope,ph_r_cal_slope) EQU(ph_w_cal_offset,ph_r_cal_offset) EQU(ph_w_cal_process,ph_r_cal_process) XIC(ph_cal_b_40_check_params_Timer.DN) MOV(50,ph_cal_state_var) ];
				RC: "Proceed to 2-Point Cal or Jump to 1-Point Cal";
				N: EQU(ph_cal_state_var,50)[OTE(ph_cal_b_50_cal_method) ,EQU(2,ph_w_cal_method) MOV(60,ph_cal_state_var) ,EQU(16,ph_w_cal_method) MOV(150,ph_cal_state_var) ];
				RC: "PH Cal State: Verify probe accepts cal params. Then continue 2pt cal or jump to 1 pt";
				N: EQU(ph_cal_state_var,60)[OTE(ph_cal_b_60_place_probe) ,XIC(pH_probe_placement_ready) MOV(16#01,ph_w_cal_control) MOV(70,ph_cal_state_var) ];
				RC: "Wait for Operator to Confirm Stable Reading";
				N: EQU(ph_cal_state_var,70)[OTE(ph_cal_b_70_wait_for_stability_pt1) ,XIC(pH_stability_ok) EQU(ph_r_cal_status,8) MOV(80,ph_cal_state_var) ];
				RC: "Save cal values and move to next step";
				N: EQU(ph_cal_state_var,80)[OTE(ph_cal_b_80_write_pt1) ,TON(ph_cal_b_80_write_pt1_Timer,?,?) ,MOV(3,ph_w_cal_control) ,XIC(ph_cal_b_80_write_pt1_Timer.DN) MOV(90,ph_cal_state_var) ];
				RC: "Waiting for Write to Finish Then Move to 2nd Point (Offset Cal)";
				N: EQU(ph_cal_state_var,90)[OTE(ph_cal_b_90_wait_pt1_write) ,EQU(ph_r_cal_status,2) MOV(0,ph_w_cal_control) MOV(100,ph_cal_state_var) ];
				RC: "2nd Point Cal Start";
				N: EQU(ph_cal_state_var,100)[OTE(ph_cal_b_100_start_pt2) ,EQU(ph_r_cal_status,1) [MOV(1,ph_w_cal_method) ,MOV(110,ph_cal_state_var) ] ];
				RC: "2nd Point Confirm Probe Placement then Start Cal";
				N: EQU(ph_cal_state_var,110)[OTE(ph_cal_b_110_place_probe_pt2) ,XIC(pH_probe_placement_ready) MOV(1,ph_w_cal_control) MOV(120,ph_cal_state_var) ];
				RC: "2nd Point Wait for Operator to Confirm Stability";
				N: EQU(ph_cal_state_var,120)[OTE(ph_cal_b_120_wait_for_stability_pt2) ,XIC(pH_stability_ok) EQU(ph_r_cal_status,8) MOV(130,ph_cal_state_var) ];
				RC: "Initiate Save";
				N: EQU(ph_cal_state_var,130)[OTE(ph_cal_b_130_write_pt2) ,TON(ph_cal_b_130_write_pt2_Timer,?,?) ,MOV(3,ph_w_cal_control) ,XIC(ph_cal_b_130_write_pt2_Timer.DN) MOV(140,ph_cal_state_var) ];
				RC: "Saving, go to complete when done";
				N: EQU(ph_cal_state_var,140)[OTE(ph_cal_b_140_wait_for_done) ,EQU(ph_r_cal_status,2) MOV(190,ph_cal_state_var) ];
				RC: "===============================$N"
				    "pH 1-Point Calibration$N"
				    "===============================";
				N: NOP();
				N: EQU(ph_cal_state_var,150)[OTE(ph_cal_b_150_place_probe_process) ,XIC(pH_probe_placement_ready) MOV(1,ph_w_cal_control) MOV(160,ph_cal_state_var) ];
				N: EQU(ph_cal_state_var,160)[OTE(ph_cal_b_160_wait_for_stability_process) ,XIC(pH_stability_ok) EQU(ph_r_cal_status,8) MOV(170,ph_cal_state_var) ];
				N: EQU(ph_cal_state_var,170)[OTE(ph_cal_b_170_write_process) ,TON(ph_cal_b_170_write_process_Timer,?,?) ,MOV(3,ph_w_cal_control) ,XIC(ph_cal_b_170_write_process_Timer.DN) MOV(180,ph_cal_state_var) ];
				N: EQU(ph_cal_state_var,180)[OTE(ph_cal_b_180_wait_for_done_process) ,EQU(ph_r_cal_status,2) MOV(190,ph_cal_state_var) ];
				N: EQU(ph_cal_state_var,190)[OTE(ph_cal_b_190_done_ok) ,MOV(cal_date,ph_cal_done_date) ];
				N: EQU(ph_cal_state_var,200)OTE(ph_cal_b_200_done_error);
				N: EQU(ph_cal_state_var,210)OTE(ph_cal_b_210_pwd_error);
		END_ROUTINE

		ROUTINE Pump_Interlock_Stops 
				RC: "When Communication with BRX is Lost, Repeatedly Send Stop Command to P101, P102, P103, and P104 until all 4 are stopped";
				N: [XIC(Comm_Loss_Stop) ,XIC(Estop_Active_Flag) ]XIO(Perfusion_On)XIO(BRX_Level_Initialize)XIO(ConditionedMedia_Initialize)XIO(BRX_Waiting_Comms)[TON(BRX_Waiting_Comms_Timer,?,?) ,XIC(BRX_Waiting_Comms_Timer.DN) [RES(BRX_Waiting_Comms_Timer) ,OTE(BRX_Comms_Retry_Stop) ] ,XIC(P101_Status_Code.In_Position) XIC(P102_Status_Code.In_Position) XIC(P103_Status_Code.In_Position) XIC(P104_Status_Code.In_Position) OTL(BRX_Waiting_Comms) ];
				N: XIO(Comm_Loss_Stop)OTU(BRX_Waiting_Comms);
				RC: "When BRX Level is HiHi, Repeat Stop Command to P101 and P103 until both are stopped.";
				N: XIC(LIT801.Alm_HiHi)XIO(BRX_HiHi_Stopped)[TON(BRX_HiHi_Stop_Timer,?,?) ,XIC(BRX_HiHi_Stop_Timer.DN) [RES(BRX_HiHi_Stop_Timer) ,OTE(BRX_HiHi_Retry_Stop) ] ,XIC(P101_Status_Code.In_Position) XIC(P103_Status_Code.In_Position) OTL(BRX_HiHi_Stopped) ];
				RC: "When BRX Level is LoLo, Repeat Stop Command to P104 until stopped.";
				N: XIC(LIT801.Alm_LoLo)XIO(BRX_LoLo_Stopped)[TON(BRX_LoLo_Stop_Timer,?,?) ,XIC(BRX_LoLo_Stop_Timer.DN) [RES(BRX_LoLo_Stop_Timer) ,OTE(BRX_LoLo_Retry_Stop) ] ,XIC(P104_Status_Code.In_Position) OTL(BRX_LoLo_Stopped) ];
				RC: "When Media Level is LoLo, Repeat Stop Command to P101 and P102 until both are stopped.";
				N: XIC(WT701.Alm_LoLo)XIO(Media_LoLo_Stopped)[TON(Media_LoLo_Stop_Timer,?,?) ,XIC(Media_LoLo_Stop_Timer.DN) [RES(Media_LoLo_Stop_Timer) ,OTE(Media_LoLo_Retry_Stop) ] ,XIC(P101_Status_Code.In_Position) XIC(P102_Status_Code.In_Position) OTL(Media_LoLo_Stopped) ];
				RC: "When Vessel Level is HiHi, Repeat Stop Command to P102 and P104 until both are stopped.";
				N: XIC(WT702.Alm_HiHi)XIO(MMV_HiHi_Stopped)[TON(MMV_HiHi_Stop_Timer,?,?) ,XIC(MMV_HiHi_Stop_Timer.DN) [RES(MMV_HiHi_Stop_Timer) ,OTE(MMV_HiHi_Retry_Stop) ] ,XIC(P102_Status_Code.In_Position) XIC(P104_Status_Code.In_Position) OTL(MMV_HiHi_Stopped) ];
				RC: "When Vessel Level is LoLo, Repeat Stop Command to P103 until stopped.";
				N: XIC(WT702.Alm_LoLo)XIO(MMV_LoLo_Stopped)[TON(MMV_LoLo_Stop_Timer,?,?) ,XIC(MMV_LoLo_Stop_Timer.DN) [RES(MMV_LoLo_Stop_Timer) ,OTE(MMV_LoLo_Retry_Stop) ] ,XIC(P103_Status_Code.In_Position) OTL(MMV_LoLo_Stopped) ];
		END_ROUTINE

		ROUTINE RL_DO (Description := "Propagate MT scale data")
				N: MOV(do_r_do,DOpbs.PV);
		END_ROUTINE

		ROUTINE RL_MTS (Description := "Propagate MT scale data")
				N: [MOV(MT_0_R_PV,WT701.Inp_PV) ,XIO(MT_0_R_DATA_OK) OTE(WT701.Inp_PVBad) ,XIO(MT_0_R_DATA_STABLE) OTE(WT701.Inp_PVUncertain) ,XIC(WT701_Zero_ACK) OTE(MT_0_W_ZERO) ,XIC(WT701_Tare_ACK) OTE(MT_0_W_TARE) ,EQU(MT_0_R_PV,0) TON(WT701_Zero_Timer,?,?) XIO(WT701_Zero_Timer.DN) OTE(WT701_Zero_DONE) ];
				N: [MOV(MT_1_R_PV,WT703.Inp_PV) ,XIO(MT_1_R_DATA_OK) OTE(WT703.Inp_PVBad) ,XIO(MT_1_R_DATA_STABLE) OTE(WT703.Inp_PVUncertain) ,XIC(WT703_Zero_ACK) OTE(MT_1_W_ZERO) ,XIC(WT703_Tare_ACK) OTE(MT_1_W_TARE) ,EQU(MT_1_R_PV,0) TON(WT703_Zero_Timer,?,?) XIO(WT703_Zero_Timer.DN) OTE(WT703_Zero_DONE) ];
		END_ROUTINE

		ROUTINE RL_PH (Description := "Propagate MT scale data")
				N: MOV(ph_r_ph,PHpbs.PV);
		END_ROUTINE

		ROUTINE RTD_Calibration 
				N: SUB(TT700_Ref1Point,TT700.Val,TT700_1Point_Offset);
				N: XIC(TT700_Accept1Point)ONS(ONS[0].8)NEQ(TT700_Ref1Point,TT700.Val)ADD(TT700_1Point_Offset,TT700.Cfg_PVEUMin,TT700_NewMin)ADD(TT700_1Point_Offset,TT700.Cfg_PVEUMax,TT700_NewMax)MOV(TT700_NewMin,TT700.Cfg_PVEUMin)MOV(TT700_NewMax,TT700.Cfg_PVEUMax)OTL(TT700_1Point_Complete);
				N: XIC(TT700_CalClear)MOV(100,TT700.Cfg_PVEUMax)MOV(0,TT700.Cfg_PVEUMin)OTU(TT700_2Point_Complete)OTU(TT700_1Point_Complete);
				N: XIC(TT700_2PointAccept)ONS(ONS[0].7)[MOV(TT700.Cfg_PVEUMin,TT700_MinCfg) MOV(TT700.Cfg_PVEUMax,TT700_MaxCfg) SUB(TT700_RawMax,TT700_RawMin,TT700_RawRange) SUB(TT700_RefMax,TT700_RefMin,TT700_RefRange) ,CPT(TT700.Cfg_PVEUMax,( TT700_MaxCfg - TT700_RawMin ) * ( TT700_RefRange / TT700_RawRange ) + TT700_RefMin) ,CPT(TT700.Cfg_PVEUMin,( TT700_MinCfg - TT700_RawMin ) * ( TT700_RefRange / TT700_RawRange ) + TT700_RefMin) OTL(TT700_2Point_Complete) ];
		END_ROUTINE

		ROUTINE SM_BRX_HiAdj 
				RC: "Stop State Machine as Needed (Estop, Cycle Stop, Fault, etc.)";
				N: XIC(Estop_Active_Flag)OTU(BRX_HiAdjEnable);
				RC: "Reset State Machine After Fault$N"
				    "Turn OFF State Machine by Putting in State 0$N"
				    "Turn OFF State Machine On Start-Up$N"
				    "Turn OFF State Machine if PID OFF$N"
				    "Turn OFF State Machine if Cal is Running";
				N: [XIC(BRX_HiAdj_Reset) ,XIO(BRX_HiAdjEnable) ,XIC(s:fs) ,XIO(ConditionedMedia_Initialize) ,XIC(P103_Cal.Cal_Running) ,XIC(P104_Cal.Cal_Running) ][MOV(0,BRX_HiAdj_State) ,OTU(BRX_HiAdj_Reset) ,OTU(BRX_HiAdjEnable) ];
				RC: "Prioritize MCV HI Adjust";
				N: GRT(MCV_HiAdj_State,10)MOV(10,BRX_HiAdj_State);
				RC: "State 0: State Machine OFF$N"
				    "Toggle Start Bit to Move to State 10 and Enable State Machine";
				N: EQU(BRX_HiAdj_State,0)[OTE(BRX_HiAdj_OFF) ,XIC(BRX_HiAdjEnable) MOV(10,BRX_HiAdj_State) [OTL(P103.PCmd_Prog) ,OTL(P104.PCmd_Prog) ] ];
				RC: "State 10: Idle$N"
				    "If the vessel weight PV exceeds the SP, move to State 20.";
				N: EQU(BRX_HiAdj_State,10)[OTE(BRX_HiAdj_Idle) ,LEQ(MCV_HiAdj_State,10) GRT(LIT801.Val,BRX_HiSP) MOV(20,BRX_HiAdj_State) ];
				RC: "State 20: Pump Speed Adjustment$N"
				    "P-104 Output is set to P-103 PV multiplied by BRX Hi Adjust speed ratio for BRX_HiAdjTimer time.$N"
				    "Move to State 30 when timer is done.$N"
				    "";
				N: EQU(BRX_HiAdj_State,20)[OTE(BRX_HiAdj_PumpAdj) ,CMP(ConditionedMedia_Scaler.Out*(Recirc_HiSP1/100)<P104.Cfg_MaxSpdRef) MOV(ConditionedMedia_Scaler.Out,P103.PSet_SpeedRef) CPT(P104.PSet_SpeedRef,ConditionedMedia_Scaler.Out*(Recirc_HiSP1/100)) ,CMP(ConditionedMedia_Scaler.Out*(Recirc_HiSP1/100)>P104.Cfg_MaxSpdRef) CPT(P103.PSet_SpeedRef,P103.Cfg_MaxSpdRef/(Recirc_HiSP1/100)) CPT(P104.PSet_SpeedRef,P104.Cfg_MaxSpdRef) ,TON(BRX_HiAdjTimer,?,?) ,XIC(BRX_HiAdjTimer.DN) MOV(30,BRX_HiAdj_State) ];
				RC: "Step 30: Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured BRX Hi Adjust Weight go to State 50.$N"
				    "If Vessel weight PV exceeds configured BRX Hi Adjust Weight go to State 40.";
				N: EQU(BRX_HiAdj_State,30)[OTE(BRX_HiAdj_Assess1) ,LES(LIT801.Val,BRX_HiSP) MOV(10,BRX_HiAdj_State) ,GEQ(LIT801.Val,BRX_HiSP) MOV(40,BRX_HiAdj_State) ];
				RC: "Step 40: Buffer$N"
				    "P104 Wait 10 seconds for BRX level reading to stabilize, then proceed to State 50.";
				N: EQU(BRX_HiAdj_State,40)[OTE(BRX_HiAdj_Buffer) ,[MOV(P103.PSet_SpeedRef,P104.PSet_SpeedRef) ,MOV(P103.PSet_SpeedRef,P104.Val_SpeedFdbk) ] ,OTU(P103.PCmd_StartFwd) OTL(P103.PCmd_Stop) ,OTU(P104.PCmd_StartFwd) OTL(P104.PCmd_Stop) ,TON(BRX_HiAdj_Stability_Timer,?,?) ,XIC(BRX_HiAdj_Stability_Timer.DN) MOV(50,BRX_HiAdj_State) ];
				RC: "Step 50: Post Buffer Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured BRX Hi Adjust Weight go to State 10.$N"
				    "If Vessel weight PV exceeds configured BRX Hi Adjust Weight go to State 20.";
				N: EQU(BRX_HiAdj_State,50)[OTE(BRX_HiAdj_Assess2) ,LES(LIT801.Val,BRX_HiSP) MOV(10,BRX_HiAdj_State) ,GEQ(LIT801.Val,BRX_HiSP) MOV(20,BRX_HiAdj_State) ];
		END_ROUTINE

		ROUTINE SM_BRX_LoAdj 
				RC: "Stop State Machine as Needed (Estop, Cycle Stop, Fault, etc.)";
				N: XIC(Estop_Active_Flag)OTU(BRX_LoAdjEnable);
				RC: "Reset State Machine After Fault$N"
				    "Turn OFF State Machine by Putting in State 0$N"
				    "Turn OFF State Machine On Start-Up$N"
				    "Turn OFF State Machine if PID OFF$N"
				    "Turn OFF State Machine if Cal is Running";
				N: [XIC(BRX_LoAdj_Reset) ,XIO(BRX_LoAdjEnable) ,XIC(s:fs) ,XIO(ConditionedMedia_Initialize) ,XIC(P103_Cal.Cal_Running) ,XIC(P104_Cal.Cal_Running) ][MOV(0,BRX_LoAdj_State) ,OTU(BRX_LoAdj_Reset) ,OTU(BRX_LoAdjEnable) ];
				RC: "Prioritize MCV HI Adjust";
				N: GRT(MCV_HiAdj_State,10)MOV(10,BRX_LoAdj_State);
				RC: "State 0: State Machine OFF$N"
				    "Toggle Start Bit to Move to State 10 and Enable State Machine";
				N: EQU(BRX_LoAdj_State,0)[OTE(BRX_HLoAdj_OFF) ,XIC(BRX_LoAdjEnable) MOV(10,BRX_LoAdj_State) [OTL(P103.PCmd_Prog) ,OTL(P104.PCmd_Prog) ] ];
				RC: "State 10: Idle$N"
				    "If the vessel weight PV is less than the SP, move to State 20.";
				N: EQU(BRX_LoAdj_State,10)[OTE(BRX_LoAdj_Idle) ,LEQ(MCV_HiAdj_State,10) LES(LIT801.Val,BRX_LoSP) MOV(20,BRX_LoAdj_State) ];
				RC: "State 20: Pump Speed Adjustment$N"
				    "P-104 Output is set to P-103 PV multiplied by BRX LoAdjust speed ratio for BRX_LoAdjTimer time.$N"
				    "Move to State 30 when timer is done.";
				N: EQU(BRX_LoAdj_State,20)[OTE(BRX_LoAdj_PumpAdj) ,MOV(ConditionedMedia_Scaler.Out,P103.PSet_SpeedRef) CPT(P104.PSet_SpeedRef,ConditionedMedia_Scaler.Out * ( Recirc_LoSP2 / 100 )) ,TON(BRX_LoAdjTimer,?,?) ,XIC(BRX_LoAdjTimer.DN) MOV(30,BRX_LoAdj_State) ];
				RC: "Step 30: Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured BRX Lo Adjust Weight go to State 40.$N"
				    "If Vessel weight PV exceeds configured BRX LoAdjust Weight go to State 50.";
				N: EQU(BRX_LoAdj_State,30)[OTE(BRX_LoAdj_Assess1) ,LES(LIT801.Val,BRX_LoSP) MOV(40,BRX_LoAdj_State) ,GEQ(LIT801.Val,BRX_LoSP) MOV(50,BRX_LoAdj_State) ];
				RC: "Step 40: Buffer$N"
				    "Wait 10 seconds for MCV weight reading to stabilize, then proceed to State 50.";
				N: EQU(BRX_LoAdj_State,40)[OTE(BRX_LoAdj_Buffer) ,[MOV(P103.PSet_SpeedRef,P104.PSet_SpeedRef) ,MOV(P103.PSet_SpeedRef,P104.Val_SpeedFdbk) ] ,TON(BRX_LoAdj_Stability_Timer,?,?) ,XIC(BRX_LoAdj_Stability_Timer.DN) MOV(50,BRX_LoAdj_State) ];
				RC: "Step 50: Post Buffer Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured BRX Lo Adjust Weight go to State 20.$N"
				    "If Vessel weight PV exceeds configured BRX Lo Adjust Weight go to State 10.";
				N: EQU(BRX_LoAdj_State,50)[OTE(BRX_LoAdj_Assess2) ,GEQ(LIT801.Val,BRX_LoSP) MOV(10,BRX_LoAdj_State) ,LES(LIT801.Val,BRX_LoSP) MOV(20,BRX_LoAdj_State) ];
		END_ROUTINE

		ROUTINE SM_MCV_HiAdj 
				RC: "Stop State Machine as Needed (Estop, Cycle Stop, Fault, etc.)";
				N: XIC(Estop_Active_Flag)OTU(MCV_HiAdjEnable);
				RC: "Reset State Machine After Fault$N"
				    "Turn OFF State Machine by Putting in State 0$N"
				    "Turn OFF State Machine On Start-Up$N"
				    "Turn OFF State Machine if PID OFF$N"
				    "Turn OFF State Machine if Cal is Running";
				N: [XIC(MCV_HiAdj_Reset) ,XIO(MCV_HiAdjEnable) ,XIC(s:fs) ,XIO(ConditionedMedia_Initialize) ,XIC(P103_Cal.Cal_Running) ,XIC(P104_Cal.Cal_Running) ][MOV(0,MCV_HiAdj_State) ,OTU(MCV_HiAdj_Reset) ,OTU(MCV_HiAdjEnable) ];
				RC: "State 0: State Machine OFF$N"
				    "Toggle Start Bit to Move to State 10 and Enable State Machine";
				N: EQU(MCV_HiAdj_State,0)[OTE(MCV_HiAdj_OFF) ,XIC(MCV_HiAdjEnable) MOV(10,MCV_HiAdj_State) [OTL(P103.PCmd_Prog) ,OTL(P104.PCmd_Prog) ] ];
				RC: "State 10: Idle$N"
				    "If the vessel weight PV exceeds the SP, move to State 20.";
				N: EQU(MCV_HiAdj_State,10)[OTE(MCV_HiAdj_Idle) ,GRT(WT702.Val,MCV_HiSP) MOV(20,MCV_HiAdj_State) ];
				RC: "State 20: Pump Speed Adjustment$N"
				    "P-104 Output is set to P-103 PV multiplied by MCV Hi Adjust speed ratio for MCV_HiAdjTimer time.$N"
				    "Move to State 30 when timer is done.$N"
				    "";
				N: EQU(MCV_HiAdj_State,20)[OTE(MCV_HiAdj_PumpAdj) ,MOV(ConditionedMedia_Scaler.Out,P103.PSet_SpeedRef) CPT(P104.PSet_SpeedRef,ConditionedMedia_Scaler.Out * ( Recirc_LoSP1 / 100 )) ,TON(MCV_HiAdjTimer,?,?) ,XIC(MCV_HiAdjTimer.DN) MOV(30,MCV_HiAdj_State) ];
				RC: "Step 30: Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured MCV Hi Adjust Weight go to State 50.$N"
				    "If Vessel weight PV exceeds configured MCV Hi Adjust Weight go to State 40.";
				N: EQU(MCV_HiAdj_State,30)[OTE(MCV_HiAdj_Assess1) ,GEQ(WT702.Val,MCV_HiSP) MOV(40,MCV_HiAdj_State) ,LES(WT702.Val,MCV_HiSP) MOV(10,MCV_HiAdj_State) ];
				RC: "Step 40: Buffer$N"
				    "Wait 10 seconds for MCV weight reading to stabilize, then proceed to State 50.";
				N: EQU(MCV_HiAdj_State,40)[OTE(MCV_HiAdj_Buffer) ,MOV(P103.PSet_SpeedRef,P104.PSet_SpeedRef) ,TON(MCV_HiAdj_Stability_Timer,?,?) ,XIC(MCV_HiAdj_Stability_Timer.DN) MOV(50,MCV_HiAdj_State) ];
				RC: "Step 50: Post Buffer Assess Vessel Level$N"
				    "If Vessel weight PV is less than configured MCV Hi Adjust Weight go to State 10.$N"
				    "If Vessel weight PV exceeds configured MCV Hi Adjust Weight go to State 20.";
				N: EQU(MCV_HiAdj_State,50)[OTE(MCV_HiAdj_Assess2) ,GEQ(WT702.Val,MCV_HiSP) MOV(20,MCV_HiAdj_State) ,LES(WT702.Val,MCV_HiSP) MOV(10,MCV_HiAdj_State) ];
		END_ROUTINE

		ROUTINE Wago_Comms 
				RC: "===========================================================$N"
				    "Inputs$N"
				    "===========================================================";
				N: NOP();
				RC: "Slot 1 Analog Input$N"
				    "Grabs and Stores Analog Input Data for Temperature probes from Wago";
				N: COP(Wago_IO:I2.Data[0],Slot1_RTD_WAGO461_Inputs[0],4);
				N: WAGO_461(Slot1_RTD_WAGO461,Slot1_RTD_WAGO461_Inputs,0,0);
				RC: "Slot 2 Analog Input$N"
				    "Grabs and Stores Analog Input Data for pH and DO probes from Wago";
				N: COP(Wago_IO:I2.Data[4],Slot2_AI_WAGO455_Inputs[0],8);
				N: WAGO_455(Slot2_AI_WAGO455,Slot2_AI_WAGO455_Inputs);
				RC: "===========================================================$N"
				    "Outputs$N"
				    "===========================================================";
				N: NOP();
				N: COP(Slot3_AO_WAGO559_Outputs[0],Wago_IO:O2.Data[0],8);
				RC: "Slot 3$N"
				    "Grab and Stor Analog Output Values";
				N: WAGO_559(Slot3_AO_WAGO559,Slot3_AO_WAGO559_Outputs);
		END_ROUTINE

		FBD_ROUTINE Wago_Signal_Scaling (Description := "Scale Wago Signals",
		                                 SheetSize := "Tabloid - 11 x 17 in",
		                                 SheetOrientation := Landscape)
			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 200,
				       Y := 320,
				       Operand := "Heater_Output.Val_CVOut",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 220,
				       Y := 100,
				       Operand := "Slot2_AI_WAGO455.Ch1_Value",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 220,
				       Y := 220,
				       Operand := "Slot2_AI_WAGO455.Ch2_Value",
				       HideDescription := No)
				END_IREF

				OREF  (ID := 3,
				       X := 480,
				       Y := 220,
				       Operand := "DO_Normalized",
				       HideDescription := No)
				END_OREF

				OREF  (ID := 4,
				       X := 500,
				       Y := 320,
				       Operand := "Slot3_AO_WAGO559.Ch1_Voltage",
				       HideDescription := No)
				END_OREF

				OREF  (ID := 5,
				       X := 480,
				       Y := 100,
				       Operand := "pH_Normalized",
				       HideDescription := No)
				END_OREF

				SCL_BLOCK  (ID := 6,
				            X := 340,
				            Y := 200,
				            Operand := "DO_Scale",
				            VisiblePins := "In, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				SCL_BLOCK  (ID := 7,
				            X := 320,
				            Y := 300,
				            Operand := "HCR01_Scale",
				            VisiblePins := "In, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				SCL_BLOCK  (ID := 8,
				            X := 340,
				            Y := 80,
				            Operand := "pH_Scale",
				            VisiblePins := "In, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 7,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 8,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 6,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "Out",
				       ToElementID := 3,
				       ToParameter := "")
				END_WIRE

				WIRE  (FromElementID := 7,
				       FromParameter := "Out",
				       ToElementID := 4,
				       ToParameter := "")
				END_WIRE

				WIRE  (FromElementID := 8,
				       FromParameter := "Out",
				       ToElementID := 5,
				       ToParameter := "")
				END_WIRE

			END_SHEET

		END_FBD_ROUTINE

		CHILD_PROGRAMS
		END_CHILD_PROGRAMS

	END_PROGRAM

	PROGRAM PIDs (MAIN := "Main",
	              MODE := 0,
	              DisableFlag := 0,
	              UseAsFolder := 0)
		TAG
			ADD_01 : FBD_MATH  := [3,1.00000000e+000,5.00000000e-001,1.50000000e+000];
			BOR_01 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
			BOR_02 : FBD_BOOLEAN_OR  := [1,0,5.60519386e-045];
			BOR_03 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
			BOR_04 : FBD_BOOLEAN_OR  := [5,3,5.60519386e-045];
			BOR_05 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
			BOR_06 : FBD_BOOLEAN_OR  := [1,1,5.60519386e-045];
			DIV_01 : FBD_MATH  := [3,5.00000000e+001,1.00000000e+002,5.00000000e-001];
			GRT_01 : FBD_COMPARE  := [1,0.00000000e+000,0.00000000e+000];
			OSRI_01 : FBD_ONESHOT  := [1,0,5.60519386e-045];
			PIDE_01 : PID_ENHANCED  := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
					,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
					,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
					,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					];
			PIDE_02 : PID_ENHANCED  := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
					,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
					,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
					,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					];
			PIDE_03 : PID_ENHANCED  := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
					,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
					,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
					,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					];
			PIDE_04 : PID_ENHANCED  := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
					,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
					,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
					,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					];
			PIDE_05 : PID_ENHANCED  := [1,8192,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,1.00000000e+002,0.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000,1.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,1.00000000e+002
					,0.00000000e+000,1.00000000e+002,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,3.40282347e+038
					,3.40282347e+038,-3.40282347e+038,-3.40282347e+038,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,3.40282347e+038,3.40282347e+038,3.40282347e+038,3.40282347e+038,0.00000000e+000
					,0,0.00000000e+000,1,0,0,0,0,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0,0,5.60519386e-045
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000
					];
			SCL_01 : SCALE  := [1,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0.00000000e+000,0,0.00000000e+000
					,0,5.60519386e-045,0.00000000e+000,0.00000000e+000,0.00000000e+000];
			SEL_01 : SELECT  := [3,3.00000000e+002,1.00000000e+002,1,1.00000000e+002,5.60519386e-045];
			SEL_02 : SELECT  := [3,3.00000000e+002,7.00000000e+001,1,7.00000000e+001,5.60519386e-045];
			SEL_03 : SELECT  := [1,1.00000000e+002,2.79999995e+000,1,1.00000000e+002,5.60519386e-045];
			SEL_04 : SELECT  := [1,1.00000000e+002,1.00000000e+000,1,1.00000000e+002,5.60519386e-045];
			SEL_05 : SELECT  := [1,6.00000000e+001,0.00000000e+000,1,6.00000000e+001,5.60519386e-045];
			SUB_01 : FBD_MATH  := [3,1.00000000e+000,5.00000000e-001,5.00000000e-001];
		END_TAG

		ROUTINE GasControl 
				N: XIC(GasControl_ON)ONS(GasOnOns)[OTU(FIC140.PCmd_Unlock) OTU(FIC130.PCmd_Unlock) OTU(FIC120.PCmd_Unlock) OTU(FIC110.PCmd_Unlock) ,OTL(FIC140.PCmd_Lock) OTL(FIC130.PCmd_Lock) OTL(FIC120.PCmd_Lock) OTL(FIC110.PCmd_Lock) ];
				N: XIO(GasControl_ON)ONS(GasOffOns)[OTU(FIC110.PCmd_Lock) OTU(FIC120.PCmd_Lock) OTU(FIC130.PCmd_Lock) OTU(FIC140.PCmd_Lock) ,OTL(FIC110.PCmd_Unlock) OTL(FIC120.PCmd_Unlock) OTL(FIC130.PCmd_Unlock) OTL(FIC140.PCmd_Unlock) OTL(pH_Initialize) OTL(DOPID_INITIALIZE) ];
				RC: "Logic for Deviation Alarms";
				N: XIC(GasControl_ON)CPT(Total_Gas_Val_Pos,FIC110.Val_Pos+FIC120.Val_Pos+FIC130.Val_Pos+FIC140.Val_Pos)[ADD(TotalFlowSP,Total_Gas_HiDev,Total_Gas_HiDev_Limit) ,SUB(TotalFlowSP,Total_Gas_LoDev,Total_Gas_LoDev_Limit) ]LIM(Total_Gas_HiDev_Limit,Total_Gas_Val_Pos,Total_Gas_LoDev_Limit)[TON(Total_Gas_Dev_Timer,?,?) ,XIC(Total_Gas_Dev_Timer.DN) [GRT(Total_Gas_Val_Pos,Total_Gas_HiDev_Limit) OTE(Total_Gas_Alm_HiDev) ,LES(Total_Gas_Val_Pos,Total_Gas_LoDev_Limit) OTE(Total_Gas_Alm_LoDev) ] ];
				N: LES(FIC120.Cfg_CVEUMax,TotalFlowSP)CPT(O2MaxCalc,FIC120.Cfg_CVEUMax /TotalFlowSP);
				N: GEQ(FIC120.Cfg_CVEUMax,TotalFlowSP)MOV(1,O2MaxCalc);
				N: LES(FIC140.Cfg_CVEUMax,TotalFlowSP)CPT(N2MaxCalc,FIC140.Cfg_CVEUMax/TotalFlowSP);
				N: GEQ(FIC140.Cfg_CVEUMax,TotalFlowSP)MOV(1,N2MaxCalc);
				N: LES(FIC130.Cfg_CVEUMax,TotalFlowSP)CPT(CO2MaxCalc,FIC130.Cfg_CVEUMax/TotalFlowSP);
				N: GEQ(FIC130.Cfg_CVEUMax,TotalFlowSP)MOV(1,CO2MaxCalc);
				N: LES(FIC110.Cfg_CVEUMax,TotalFlowSP)CPT(CCAMaxCalc,FIC110.Cfg_CVEUMax/TotalFlowSP);
				N: GEQ(FIC110.Cfg_CVEUMax,TotalFlowSP)MOV(1,CCAMaxCalc);
				N: XIC(CO2ProgOper)MOV(CO2ManualSP,CO2PercentOut);
				N: XIO(CO2ProgOper)MOV(C02Scaler.Out,CO2PercentOut);
				N: XIC(O2ProgOper)CMP(( O2ManualSP + CO2PercentOut ) <= 1)MOV(O2ManualSP,O2PercentOut);
				N: XIC(O2ProgOper)CMP(( O2ManualSP + CO2PercentOut) > 1)CPT(O2PercentOut,O2ManualSP-( O2ManualSP + CO2PercentOut - 1));
				N: XIO(O2ProgOper)CMP(( O2Scaler.Out + CO2PercentOut) > 1)CPT(O2PercentOut,O2Scaler.Out-( O2Scaler.Out + CO2PercentOut - 1));
				N: XIO(O2ProgOper)CMP(( O2Scaler.Out + CO2PercentOut) <= 1)MOV(O2Scaler.Out,O2PercentOut);
				N: XIO(N2ProgOper)CMP(( O2PercentOut + CO2PercentOut + N2Scaler.Out) > 1)CPT(N2PercentOut,N2Scaler.Out-( O2PercentOut + CO2PercentOut + N2Scaler.Out - 1));
				N: XIO(N2ProgOper)CMP(( O2PercentOut + CO2PercentOut + N2Scaler.Out) <= 1)MOV(N2Scaler.Out,N2PercentOut);
				N: XIC(N2ProgOper)CMP(( O2PercentOut + CO2PercentOut + N2ManualSP ) <= 1)MOV(N2ManualSP,N2PercentOut);
				N: XIC(N2ProgOper)CMP(( O2PercentOut + CO2PercentOut + N2ManualSP) > 1)CPT(N2PercentOut,N2ManualSP-( N2ManualSP + CO2PercentOut + O2PercentOut- 1));
				N: [XIO(AirProgOper) ,XIC(AirProgOper) ]CMP(( O2PercentOut + CO2PercentOut + N2PercentOut ) <= 1)CPT(AirPercentOut,1- ( N2PercentOut + O2PercentOut + CO2PercentOut ));
				N: AFI()XIO(AirProgOper)CMP(( O2PercentOut + CO2PercentOut + N2PercentOut ) = 1)MOV(0,AirPercentOut);
				N: AFI()XIC(AirProgOper)CMP(( O2PercentOut + CO2PercentOut + N2PercentOut + AirManualSP) > 1)CPT(AirPercentOut,AirManualSP-( N2PercentOut + CO2PercentOut + O2PercentOut + AirManualSP - 1));
				N: XIC(GasControl_ON)MUL(N2PercentOut,TotalFlowSP,FIC140.PSet_CV)MUL(CO2PercentOut,TotalFlowSP,FIC130.PSet_CV)MUL(AirPercentOut,TotalFlowSP,FIC110.PSet_CV)MUL(O2PercentOut,TotalFlowSP,FIC120.PSet_CV);
				N: XIO(GasControl_ON)MUL(N2PercentOut,0,FIC140.PSet_CV)MUL(CO2PercentOut,0,FIC130.PSet_CV)MUL(AirPercentOut,0,FIC110.PSet_CV)MUL(O2PercentOut,0,FIC120.PSet_CV);
				N: [DIV(O2EUMax_Inp,100,O2EUMax) GRT(O2EUMax,O2MaxCalc) MOV(O2MaxCalc,O2EUMax) ,DIV(N2EUMax_Inp,100,N2EUMax) GRT(N2EUMax,N2MaxCalc) MOV(N2MaxCalc,N2EUMax) ,DIV(CO2EUMax_Inp,100,CO2EUMax) GRT(CO2EUMax,CO2MaxCalc) MOV(CO2MaxCalc,CO2EUMax) ];
				N: [DIV(O2EUMin_Inp,100,O2EUMin) ,DIV(N2EUMin_Inp,100,N2EUMin) ,DIV(CO2EUMin_Inp,100,CO2EUMin) ];
				N: [DIV(CO2ManualSP_Inp,100,CO2ManualSP) GRT(CO2ManualSP,CO2MaxCalc) MOV(CO2MaxCalc,CO2ManualSP) ,DIV(O2ManualSP_Inp,100,O2ManualSP) GRT(O2ManualSP,O2MaxCalc) MOV(O2MaxCalc,O2ManualSP) ,DIV(N2ManualSP_Inp,100,N2ManualSP) GRT(N2ManualSP,N2MaxCalc) MOV(N2MaxCalc,N2ManualSP) ,DIV(AirManualSP_Inp,100,AirManualSP) GRT(AirManualSP,CCAMaxCalc) MOV(CCAMaxCalc,AirManualSP) ];
				N: [DIV(O2EUMax_Inp,100,O2EUMax) GRT(O2EUMax,O2MaxCalc) MOV(O2MaxCalc,O2EUMax) ,DIV(N2EUMax_Inp,100,N2EUMax) GRT(N2EUMax,N2MaxCalc) MOV(N2MaxCalc,N2EUMax) ,DIV(CO2EUMax_Inp,100,CO2EUMax) GRT(CO2EUMax,CO2MaxCalc) MOV(CO2MaxCalc,CO2EUMax) ];
				N: [DIV(O2EUMin_Inp,100,O2EUMin) ,DIV(N2EUMin_Inp,100,N2EUMin) ,DIV(CO2EUMin_Inp,100,CO2EUMin) ];
				N: [DIV(CO2ManualSP_Inp,100,CO2ManualSP) GRT(CO2ManualSP,CO2MaxCalc) MOV(CO2MaxCalc,CO2ManualSP) ,DIV(O2ManualSP_Inp,100,O2ManualSP) GRT(O2ManualSP,O2MaxCalc) MOV(O2MaxCalc,O2ManualSP) ,DIV(N2ManualSP_Inp,100,N2ManualSP) GRT(N2ManualSP,N2MaxCalc) MOV(N2MaxCalc,N2ManualSP) ,DIV(AirManualSP_Inp,100,AirManualSP) GRT(AirManualSP,CCAMaxCalc) MOV(CCAMaxCalc,AirManualSP) ];
				N: XIC(Estop_Active_Flag)OTU(GasControl_ON);
		END_ROUTINE

		ROUTINE Main 
				N: JSR(PBS,0);
				N: JSR(GasControl,0);
				N: JSR(TempControl,0);
		END_ROUTINE

		FBD_ROUTINE PBS (SheetSize := "Tabloid - 11 x 17 in",
		                 SheetOrientation := Landscape)
			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 120,
				       Y := 280,
				       Operand := "0",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 540,
				       Y := 280,
				       Operand := "0",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 140,
				       Y := 520,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 3,
				       X := 580,
				       Y := 480,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 4,
				       X := 140,
				       Y := 180,
				       Operand := "AT701.Val",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 5,
				       X := 580,
				       Y := 180,
				       Operand := "AT702.Val",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 6,
				       X := 960,
				       Y := 500,
				       Operand := "CO2CVMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 7,
				       X := 960,
				       Y := 520,
				       Operand := "CO2CVMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 8,
				       X := 980,
				       Y := 540,
				       Operand := "CO2EUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 9,
				       X := 960,
				       Y := 560,
				       Operand := "CO2EUMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 10,
				       X := 120,
				       Y := 260,
				       Operand := "DOPID_INITIALIZE",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 11,
				       X := 120,
				       Y := 380,
				       Operand := "DO_CVEUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 12,
				       X := 120,
				       Y := 420,
				       Operand := "DO_CVEUMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 13,
				       X := 160,
				       Y := 460,
				       Operand := "DO_HiDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 14,
				       X := 160,
				       Y := 480,
				       Operand := "DO_LoDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 15,
				       X := 100,
				       Y := 140,
				       Operand := "DO_ON",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 16,
				       X := 200,
				       Y := 760,
				       Operand := "DO_PID_AUTOREQ",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 17,
				       X := 140,
				       Y := 320,
				       Operand := "ManualDO_CV",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 18,
				       X := 580,
				       Y := 320,
				       Operand := "ManualpH_CV",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 19,
				       X := 960,
				       Y := 340,
				       Operand := "N2CVMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 20,
				       X := 960,
				       Y := 360,
				       Operand := "N2CVMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 21,
				       X := 960,
				       Y := 380,
				       Operand := "N2EUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 22,
				       X := 960,
				       Y := 400,
				       Operand := "N2EUMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 23,
				       X := 960,
				       Y := 180,
				       Operand := "O2CVMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 24,
				       X := 960,
				       Y := 200,
				       Operand := "O2CVMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 25,
				       X := 960,
				       Y := 220,
				       Operand := "O2EUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 26,
				       X := 960,
				       Y := 240,
				       Operand := "O2EUMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 27,
				       X := 560,
				       Y := 160,
				       Operand := "PH_On",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 28,
				       X := 540,
				       Y := 380,
				       Operand := "pH_CVEUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 29,
				       X := 540,
				       Y := 400,
				       Operand := "pH_CVEUMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 30,
				       X := 580,
				       Y := 440,
				       Operand := "pH_HiDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 31,
				       X := 600,
				       Y := 260,
				       Operand := "pH_Initialize",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 32,
				       X := 580,
				       Y := 420,
				       Operand := "pH_LoDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 33,
				       X := 660,
				       Y := 720,
				       Operand := "pH_PID_AUTOREQ",
				       HideDescription := No)
				END_IREF

				BOR_BLOCK  (ID := 34,
				            X := 100,
				            Y := 0,
				            Operand := "BOR_05",
				            VisiblePins := "In1, In2, Out",
				            HideDescription := No)
				END_BOR_BLOCK

				BOR_BLOCK  (ID := 35,
				            X := 520,
				            Y := 20,
				            Operand := "BOR_06",
				            VisiblePins := "In1, In2, Out",
				            HideDescription := No)
				END_BOR_BLOCK

				PIDE_BLOCK  (ID := 36,
				             X := 200,
				             Y := 100,
				             Operand := "DOpbs",
				             VisiblePins := "EnableIn, PV, SPProg, SPCascade, RatioProg, CVInitReq, CVInitValue, CVProg, CVOper, CVPrevious, CVSetPrevious, CVEUMax, CVEUMin, FF, HandFB, DevHLimit, DevLLimit, ProgProgReq, ProgOperReq, ProgCasRatReq, ProgAutoReq, ProgManualReq, ProgOverrideReq, ProgHandReq, OperProgReq, OperOperReq, OperAutoReq, OperManualReq, CVEU, CV, CVHAlarm, CVLAlarm, SP, PVHHAlarm, PVHAlarm, PVLAlarm, PVLLAlarm, PVROCPosAlarm, PVROCNegAlarm, DevHHAlarm, DevHAlarm, DevLAlarm, DevLLAlarm, ProgOper, CasRat, Auto, Manual, Override, Hand",
				             HideDescription := No,
				             AutotuneTag := "")
				END_PIDE_BLOCK

				PIDE_BLOCK  (ID := 37,
				             X := 620,
				             Y := 100,
				             Operand := "PHpbs",
				             VisiblePins := "EnableIn, PV, SPProg, SPCascade, RatioProg, CVInitReq, CVInitValue, CVProg, CVOper, CVPrevious, CVSetPrevious, CVEUMax, CVEUMin, FF, HandFB, DevHLimit, DevLLimit, ProgProgReq, ProgOperReq, ProgCasRatReq, ProgAutoReq, ProgManualReq, ProgOverrideReq, ProgHandReq, OperProgReq, OperOperReq, OperAutoReq, OperManualReq, CVEU, CV, CVHAlarm, CVLAlarm, SP, PVHHAlarm, PVHAlarm, PVLAlarm, PVLLAlarm, PVROCPosAlarm, PVROCNegAlarm, DevHHAlarm, DevHAlarm, DevLAlarm, DevLLAlarm, ProgOper, CasRat, Auto, Manual, Override, Hand",
				             HideDescription := No,
				             AutotuneTag := "")
				END_PIDE_BLOCK

				SCL_BLOCK  (ID := 38,
				            X := 1040,
				            Y := 420,
				            Operand := "C02Scaler",
				            VisiblePins := "In, InRawMax, InRawMin, InEUMax, InEUMin, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				SCL_BLOCK  (ID := 39,
				            X := 1040,
				            Y := 260,
				            Operand := "N2Scaler",
				            VisiblePins := "In, InRawMax, InRawMin, InEUMax, InEUMin, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				SCL_BLOCK  (ID := 40,
				            X := 1040,
				            Y := 100,
				            Operand := "O2Scaler",
				            VisiblePins := "In, InRawMax, InRawMin, InEUMax, InEUMin, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				BNOT_FUNCTION  (ID := 41,
				                X := 80,
				                Y := 600)
				END_BNOT_FUNCTION

				BNOT_FUNCTION  (ID := 42,
				                X := 720,
				                Y := 720)
				END_BNOT_FUNCTION

				NEG_FUNCTION  (ID := 43,
				               X := 920,
				               Y := 280)
				END_NEG_FUNCTION

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "CVInitValue")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "CVInitValue")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "ProgOperReq")
				END_WIRE

				WIRE  (FromElementID := 3,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "ProgOperReq")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "PV")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "PV")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "",
				       ToElementID := 38,
				       ToParameter := "InRawMax")
				END_WIRE

				WIRE  (FromElementID := 7,
				       FromParameter := "",
				       ToElementID := 38,
				       ToParameter := "InRawMin")
				END_WIRE

				WIRE  (FromElementID := 8,
				       FromParameter := "",
				       ToElementID := 38,
				       ToParameter := "InEUMax")
				END_WIRE

				WIRE  (FromElementID := 9,
				       FromParameter := "",
				       ToElementID := 38,
				       ToParameter := "InEUMin")
				END_WIRE

				WIRE  (FromElementID := 10,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "CVInitReq")
				END_WIRE

				WIRE  (FromElementID := 11,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "CVEUMax")
				END_WIRE

				WIRE  (FromElementID := 12,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "CVEUMin")
				END_WIRE

				WIRE  (FromElementID := 13,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "DevHLimit")
				END_WIRE

				WIRE  (FromElementID := 14,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "DevLLimit")
				END_WIRE

				WIRE  (FromElementID := 15,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "EnableIn")
				END_WIRE

				WIRE  (FromElementID := 16,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "OperAutoReq")
				END_WIRE

				WIRE  (FromElementID := 16,
				       FromParameter := "",
				       ToElementID := 41,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 17,
				       FromParameter := "",
				       ToElementID := 36,
				       ToParameter := "CVOper")
				END_WIRE

				WIRE  (FromElementID := 18,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "CVOper")
				END_WIRE

				WIRE  (FromElementID := 19,
				       FromParameter := "",
				       ToElementID := 39,
				       ToParameter := "InRawMax")
				END_WIRE

				WIRE  (FromElementID := 20,
				       FromParameter := "",
				       ToElementID := 39,
				       ToParameter := "InRawMin")
				END_WIRE

				WIRE  (FromElementID := 21,
				       FromParameter := "",
				       ToElementID := 39,
				       ToParameter := "InEUMax")
				END_WIRE

				WIRE  (FromElementID := 22,
				       FromParameter := "",
				       ToElementID := 39,
				       ToParameter := "InEUMin")
				END_WIRE

				WIRE  (FromElementID := 23,
				       FromParameter := "",
				       ToElementID := 40,
				       ToParameter := "InRawMax")
				END_WIRE

				WIRE  (FromElementID := 24,
				       FromParameter := "",
				       ToElementID := 40,
				       ToParameter := "InRawMin")
				END_WIRE

				WIRE  (FromElementID := 25,
				       FromParameter := "",
				       ToElementID := 40,
				       ToParameter := "InEUMax")
				END_WIRE

				WIRE  (FromElementID := 26,
				       FromParameter := "",
				       ToElementID := 40,
				       ToParameter := "InEUMin")
				END_WIRE

				WIRE  (FromElementID := 27,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "EnableIn")
				END_WIRE

				WIRE  (FromElementID := 28,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "CVEUMax")
				END_WIRE

				WIRE  (FromElementID := 29,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "CVEUMin")
				END_WIRE

				WIRE  (FromElementID := 30,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "DevLLimit")
				END_WIRE

				WIRE  (FromElementID := 31,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "CVInitReq")
				END_WIRE

				WIRE  (FromElementID := 32,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "DevHLimit")
				END_WIRE

				WIRE  (FromElementID := 33,
				       FromParameter := "",
				       ToElementID := 37,
				       ToParameter := "OperAutoReq")
				END_WIRE

				WIRE  (FromElementID := 33,
				       FromParameter := "",
				       ToElementID := 42,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 34,
				       FromParameter := "Out",
				       ToElementID := 36,
				       ToParameter := "CVSetPrevious")
				END_WIRE

				WIRE  (FromElementID := 35,
				       FromParameter := "Out",
				       ToElementID := 37,
				       ToParameter := "CVSetPrevious")
				END_WIRE

				WIRE  (FromElementID := 36,
				       FromParameter := "CV",
				       ToElementID := 36,
				       ToParameter := "CVPrevious")
				END_WIRE

				WIRE  (FromElementID := 36,
				       FromParameter := "CVEU",
				       ToElementID := 40,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 36,
				       FromParameter := "CVEU",
				       ToElementID := 43,
				       ToParameter := "Source")
				END_WIRE

				WIRE  (FromElementID := 37,
				       FromParameter := "CV",
				       ToElementID := 37,
				       ToParameter := "CVPrevious")
				END_WIRE

				WIRE  (FromElementID := 37,
				       FromParameter := "CVEU",
				       ToElementID := 38,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 41,
				       FromParameter := "Out",
				       ToElementID := 36,
				       ToParameter := "OperManualReq")
				END_WIRE

				WIRE  (FromElementID := 42,
				       FromParameter := "Out",
				       ToElementID := 37,
				       ToParameter := "OperManualReq")
				END_WIRE

				WIRE  (FromElementID := 43,
				       FromParameter := "Dest",
				       ToElementID := 39,
				       ToParameter := "In")
				END_WIRE

				FEEDBACK_WIRE  (FromElementID := 36,
				                FromParameter := "CVHAlarm",
				                ToElementID := 34,
				                ToParameter := "In1")
				END_FEEDBACK_WIRE

				FEEDBACK_WIRE  (FromElementID := 36,
				                FromParameter := "CVLAlarm",
				                ToElementID := 34,
				                ToParameter := "In2")
				END_FEEDBACK_WIRE

				FEEDBACK_WIRE  (FromElementID := 37,
				                FromParameter := "CVHAlarm",
				                ToElementID := 35,
				                ToParameter := "In1")
				END_FEEDBACK_WIRE

				FEEDBACK_WIRE  (FromElementID := 37,
				                FromParameter := "CVLAlarm",
				                ToElementID := 35,
				                ToParameter := "In2")
				END_FEEDBACK_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 740,
				       Y := 480,
				       Operand := "0",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 620,
				       Y := 720,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 140,
				       Y := 680,
				       Operand := "300",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 3,
				       X := 800,
				       Y := 380,
				       Operand := "AIC703.Val",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 4,
				       X := 260,
				       Y := 440,
				       Operand := "BRX_Comm_Toggle",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 5,
				       X := 300,
				       Y := 320,
				       Operand := "BRX_DO_SP",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 6,
				       X := 1380,
				       Y := 360,
				       Operand := "CondMedRawMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 7,
				       X := 1400,
				       Y := 380,
				       Operand := "CondMedRawMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 8,
				       X := 240,
				       Y := 600,
				       Operand := "ConditionedMedia_HiDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 9,
				       X := 220,
				       Y := 740,
				       Operand := "ConditionedMedia_LoDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 10,
				       X := 220,
				       Y := 640,
				       Operand := "ConditionedMedia_Running",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 11,
				       X := 1380,
				       Y := 400,
				       Operand := "P103.Cfg_MaxSpdRef",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 12,
				       X := 1400,
				       Y := 420,
				       Operand := "P103.Cfg_MinSpdRef",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 13,
				       X := 320,
				       Y := 360,
				       Operand := "PBSData.do_sp",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 14,
				       X := 820,
				       Y := 460,
				       Operand := "Start_ConditionedMedia_Initialize",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 15,
				       X := 520,
				       Y := 820,
				       Operand := "conditionedMedia_auto",
				       HideDescription := No)
				END_IREF

				BOR_BLOCK  (ID := 16,
				            X := 500,
				            Y := 480,
				            Operand := "BOR_03",
				            VisiblePins := "In1, In2, Out",
				            HideDescription := No)
				END_BOR_BLOCK

				PIDE_BLOCK  (ID := 17,
				             X := 880,
				             Y := 320,
				             Operand := "ConditionedMedia_PID",
				             VisiblePins := "EnableIn, PV, SPProg, SPOper, SPCascade, RatioProg, CVInitReq, CVInitValue, CVProg, CVPrevious, CVSetPrevious, CVEUMax, CVEUMin, FF, HandFB, DevHLimit, DevLLimit, ProgProgReq, ProgOperReq, ProgCasRatReq, ProgAutoReq, ProgManualReq, ProgOverrideReq, ProgHandReq, OperProgReq, OperOperReq, OperAutoReq, OperManualReq, CVEU, CVHAlarm, CVLAlarm, SP, PVHHAlarm, PVHAlarm, PVLAlarm, PVLLAlarm, PVROCPosAlarm, PVROCNegAlarm, DevHHAlarm, DevHAlarm, DevLAlarm, DevLLAlarm, ProgOper, CasRat, Auto, Manual, Override, Hand",
				             HideDescription := No,
				             AutotuneTag := "")
				END_PIDE_BLOCK

				SCL_BLOCK  (ID := 18,
				            X := 1420,
				            Y := 280,
				            Operand := "ConditionedMedia_Scaler",
				            VisiblePins := "In, InRawMax, InRawMin, InEUMax, InEUMin, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				SEL_BLOCK  (ID := 19,
				            X := 300,
				            Y := 540,
				            Operand := "SEL_01",
				            VisiblePins := "In1, In2, SelectorIn, Out",
				            HideDescription := No)
				END_SEL_BLOCK

				SEL_BLOCK  (ID := 20,
				            X := 300,
				            Y := 660,
				            Operand := "SEL_02",
				            VisiblePins := "In1, In2, SelectorIn, Out",
				            HideDescription := No)
				END_SEL_BLOCK

				SEL_BLOCK  (ID := 21,
				            X := 460,
				            Y := 280,
				            Operand := "SEL_05",
				            VisiblePins := "In1, In2, SelectorIn, Out",
				            HideDescription := No)
				END_SEL_BLOCK

				BNOT_FUNCTION  (ID := 22,
				                X := 580,
				                Y := 820)
				END_BNOT_FUNCTION

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 17,
				       ToParameter := "CVInitValue")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 17,
				       ToParameter := "ProgOperReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 19,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 20,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 3,
				       FromParameter := "",
				       ToElementID := 17,
				       ToParameter := "PV")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "",
				       ToElementID := 21,
				       ToParameter := "SelectorIn")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "",
				       ToElementID := 21,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "",
				       ToElementID := 18,
				       ToParameter := "InRawMax")
				END_WIRE

				WIRE  (FromElementID := 7,
				       FromParameter := "",
				       ToElementID := 18,
				       ToParameter := "InRawMin")
				END_WIRE

				WIRE  (FromElementID := 8,
				       FromParameter := "",
				       ToElementID := 19,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 9,
				       FromParameter := "",
				       ToElementID := 20,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 10,
				       FromParameter := "",
				       ToElementID := 19,
				       ToParameter := "SelectorIn")
				END_WIRE

				WIRE  (FromElementID := 10,
				       FromParameter := "",
				       ToElementID := 20,
				       ToParameter := "SelectorIn")
				END_WIRE

				WIRE  (FromElementID := 11,
				       FromParameter := "",
				       ToElementID := 18,
				       ToParameter := "InEUMax")
				END_WIRE

				WIRE  (FromElementID := 12,
				       FromParameter := "",
				       ToElementID := 18,
				       ToParameter := "InEUMin")
				END_WIRE

				WIRE  (FromElementID := 13,
				       FromParameter := "",
				       ToElementID := 21,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 14,
				       FromParameter := "",
				       ToElementID := 17,
				       ToParameter := "CVInitReq")
				END_WIRE

				WIRE  (FromElementID := 15,
				       FromParameter := "",
				       ToElementID := 17,
				       ToParameter := "OperAutoReq")
				END_WIRE

				WIRE  (FromElementID := 15,
				       FromParameter := "",
				       ToElementID := 17,
				       ToParameter := "ProgAutoReq")
				END_WIRE

				WIRE  (FromElementID := 15,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 16,
				       FromParameter := "Out",
				       ToElementID := 17,
				       ToParameter := "CVSetPrevious")
				END_WIRE

				WIRE  (FromElementID := 17,
				       FromParameter := "CVEU",
				       ToElementID := 17,
				       ToParameter := "CVPrevious")
				END_WIRE

				WIRE  (FromElementID := 17,
				       FromParameter := "CVEU",
				       ToElementID := 18,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 19,
				       FromParameter := "Out",
				       ToElementID := 17,
				       ToParameter := "DevHLimit")
				END_WIRE

				WIRE  (FromElementID := 20,
				       FromParameter := "Out",
				       ToElementID := 17,
				       ToParameter := "DevLLimit")
				END_WIRE

				WIRE  (FromElementID := 21,
				       FromParameter := "Out",
				       ToElementID := 17,
				       ToParameter := "SPOper")
				END_WIRE

				WIRE  (FromElementID := 22,
				       FromParameter := "Out",
				       ToElementID := 17,
				       ToParameter := "OperManualReq")
				END_WIRE

				WIRE  (FromElementID := 22,
				       FromParameter := "Out",
				       ToElementID := 17,
				       ToParameter := "ProgManualReq")
				END_WIRE

				FEEDBACK_WIRE  (FromElementID := 17,
				                FromParameter := "CVHAlarm",
				                ToElementID := 16,
				                ToParameter := "In1")
				END_FEEDBACK_WIRE

				FEEDBACK_WIRE  (FromElementID := 17,
				                FromParameter := "CVLAlarm",
				                ToElementID := 16,
				                ToParameter := "In2")
				END_FEEDBACK_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 360,
				       Y := 460,
				       Operand := "0",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 260,
				       Y := 640,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 380,
				       Y := 640,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 3,
				       X := 340,
				       Y := 360,
				       Operand := "TT700.Val",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 4,
				       X := 920,
				       Y := 460,
				       Operand := "TempEUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 5,
				       X := 940,
				       Y := 480,
				       Operand := "TempEUMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 6,
				       X := 920,
				       Y := 420,
				       Operand := "TempRawMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 7,
				       X := 940,
				       Y := 440,
				       Operand := "TempRawMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 8,
				       X := 380,
				       Y := 440,
				       Operand := "Temp_Initialize",
				       HideDescription := No)
				END_IREF

				BOR_BLOCK  (ID := 9,
				            X := 180,
				            Y := 460,
				            Operand := "BOR_01",
				            VisiblePins := "In1, In2, Out",
				            HideDescription := No)
				END_BOR_BLOCK

				PIDE_BLOCK  (ID := 10,
				             X := 440,
				             Y := 300,
				             Operand := "Temp_PID",
				             VisiblePins := "PV, SPProg, SPCascade, RatioProg, CVInitReq, CVInitValue, CVProg, CVPrevious, CVSetPrevious, CVEUMax, CVEUMin, FF, HandFB, ProgProgReq, ProgOperReq, ProgCasRatReq, ProgAutoReq, ProgManualReq, ProgOverrideReq, ProgHandReq, OperProgReq, OperOperReq, OperAutoReq, CVEU, CV, CVHAlarm, CVLAlarm, SP, PVHHAlarm, PVHAlarm, PVLAlarm, PVLLAlarm, PVROCPosAlarm, PVROCNegAlarm, DevHHAlarm, DevHAlarm, DevLAlarm, DevLLAlarm, ProgOper, CasRat, Auto, Manual, Override, Hand",
				             HideDescription := No,
				             AutotuneTag := "")
				END_PIDE_BLOCK

				SCL_BLOCK  (ID := 11,
				            X := 960,
				            Y := 340,
				            Operand := "Temp_Scaler",
				            VisiblePins := "In, InRawMax, InRawMin, InEUMax, InEUMin, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "CVInitValue")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "OperOperReq")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "ProgOperReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "OperAutoReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "ProgAutoReq")
				END_WIRE

				WIRE  (FromElementID := 3,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "PV")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "",
				       ToElementID := 11,
				       ToParameter := "InEUMax")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "",
				       ToElementID := 11,
				       ToParameter := "InEUMin")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "",
				       ToElementID := 11,
				       ToParameter := "InRawMax")
				END_WIRE

				WIRE  (FromElementID := 7,
				       FromParameter := "",
				       ToElementID := 11,
				       ToParameter := "InRawMin")
				END_WIRE

				WIRE  (FromElementID := 8,
				       FromParameter := "",
				       ToElementID := 10,
				       ToParameter := "CVInitReq")
				END_WIRE

				WIRE  (FromElementID := 9,
				       FromParameter := "Out",
				       ToElementID := 10,
				       ToParameter := "CVSetPrevious")
				END_WIRE

				WIRE  (FromElementID := 10,
				       FromParameter := "CV",
				       ToElementID := 10,
				       ToParameter := "CVPrevious")
				END_WIRE

				WIRE  (FromElementID := 10,
				       FromParameter := "CVEU",
				       ToElementID := 11,
				       ToParameter := "In")
				END_WIRE

				FEEDBACK_WIRE  (FromElementID := 10,
				                FromParameter := "CVHAlarm",
				                ToElementID := 9,
				                ToParameter := "In1")
				END_FEEDBACK_WIRE

				FEEDBACK_WIRE  (FromElementID := 10,
				                FromParameter := "CVLAlarm",
				                ToElementID := 9,
				                ToParameter := "In2")
				END_FEEDBACK_WIRE

			END_SHEET

			SHEET  (Name := "")
				IREF  (ID := 0,
				       X := 680,
				       Y := 680,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 1,
				       X := 680,
				       Y := 720,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 2,
				       X := 1400,
				       Y := 700,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 3,
				       X := 1400,
				       Y := 840,
				       Operand := "1",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 4,
				       X := 120,
				       Y := 580,
				       Operand := "100",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 5,
				       X := 1200,
				       Y := 840,
				       Operand := "100",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 6,
				       X := 780,
				       Y := 460,
				       Operand := "50",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 7,
				       X := 1380,
				       Y := 480,
				       Operand := "BRX_Level_EUMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 8,
				       X := 1380,
				       Y := 500,
				       Operand := "BRX_Level_EUmin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 9,
				       X := 320,
				       Y := 620,
				       Operand := "BRX_Level_HiDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 10,
				       X := 800,
				       Y := 440,
				       Operand := "BRX_Level_Initialize",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 11,
				       X := 320,
				       Y := 780,
				       Operand := "BRX_Level_LoDev",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 12,
				       X := 1360,
				       Y := 440,
				       Operand := "BRX_Level_RawMax",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 13,
				       X := 1360,
				       Y := 460,
				       Operand := "BRX_Level_RawMin",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 14,
				       X := 760,
				       Y := 360,
				       Operand := "LIT801.Val",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 15,
				       X := 1260,
				       Y := 780,
				       Operand := "Perfusion_Level_Aggression",
				       HideDescription := No)
				END_IREF

				IREF  (ID := 16,
				       X := 180,
				       Y := 700,
				       Operand := "Perfusion_Running",
				       HideDescription := No)
				END_IREF

				OREF  (ID := 17,
				       X := 1580,
				       Y := 700,
				       Operand := "BRX_Level_EUMax",
				       HideDescription := No)
				END_OREF

				OREF  (ID := 18,
				       X := 1590,
				       Y := 840,
				       Operand := "BRX_Level_EUmin",
				       HideDescription := No)
				END_OREF

				ADD_BLOCK  (ID := 19,
				            X := 1440,
				            Y := 640,
				            Operand := "ADD_01",
				            VisiblePins := "SourceA, SourceB, Dest",
				            HideDescription := No)
				END_ADD_BLOCK

				BOR_BLOCK  (ID := 20,
				            X := 600,
				            Y := 460,
				            Operand := "BOR_04",
				            VisiblePins := "In1, In2, Out",
				            HideDescription := No)
				END_BOR_BLOCK

				DIV_BLOCK  (ID := 21,
				            X := 1300,
				            Y := 720,
				            Operand := "DIV_01",
				            VisiblePins := "SourceA, SourceB, Dest",
				            HideDescription := No)
				END_DIV_BLOCK

				PIDE_BLOCK  (ID := 22,
				             X := 860,
				             Y := 300,
				             Operand := "BRX_LevelPID",
				             VisiblePins := "PV, SPProg, SPCascade, RatioProg, CVInitReq, CVInitValue, CVProg, CVPrevious, CVSetPrevious, FF, HandFB, DevHLimit, DevLLimit, ProgProgReq, ProgOperReq, ProgCasRatReq, ProgAutoReq, ProgManualReq, ProgOverrideReq, ProgHandReq, OperProgReq, OperOperReq, OperAutoReq, CVEU, CVHAlarm, CVLAlarm, SP, PVHHAlarm, PVHAlarm, PVLAlarm, PVLLAlarm, PVROCPosAlarm, PVROCNegAlarm, DevHHAlarm, DevHAlarm, DevLAlarm, DevLLAlarm, ProgOper, CasRat, Auto, Manual, Override, Hand",
				             HideDescription := No,
				             AutotuneTag := "")
				END_PIDE_BLOCK

				SCL_BLOCK  (ID := 23,
				            X := 1440,
				            Y := 360,
				            Operand := "BRX_Level_Scaler",
				            VisiblePins := "In, InRawMax, InRawMin, InEUMax, InEUMin, Out",
				            HideDescription := No)
				END_SCL_BLOCK

				SEL_BLOCK  (ID := 24,
				            X := 400,
				            Y := 540,
				            Operand := "SEL_03",
				            VisiblePins := "In1, In2, SelectorIn, Out",
				            HideDescription := No)
				END_SEL_BLOCK

				SEL_BLOCK  (ID := 25,
				            X := 400,
				            Y := 700,
				            Operand := "SEL_04",
				            VisiblePins := "In1, In2, SelectorIn, Out",
				            HideDescription := No)
				END_SEL_BLOCK

				SUB_BLOCK  (ID := 26,
				            X := 1440,
				            Y := 780,
				            Operand := "SUB_01",
				            VisiblePins := "SourceA, SourceB, Dest",
				            HideDescription := No)
				END_SUB_BLOCK

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "OperOperReq")
				END_WIRE

				WIRE  (FromElementID := 0,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "ProgOperReq")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "OperAutoReq")
				END_WIRE

				WIRE  (FromElementID := 1,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "ProgAutoReq")
				END_WIRE

				WIRE  (FromElementID := 2,
				       FromParameter := "",
				       ToElementID := 19,
				       ToParameter := "SourceA")
				END_WIRE

				WIRE  (FromElementID := 3,
				       FromParameter := "",
				       ToElementID := 26,
				       ToParameter := "SourceA")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "",
				       ToElementID := 24,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 4,
				       FromParameter := "",
				       ToElementID := 25,
				       ToParameter := "In1")
				END_WIRE

				WIRE  (FromElementID := 5,
				       FromParameter := "",
				       ToElementID := 21,
				       ToParameter := "SourceB")
				END_WIRE

				WIRE  (FromElementID := 6,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "CVInitValue")
				END_WIRE

				WIRE  (FromElementID := 7,
				       FromParameter := "",
				       ToElementID := 23,
				       ToParameter := "InEUMax")
				END_WIRE

				WIRE  (FromElementID := 8,
				       FromParameter := "",
				       ToElementID := 23,
				       ToParameter := "InEUMin")
				END_WIRE

				WIRE  (FromElementID := 9,
				       FromParameter := "",
				       ToElementID := 24,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 10,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "CVInitReq")
				END_WIRE

				WIRE  (FromElementID := 11,
				       FromParameter := "",
				       ToElementID := 25,
				       ToParameter := "In2")
				END_WIRE

				WIRE  (FromElementID := 12,
				       FromParameter := "",
				       ToElementID := 23,
				       ToParameter := "InRawMax")
				END_WIRE

				WIRE  (FromElementID := 13,
				       FromParameter := "",
				       ToElementID := 23,
				       ToParameter := "InRawMin")
				END_WIRE

				WIRE  (FromElementID := 14,
				       FromParameter := "",
				       ToElementID := 22,
				       ToParameter := "PV")
				END_WIRE

				WIRE  (FromElementID := 15,
				       FromParameter := "",
				       ToElementID := 21,
				       ToParameter := "SourceA")
				END_WIRE

				WIRE  (FromElementID := 16,
				       FromParameter := "",
				       ToElementID := 24,
				       ToParameter := "SelectorIn")
				END_WIRE

				WIRE  (FromElementID := 16,
				       FromParameter := "",
				       ToElementID := 25,
				       ToParameter := "SelectorIn")
				END_WIRE

				WIRE  (FromElementID := 19,
				       FromParameter := "Dest",
				       ToElementID := 17,
				       ToParameter := "")
				END_WIRE

				WIRE  (FromElementID := 20,
				       FromParameter := "Out",
				       ToElementID := 22,
				       ToParameter := "CVSetPrevious")
				END_WIRE

				WIRE  (FromElementID := 21,
				       FromParameter := "Dest",
				       ToElementID := 19,
				       ToParameter := "SourceB")
				END_WIRE

				WIRE  (FromElementID := 21,
				       FromParameter := "Dest",
				       ToElementID := 26,
				       ToParameter := "SourceB")
				END_WIRE

				WIRE  (FromElementID := 22,
				       FromParameter := "CVEU",
				       ToElementID := 22,
				       ToParameter := "CVPrevious")
				END_WIRE

				WIRE  (FromElementID := 22,
				       FromParameter := "CVEU",
				       ToElementID := 23,
				       ToParameter := "In")
				END_WIRE

				WIRE  (FromElementID := 24,
				       FromParameter := "Out",
				       ToElementID := 22,
				       ToParameter := "DevHLimit")
				END_WIRE

				WIRE  (FromElementID := 25,
				       FromParameter := "Out",
				       ToElementID := 22,
				       ToParameter := "DevLLimit")
				END_WIRE

				WIRE  (FromElementID := 26,
				       FromParameter := "Dest",
				       ToElementID := 18,
				       ToParameter := "")
				END_WIRE

				FEEDBACK_WIRE  (FromElementID := 22,
				                FromParameter := "CVHAlarm",
				                ToElementID := 20,
				                ToParameter := "In1")
				END_FEEDBACK_WIRE

				FEEDBACK_WIRE  (FromElementID := 22,
				                FromParameter := "CVLAlarm",
				                ToElementID := 20,
				                ToParameter := "In2")
				END_FEEDBACK_WIRE

			END_SHEET

		END_FBD_ROUTINE

		ROUTINE TempControl 
				N: XIO(Temp_Initialize)ONS(TempOnOns)[OTU(Heater_Output.PCmd_Unlock) ,OTL(Heater_Output.PCmd_Lock) ];
				N: XIC(Temp_Initialize)ONS(TempOffOns)[OTU(Heater_Output.PCmd_Lock) ,OTL(Heater_Output.PCmd_Unlock) ];
				N: XIC(Estop_Active_Flag)OTL(Temp_Initialize);
		END_ROUTINE

		CHILD_PROGRAMS
		END_CHILD_PROGRAMS

	END_PROGRAM

	PROGRAM TimeandDate (MAIN := "Main",
	                     MODE := 0,
	                     DisableFlag := 0,
	                     UseAsFolder := 0)
		TAG
		END_TAG

		ROUTINE Cal_Time_and_Date 
				N: MID(LocalDateTimeString,1,2,file_test)[EQU(file_test,' ') MID(LocalDateTimeString,1,1,cal_day) CONCAT(zero,cal_day,cal_date) MID(LocalDateTimeString,3,3,cal_month) MID(LocalDateTimeString,4,7,cal_year) ,NEQ(file_test,' ') MID(LocalDateTimeString,2,1,cal_day) MID(LocalDateTimeString,3,4,cal_month) MID(LocalDateTimeString,4,8,cal_year) ]CONCAT(cal_day,cal_month,cal_date)CONCAT(cal_date,cal_year,cal_date);
		END_ROUTINE

		ROUTINE Main 
				RC: "PLC Date and Time";
				N: GSV(WallClockTime,,LocalDateTime,PLCStatus.LocalDateTime[0]);
				N: [COP(PLCStatus.LocalDateTime[0],LocalDateTimeRef.Yr,1) ,COP(PLCStatus.LocalDateTime[1],LocalDateTimeRef.Mo,1) ,COP(PLCStatus.LocalDateTime[2],LocalDateTimeRef.Da,1) ,COP(PLCStatus.LocalDateTime[3],LocalDateTimeRef.Hr,1) ,COP(PLCStatus.LocalDateTime[4],LocalDateTimeRef.Min,1) ,COP(PLCStatus.LocalDateTime[5],LocalDateTimeRef.Sec,1) ,COP(PLCStatus.LocalDateTime[6],LocalDateTimeRef.uSec,1) ,T_TtoS(LocalDateTimeTtoS,LocalDateTimeRef,LocalDateTimeString) ];
				N: JSR(Cal_Time_and_Date,0);
				N: JSR(Module_Status,0);
		END_ROUTINE

		ROUTINE Module_Status 
		END_ROUTINE

		CHILD_PROGRAMS
		END_CHILD_PROGRAMS

	END_PROGRAM

	TASK CMs_100ms (Type := PERIODIC,
	                Rate := 100,
	                Priority := 10,
	                Watchdog := 500,
	                DisableUpdateOutputs := No,
	                InhibitTask := No)
			CM_PBS;
	END_TASK

	TASK Other_1000ms (Type := PERIODIC,
	                   Rate := 1000,
	                   Priority := 10,
	                   Watchdog := 10000,
	                   DisableUpdateOutputs := No,
	                   InhibitTask := No)
			PIDs;
			TimeandDate;
	END_TASK

CONFIG CST(SystemTimeMasterID := 0) END_CONFIG

CONFIG EthernetPort1(Label := "A1",
	                             PortEnabled := 1) END_CONFIG

CONFIG EthernetPort2(Label := "A2",
	                             PortEnabled := 1) END_CONFIG

CONFIG TimeSynchronize(Priority1 := 128,
	                                 Priority2 := 128,
	                                 PTPEnable := 0) END_CONFIG

CONFIG WallClockTime(LocalTimeAdjustment := 0,
	                     TimeZone := 0) END_CONFIG

END_CONTROLLER

